<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: How to Avoid Resets When Using VBOs</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>How to Avoid Resets When Using VBOs</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>How to Avoid Resets When Using VBOs  (2/27/97)</H3><DL><DD>Q:    When writing large amounts of information to virtual binary objects (VBOs), my Newton device sometimes resets.  What is going wrong?<BR><BR>A:    The problem happens because of how the Newton OS manages the memory for VBOs. Writing to VBOs in low memory conditions can sometimes cause the device to reset because no free pages are available for other OS operations.<BR>    <BR>    To work around this problem, you can periodically call the global function <CODE>ClearVBOCache</CODE> while modifying VBOs. You can also work around the problem by putting the VBO in a soup entry and using <CODE>EntryChangeXmit</CODE> or <CODE>EntryFlushXmit</CODE>.<BR><BR>    In all versions of the Newton 2.x OS released to date, VBOs (including packages) are managed in 1K pages. When you write to a VBO, the "dirty" pages can remain in the system heap, taking up space.  <CODE>ClearVBOCache</CODE> takes a reference to a VBO as an argument, and moves the dirty pages for a given VBO to the store, freeing up the system memory.  Note that this function does not commit the changes to the VBO, while <CODE>EntryChangeXmit</CODE> and <CODE>EntryFlushXmit</CODE> do commit the changes.<BR><BR>    The likelihood of the problem depends on the amount of system memory currently available and how many pages of VBOs are modified. We recommend that you modify no more than 32 pages of VBOs before committing the changes or calling <CODE>ClearVBOCache</CODE>. For example, modifying 32K of contiguous data, or a single byte in 32 different pages of one VBO, or even a single byte in 32 different VBOs all modify 32 total pages of VBO data.  Don't do this too often, though.  Calling <CODE>ClearVBOCache</CODE> repeatedly for modifications to the same page of a VBO or when there are only a few modified pages will needlessly slow the machine.<BR><BR>    If you are experiencing this problem, you should consider redesigning your application to minimize the amount of uncommited VBO data. When finished with a VBO, commit it to a soup entry as soon as possible or let it become unreferenced.</DL>
/*	File:		CardSpecificDRVR.c	Contains:	Interface to PCMCIA cards that use a 16450 serial chip, typically for				connecting to on-card modems.		Copyright:	© 1992-1994 by Apple Computer, Inc., all rights reserved.*/#ifndef __CONFIGPCMCIA_H	#include "ConfigPCMCIA.h"#endif#ifdef	hasPCMCIA#ifndef	__SERIALCHIPSAMPLE_H	#include "CardSpecificDRVR.impl.h"#endif#ifndef __NEWTONDEBUG_H	#include "NewtonDebug.h"#endif#ifndef	__COMMERRORS_H	#include "CommErrors.h"#endif#ifndef __NEWTMEMORY_H	#include "NewtMemory.h"#endif#ifndef	__SERIALOPTIONS_H	#include "SerialOptions.h"#endif#ifndef	__NAMESERVER_H	#include "NameServer.h"#endif#ifndef	__HARDWARE_H	#include "Hardware.h"#endif#ifndef __VIRTUALMEMORY_H	#include "VirtualMemory.h"#endif#ifndef	__CARDSOCKET_H	#include "CardSocket.h"#endif#ifndef __CARDHANDLER_H	#include "CardHandler.h"#endif////  "Card Specific" call selectors...//#define kCardPowerOn 	1#define kCardPowerOff 	2//-------------------------------// 16450 register base addr offsets//-------------------------------#define kReceiveBufReg 3#define kTransmitBufReg 3#define kInterruptEnbReg 2#define kInterruptIDReg 1#define kLineControlReg 0#define kModemControlReg 7#define kLineStatusReg 6#define kModemStatusReg 5#define kScratchReg 4// if kLCRegBaudDivAccess bit in LineControlReg is 1:#define kBaudDivisorLSBReg 3#define kBaudDivisorMSBReg 2//-------------------------------// 16450 register bit definitions//-------------------------------// InterruptEnbReg#define kIERegRxCharAvailable	(0x00000001)#define kIERegTxBufEmpty		(0x00000002)#define kIERegRcvLineStatus		(0x00000004)#define kIERegModemStatus		(0x00000008)#define kEnableAllInts			(0x0000000f)// InterruptIDReg#define kIIDRegIntPendingNot	(0x00000001)#define kIIDRegIntIDMask		(0x00000006)#define kModemStatusInterrupt	(0x00000000)#define kTxBufEmptyInterrupt	(0x00000002)#define kRxCharAvailInterrupt	(0x00000004)#define kLineStatusInterrupt	(0x00000006)// LineControlReg#define kLCRegWordSelectMask	(0x00000003)#define kLCRegStopBits   		(0x00000004)#define kLCRegParityEnb 		(0x00000008)#define kLCRegEvenParity		(0x00000010)#define kLCRegStickParity		(0x00000020)#define kLCRegSetBreak			(0x00000040)#define kLCRegBaudDivAccess		(0x00000080)// ModemControlReg#define kMCRegDTR				(0x00000001)#define kMCRegRTS				(0x00000002)#define kMCRegOut1				(0x00000004)#define kMCRegOut2				(0x00000008)#define kMCRegLoopBack			(0x00000010)// LineStatusReg#define kLSRegRxCharAvailable	(0x00000001)#define kLSRegOverrunErr		(0x00000002)#define kLSRegParityErr 		(0x00000004)#define kLSRegFramingErr		(0x00000008)#define kLSRegBreakDetect		(0x00000010)#define kLSRegTxBufEmpty		(0x00000020)#define kLSRegTxAllSent 		(0x00000040)#define kLineStatusErrMask		(0x0000000E)#define kLSRegExtStsMask		(0x00000071)#define kLineStatusVolatileBits (0x0000001E)// ModemStatusReg#define kMCRegDeltaCTS			(0x00000001)#define kMCRegDeltaDSR			(0x00000002)#define kMCRegTrailingEdgeRI	(0x00000004)#define kMCRegDeltaDCD			(0x00000008)#define kMCRegCTS				(0x00000010)#define kMCRegDSR				(0x00000020)#define kMCRegRI				(0x00000040)#define kMCRegDCD				(0x00000080)// Serial chips may not want to be accessed too quickly: we try to keep our// accesses fairly slow --- the ARM can potentially access every couple hundred usecs...#define kModemIOReadDelay 		(1*kMicroseconds)#define kModemIOWriteDelay 		(1*kMicroseconds)PROTOCOL_IMPL_SOURCE_MACRO(_CardSpecificDriverClassName_)		/* magic stuff, do not touch */TSerialChip* _CardSpecificDriverClassName_::New(){	fBaseRegPtr = nil;								// serial chip registers	fSerialCardHandler = nil;						// card handler for this...	fSerialCardSocket = nil;	fSerTool = nil;									// filled in at InstallChipHandler time....	fCardRemoved = false;	fInitFlag = false;	ResetState();									// reset current state...	fPowerIsOn = false;	return this;	}void _CardSpecificDriverClassName_::ResetState(){	fSavedLineStatus = 0;							// accumulated line status	fNewLoBaudConst = 0x0C;							// default to 9600 bits/sec	fNewHiBaudConst = 0x00;	fNewLineControlBits = 0x03;						// default to 8 data bits/1 stop bit/no parity	fNewModemControlBits = kMCRegDTR+kMCRegRTS+kMCRegOut2;	// IBM PC Serial port uses Out2 to control interrupt generation...	fInterruptEnableBits = kEnableAllInts;}void _CardSpecificDriverClassName_::Delete(){	if (fInitFlag) {								// if we were successfully initialized...		if (fSerTool) {			PublicEnterAtomic();			CardRemoved();							// notify any connected serial tool!			PublicExitAtomic();		}		fSerialCardSocket->DeregisterSocketInterrupt(kSocketCardIREQInt);		fInitFlag = false;		TUNameServer NameServer;		NameServer.UnRegisterName("1", "Modem");		long result = UnlockHeapRange((VAddr)this, (VAddr)((char*)this+sizeof(*this)));		XASSERT(result == noErr);					// remember to unlock ourself!	}}void _CardSpecificDriverClassName_::CardRemoved(void) // async "card gone" call...{	// This routine is called with interrupts disabled.	fCardRemoved = true;	// If we were successfully initialized, turn off interrupts	// and notify serial tool! Take care not to access the card (it may abort)...	if (fInitFlag && fSerTool) {		fSerialCardSocket->DisableSocketInterrupt(kSocketCardIREQInt);		(fSerToolIntHandlers.ExtStsIntHandler)(fSerTool);	}}NewtonErr _CardSpecificDriverClassName_::IntProc(void *object, TCardSocket* socket){	return ((_CardSpecificDriverClassName_*)object)->SerialInterrupt(socket);}NewtonErr _CardSpecificDriverClassName_::Init(TCardSocket* theCardSocket, TCardHandler* theCardHandler, UByte* baseRegAddr){	// Lock down in virtual memory since this object is accessed at IRQ interrupt level	long result = LockHeapRange((VAddr)this, (VAddr)((char*)this+sizeof(*this)), false);	XREQUIRENOT(result, Fail_LockHeapRange);	// Register a pointer to this object with the name server.	{		TUNameServer NameServer;		result =  NameServer.RegisterName("1", "Modem", (ULong)this, 1);	}	XREQUIRENOT(result, Fail_RegisterName);	fBaseRegPtr = baseRegAddr;	fSerialCardHandler = theCardHandler;	fSerialCardSocket = theCardSocket;	fSerialCardSocket->RegisterSocketInterrupt(kSocketCardIREQInt, GETINTPROCADDR(), this);	fInitFlag = true;Fail_RegisterName:Fail_LockHeapRange:	return result;}NewtonErr _CardSpecificDriverClassName_::InstallChipHandler(void* serialTool, SCCChannelInts* intHandlers){	if (fSerTool != nil)		return kSerErr_ChannelInUse;	fSerTool = serialTool;	fSerToolIntHandlers = *intHandlers;	return noErr;}NewtonErr _CardSpecificDriverClassName_::RemoveChipHandler(void* serialTool){	if (fSerTool != serialTool)		return kSerErr_NotCurrentOwner;	fSerTool = nil;	return noErr;}void _CardSpecificDriverClassName_::PutByte(UByte nextChar) 	// ** only called if TxBufEmpty() or TxBE int{	WriteSerReg(kTransmitBufReg, nextChar);}void _CardSpecificDriverClassName_::ResetTxBEmpty() 			// ** called if TxBE int and no more to write{	// should already be reset.}UByte _CardSpecificDriverClassName_::GetByte() 					// ** only called if RxBufFull() or RxBF int{	return ReadSerReg(kReceiveBufReg);}Boolean _CardSpecificDriverClassName_::TxBufEmpty() 			// ** is transmitter ready for another byte?{	return ((CheckLineStatusReg() & kLSRegTxBufEmpty) != 0);}Boolean _CardSpecificDriverClassName_::RxBufFull() 				// ** does receiver have a byte available?{	return ((CheckLineStatusReg() & kLSRegRxCharAvailable) != 0);}RxErrorStatus _CardSpecificDriverClassName_::GetRxErrorStatus()  // ** return receive error status indications for current												   				 //  byte available - this resets the status{	UByte errByte = CheckLineStatusReg() & kLineStatusErrMask;	// read line status reg, keep error bits	RxErrorStatus result = 0;	fSavedLineStatus &= ~kLineStatusErrMask;					// reset saved status	if (errByte != 0) {		if (errByte & kLSRegParityErr)			result |= kSerialRxParityErr;		if (errByte & kLSRegOverrunErr)			result |= kSerialRxOverrun;		if (errByte & kLSRegFramingErr)			result |= kSerialRxFramingErr;	}	return result;}SerialStatus _CardSpecificDriverClassName_::GetSerialStatus() 	// get status bits{	if (fCardRemoved == true)		return kSerialChipGone;									// signal card gone!	UByte result = 0;	UByte lineStatus = CheckLineStatusReg();	if (lineStatus & kLSRegRxCharAvailable)		result |= kSerialRxCharAvailable;	if (lineStatus & kLSRegTxBufEmpty)		result |= kSerialTxBufferEmpty;	if (lineStatus & kLSRegBreakDetect)		result |= kSerialBreak;	UByte modemStatus = CheckModemStatusReg();	if ((modemStatus & kMCRegCTS) == 0)				// flip for negative logic		result |= kSerialCTSNegated;	if (modemStatus & kMCRegDCD)		result |= kSerialDCDAsserted;	return result;}void _CardSpecificDriverClassName_::ResetSerialStatus() // reset latched status bits{	fSavedLineStatus &= ~kLSRegExtStsMask;				// only zero ext/status bit saved...}void _CardSpecificDriverClassName_::SetSerialOutputs(SerialOutputControl serOut){	if (serOut & kSerialOutputDTR)		fNewModemControlBits += kMCRegDTR;	if (serOut & kSerialOutputRTS)		fNewModemControlBits += kMCRegRTS;	WriteSerReg(kModemControlReg, fNewModemControlBits);}void _CardSpecificDriverClassName_::ClearSerialOutputs(SerialOutputControl serOut){	if (serOut & kSerialOutputDTR)		fNewModemControlBits &= ~kMCRegDTR;	if (serOut & kSerialOutputRTS)		fNewModemControlBits &= ~kMCRegRTS;	WriteSerReg(kModemControlReg, fNewModemControlBits);}SerialOutputControl _CardSpecificDriverClassName_::GetSerialOutputs(){	SerialOutputControl outBits = 0;	UByte modemControlBits = ReadSerReg(kModemControlReg);	if (modemControlBits & kMCRegDTR)		outBits += kSerialOutputDTR;	if (modemControlBits & kMCRegRTS)		outBits += kSerialOutputRTS;	return outBits;}void _CardSpecificDriverClassName_::PowerOff() 		// turn power off (may not be called){	//NOTE: This is not called with interrupts disabled!	fSerialCardSocket->DisableSocketInterrupt(kSocketCardIREQInt);	SetInterruptEnable(false);	fSerialCardHandler->CardSpecific(kCardPowerOff);// let the card handler do the power-off...	fPowerIsOn = false; 							// i/o address space will disappear!}void _CardSpecificDriverClassName_::PowerOn() 		// turn power back on and reconfigure{	// NOTE: This is not called with interrupts disabled!	ResetState();									// clear state back to reset values	fPowerIsOn = true;	fSerialCardHandler->CardSpecific(kCardPowerOn);	// let the card handler power on for us...	fSerialCardSocket->EnableSocketInterrupt(kSocketCardIREQInt);}Boolean _CardSpecificDriverClassName_::PowerIsOn() 	// is serial chip powered?{	return fPowerIsOn;}void _CardSpecificDriverClassName_::SetInterruptEnable(Boolean enable)  // ** enable/disable interrupts{	UByte enableBits = 0;	if (enable)		enableBits = kEnableAllInts;	fInterruptEnableBits = enableBits;	WriteSerReg(kInterruptEnbReg, enableBits);}void _CardSpecificDriverClassName_::Reset() 		// **{	SetInterruptEnable(false);						// Just turn off interrupts for now...}void _CardSpecificDriverClassName_::SetBreak(Boolean assert){	if (assert)		fNewLineControlBits |= kLCRegSetBreak;	else		fNewLineControlBits &= ~kLCRegSetBreak;	WriteSerReg(kLineControlReg, fNewLineControlBits);}InterfaceSpeed _CardSpecificDriverClassName_::SetSpeed(BitRate bitsPerSec){	ULong brgClk = 1843200/16;						// assume standard clock rate for this chip	if (bitsPerSec > k57600bps)						// no faster than 57600 bits/sec		bitsPerSec = k57600bps;	if (bitsPerSec < 2)								// no slower than 2 bits/sec		bitsPerSec = k300bps;	ULong BRGConstant = brgClk/bitsPerSec;	fNewLoBaudConst = (UByte)BRGConstant;	fNewHiBaudConst = (UByte)(BRGConstant/256);	return ((InterfaceSpeed)(brgClk/BRGConstant));}void _CardSpecificDriverClassName_::SetIOParms(TCMOSerialIOParms* opt) 	// set parity, data bits, stop bits{	ULong parity, stopBits, dataBits;	switch(opt->fDataBits)	{		case k5DataBits:			dataBits = 0;			break;		case k6DataBits:			dataBits = 1;			break;		case k7DataBits:			dataBits = 2;			break;		case k8DataBits:					// NOTE: 8 is the default		default:			dataBits = 3;			break;	}	switch(opt->fParity)	{		case kOddParity:			parity = kLCRegParityEnb;			break;		case kEvenParity:			parity = kLCRegParityEnb + kLCRegEvenParity;			break;		case kNoParity:						// NOTE: No parity is the default		default:			parity = 0;			break;	}	switch(opt->fStopBits)	{		case k2StopBits:					// NOTE: if data bits == 5, this will be 1.5 stop bits			stopBits = kLCRegStopBits;			break;		case k1StopBits:					// NOTE: 1 stop bit is the default		default:			stopBits = 0;			break;	}	fNewLineControlBits = (UChar)(parity + stopBits + dataBits);}void _CardSpecificDriverClassName_::Reconfigure() 	// ** reconfigure based on speed, IOParms{	// This is called after PowerOn by the serial driver, with interrupts disabled.	// This is also called when the serial driver is reconfigured for a different data rate.	WriteSerReg(kLineControlReg, fNewLineControlBits | kLCRegBaudDivAccess);	WriteSerReg(kBaudDivisorLSBReg, fNewLoBaudConst);	WriteSerReg(kBaudDivisorMSBReg, fNewHiBaudConst);	WriteSerReg(kLineControlReg, fNewLineControlBits);	WriteSerReg(kModemControlReg, fNewModemControlBits);	WriteSerReg(kInterruptEnbReg, fInterruptEnableBits);}UByte _CardSpecificDriverClassName_::CheckLineStatusReg(){	if (fBaseRegPtr == nil) 						// protect against card going away...		return 0;	UByte newStatus = ReadSerReg(kLineStatusReg);	fSavedLineStatus &= kLineStatusVolatileBits;	// clear bits which are not reset by reading this reg	fSavedLineStatus |= newStatus; 					// remember volatile bits	return fSavedLineStatus;}UByte _CardSpecificDriverClassName_::CheckModemStatusReg(){	return ReadSerReg(kModemStatusReg);}NewtonErr _CardSpecificDriverClassName_::SerialInterrupt(TCardSocket*){	UByte intPending = ReadSerReg(kInterruptIDReg);	while ((intPending & kIIDRegIntPendingNot) == 0) {		SCCIntHandler serToolInt = nil;		switch (intPending & kIIDRegIntIDMask) {			case kLineStatusInterrupt:				serToolInt = fSerToolIntHandlers.RxCSpecialIntHandler;				UByte lineStatus = CheckLineStatusReg();				if ((lineStatus & kLineStatusErrMask) == 0)			// if not parity/overrun/framing error					if ((lineStatus & kLSRegBreakDetect) != 0)		// should be break... (which is ext/sts for SCC)						serToolInt = fSerToolIntHandlers.ExtStsIntHandler;					else						DebugStr("Unknown line status int in SerialChipSample!");				break;			case kRxCharAvailInterrupt:				serToolInt = fSerToolIntHandlers.RxCAvailIntHandler;				break;			case kTxBufEmptyInterrupt:				serToolInt = fSerToolIntHandlers.TxBEmptyIntHandler;				break;			case kModemStatusInterrupt:				serToolInt = fSerToolIntHandlers.ExtStsIntHandler;				break;		}		(serToolInt)(fSerTool);						// invoke proper handler		intPending = ReadSerReg(kInterruptIDReg);	// loop until all interrupts are serviced	}	return noErr;}void _CardSpecificDriverClassName_::WriteSerReg(ULong regNum, UByte data){	fBaseRegPtr[regNum] = data;}UByte _CardSpecificDriverClassName_::ReadSerReg(ULong regNum){	return (fBaseRegPtr[regNum]);}#endif	// hasPCMCIA
//Copyright © 1993-1995 by Apple Computer, Inc.  All rights reserved.// listPicker defs// a validation frame is required to support editing. The frame is used// in the pickerDef.DefConst('kValidationFrame,	{		first:						// fieldpath of listPicker display item.		{			inputProto:			{							// the line in the defaultOpenEditor				_proto: newtLabelInputLine,		// protonewtlabelinputline := @422			},			theText: "First",		// label for the editLine of the defaultOpenEditor			type: 'text,			// could be of other type such as 'number or 'shape		},		second:		{			inputProto:			{				_proto: newtLabelInputLine,			},			theText: "Second",			type: 'text,		},	});//used to define the pickerDef at compile time.  May include all of the slots for the pickerDef.//In the listPicker.pickerDef proto to this DataDef.  DefConst('kMySoupDataDef,{	_proto: protoNameRefDataDef,				// Required	name:  "Random Data ",						// name at top left of picker		// the following stuff is required for validation	Validate: func(nameRef, pathArray)	begin		// keep track of any paths that fail		local failedPaths := [];		foreach index, path in pathArray do		begin			// very simple test since each path is			// is supposed to be a string			// your test may be more complex and call			// other methods to verify particular types of data			if NOT :ValidateString(nameRef, path) then				AddArraySlot(failedPaths, path) ;			// return the failedPaths or an empty array		end;		return failedPaths ;		end,		// my own utility function to make sure the string is valid	// used :Validate above	ValidateString: func(nameRef, path)	begin		// try and get the data from the nameRef		local realData := nameRef.(path) ;				// if not data in the nameRef, try and get		// the entry and get the data from it		if NOT realData then		begin			entry := EntryFromObj(nameRef) ;			if entry then			begin				realData := entry.(path) ;				nameRef.(path) := realData ;			end ;		end ;				// valid if the value is non-NIL and is a filled string		return realData AND IsString(realData) AND StrFilled(realData) ;	end,			// provide this method to open an edit slip for	// a new or editited item.	OpenEditor: func(tapInfo, context, why)	begin		local valid := :Validate(tapInfo.nameRef, tapInfo.editPaths) ;				// check to see if the nameRef is valid to figure out		// what to do		if (length(valid) > 0) then		begin			// if not valid, open the editor			return GetLayout("editor.t"):New(tapinfo.nameRef,				tapInfo.editPaths, why, self, 'EditDone, context) ;		end		else begin			// just toggle the selection and return nil			context:Tapped('toggle) ;			return nil ;		end ;	end,		// this is a utility method that is not part of the required	// methods. Once the editor is closed, this method gets	// called so we can update the listPicker appropriately	EditDone: func(nameRef, editPaths, context, why)	begin		// check to see if the edited item is valid		if NOT :Validate(nameRef, editPaths) then			// not valid so remove the checkmark (if any)			context:Tapped(nil);		else begin			// is valid, so see if editing or a new item			if why = 'edit then			begin				// change the actual entry				// an edit occurs when the entry that is clicked				// on does not Validate.				local entry := EntryFromObj(nameRef) ;				if entry then				begin					entry.first := nameRef.first ;					entry.second := nameRef.second ;					EntryChangeXMIT(entry, kAppSymbol) ;				end ;								// The nameRef was valid, so select it.				context:Tapped('select);			end			else begin				// a new data item so add entry to soup				local newEntry := Clone(kCanonicalEntry) ;				newEntry.first := nameRef.first ;				newEntry.second := nameRef.second ;				GetUnionSoupAlways(kSoupName):AddToDefaultStoreXMIT(newEntry, kAppSymbol) ;								// tell the listpicker to update its information				context:Update() ;			end ;		end ;	end,		});	//************/*	removed validationFrame slot from data def*/
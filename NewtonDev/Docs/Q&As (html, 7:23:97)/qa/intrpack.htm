<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Unit Import/Export and Interpackage References</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Unit Import/Export and Interpackage References</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Unit Import/Export and Interpackage References  (11/25/95)</H3><DL><DD>Q:    How can I reference information in one part or package from another (different) part or package?<BR><BR>A:    Newton 2.0 OS provides the ability for packages to share informations by exporting or importing units. Units are similar to shared libraries in other systems.<BR><BR>    A unit provides a collection of NS objects (unit members.)  Units are identified by a name, major version number, and minor version number. Any frame part can export or import zero or more units.<BR><BR>    A unit must be declared, using <CODE>DeclareUnit</CODE>, before it's used (imported or exported.) See the docs on <CODE>DeclareUnit </CODE>below for details.<BR><BR>    To export a unit, call <CODE>DefineUnit </CODE>and specify the NS objects that are exported.<BR><BR>    To import from a unit, simply reference its members using <CODE>UnitReference </CODE>(or UR for short.)<BR><BR><BR><B>    Unit Usage Notes<BR></B><BR>    &#149;    Units can also be used to share objects among parts within a single package.  This avoids the need to resort to global variables or similar undesirable techniques.<BR><BR>    &#149;    A part can export multiple units.  To achieve some degree of privacy, you can partition your objects into private and public units.  Privacy is achieved by not providing the declaration for a unit.<BR><BR>    &#149;    References to units are resolved dynamically whenever a package is activated or deactivated.  For example, a package can be loaded before the package providing the units it imports is loaded.  There will be no problem as long as the provider is loaded prior to actually using the imported members.<BR><BR>    Conversely, it's possible for the provider to be deactived while its units are in use.  The part frame methods, RemovalApproval and ImportDisabled, provide a way to deal with this situation.<BR><BR>    Robust code should ensure that the units it imports are available before attempting to use their members.  It should also gracefully handle the situation of units being removed while in use.  See the DTS sample "MooUnit" for an example.<BR><B><BR>    Unit Build-Time Functions<BR></B><BR>    These functions are available in NTK at build-time only:<BR><BR><CODE><PRE>DeclareUnit(unitName, majorVersion, minorVersion, memberIndexes)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>majorVersion </CODE>- integer - major version number of the unit<BR>        <CODE>minorVersion </CODE>- integer - minor version number of the unit<BR>        <CODE>memberIndexes </CODE>- frame - unit member name/index pairs (slot/value) <BR>        return value - unspecified<BR><CODE><BR></CODE>    A unit must be declared by <CODE>DeclareUnit </CODE>before it's used (imported or exported.) The declaration maps the member names to their indexes. A typical declaration looks like:<BR><BR><CODE><PRE>    DeclareUnit('|FastFourierTransforms:MathMagiks|, 1, 0, {        ProtoGraph:     0,        ProtoDataSet:   1,    });</PRE><BR></CODE><BR>    Typically, the declarations for a unit are provided in a file, such as "FastFourierTransforms.unit", that is added to an NTK project (similar to <CODE>.h</CODE> files in C.)<BR><BR>    When resolving imports, the name and major version specified by the importer and exporter must match exactly. The minor version does not have to match exactly. If there are units differing only in minor version, the one with the largest minor version is used.<BR><BR>    Typically, the first version of a unit will have major version 1 and minor version 0. As bug fixes releases are made, the minor version is incremented. If a major (incompatible) change is made, then the major version number is incremented.<BR><BR>    Note: When a unit is modified, the indexes of the existing members must remain the same. In other words, adding new members is safe as long as the indexes of the existing members don't change. If you change a member's index it will be incompatible with any existing clients (until they're recompiled with the new declaration.)<BR><BR><CODE><PRE>DefineUnit(unitName, members)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>members </CODE>- frame - unit member name/value pairs (slot/value)<BR>        return value - unspecified<BR>    <BR><CODE>    DefineUnit </CODE>exports a unit and specifies the value of each member. Immediates and symbols are not allowed as member values. A typical definition looks like:<BR><BR>    <CODE><PRE>    DefineUnit('|FastFourierTransforms:MathMagiks|, {    ProtoGraph:     GetLayout("foo.layout"),    ProtoDataSet:   { ... },});</PRE><BR></CODE><BR>    A unit must be declared before it's defined. The declaration used when exporting a unit with <CODE>n</CODE> members must contain <CODE>n</CODE> slots with indexes <CODE>0..n-1</CODE>. The definition must specify a value for every declared member (this is important.)<BR><BR><CODE><PRE>UnitReference(unitName, memberName)</PRE><BR></CODE>        or<BR><CODE><PRE>UR(unitName, memberName)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of a unit<BR>        <CODE>memberName </CODE>- symbol - name of a member of unit<BR>        return value - a reference to the specified member<BR><BR>    To use a unit member call <CODE>UnitReference </CODE>(<CODE>UR </CODE>for short) with the unit and member name.<BR><BR>    The unit name <CODE>'ROM</CODE> can be used to refer to obects in the base ROM. For example:<BR>    <CODE>UR('ROM, 'ProtoLabelInputLine)</CODE>.<BR><BR>    Note: references to objects in the base ROM are sometimes called "magic pointers" and have traditionally been provided in NTK by constants like <CODE>ProtoLabelInputLine </CODE>or <CODE>ROM_SystemSoupName</CODE>.<BR><BR>    In Newton 2.0 OS, there may also be packages in the ROM. These ROM packages may provide units. Their members are referenced just like any other unit, using <CODE>UR</CODE>, the unitName, and the memberName. This is the mechanism by which licensees can provide product-specific functionality.<BR><CODE><PRE>AliasUnit(alias, unitName)</PRE><BR></CODE>        <CODE>alias </CODE>- symbol - alternate name for unit<BR>        <CODE>unitName </CODE>- symbol - name of a unit<BR>        return value - unspecified<BR>    <BR><CODE>    AliasUnit </CODE>provides a way to specify an alternate name for a unit. Since unit names must be unique, they tend to be long and cumbersome. For example:<BR><CODE><PRE>    AliasUnit('FFT, '|FastFourierTransforms:MathMagiks|);</PRE><BR></CODE><BR>    ...so that you could write:<BR><CODE><PRE>    local data := UR('FFT, 'ProtoDataSet):New(points);</PRE><BR></CODE><BR>    ...instead of:<BR><CODE><PRE>    local data := UR('|FastFourierTransforms:MathMagiks|,     'ProtoDataSet):New(points);AliasUnitSubset(alias, unitName, memberNames)</PRE><BR></CODE>        <CODE>alias </CODE>- symbol - alternate name for unit<BR>        <CODE>unitName </CODE>- symbol - name of a unit<BR>        <CODE>memberNames </CODE>- array of symbols - list of unit member names<BR>        return value - unspecified<BR><BR><CODE>    AliasUnitSubset </CODE>is similar to <CODE>AliasUnit</CODE>, except that it additionally specifies a subset of the units members which can be used. This helps restrict code to using only certain members of a unit.<BR><BR><BR><B>    Unit Part Frame Methods<BR></B><BR>    These methods can optionally be defined in a part frame to handle units becoming unavailable.<BR><CODE><PRE>RemovalApproval(unitName, majorVersion, minorVersion)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>majorVersion </CODE>- integer - major version number of the unit<BR>        <CODE>minorVersion </CODE>- integer - minor version number of the unit<BR>        return value - <CODE>nil </CODE>or string<BR><BR>    This message is sent to a part frame when an imported unit is about to be deactivated. It may a return a string to be shown to the user as a warning about the consequences of deactivating the package in use. For example:<BR><BR><CODE><PRE>"This operation will cause your connection to fooWorld to be dropped."</PRE><BR></CODE><BR>    Note: do not assume that the user is removing the package. Other operations such as moving a package between stores also cause package deactivation.<BR><BR>    This message is only a warning. The user may decide to proceed and suffer the consequences. If the user proceeds, the <CODE>ImportDisabled </CODE>message (see below) will be sent.<BR><BR>    If the removing the unit is not a problem (for example, your application is closed), then<CODE> RemovalApproval </CODE>can return <CODE>nil </CODE>and the user will not be bothered.<BR><BR><CODE><PRE>ImportDisabled(unitName, majorVersion, minorVersion)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>majorVersion </CODE>- integer - major version number of the unit<BR>        <CODE>minorVersion </CODE>- integer - minor version number of the unit<BR>        return value - unspecified<BR><BR>    This message is sent to a part frame after an imported unit has been deactivated. The part should deal with the situation as gracefully as possible. For example, use alternative data or put up a Notify and/or close your application.<BR><BR><B>    Unit-Related Glue Functions<BR></B>    <BR>    These functions are available in the Newton 2.0 Platform file.<BR>                <BR><CODE><PRE>MissingImports(pkgRef)</PRE><BR></CODE>        return value - <CODE>nil </CODE>or an array of frames (see below)<BR>        glue name - <CODE>kMissingImportsFunc<BR></CODE>    <BR><CODE>    MissingImports </CODE>lists the units used by the specified package that are not currently available. <CODE>  MissingImports </CODE>returns either nil, indicating there are no missing units, or an an array of frames of the form:<BR><CODE><PRE>    {        name: symbol  - name of unit desired        major: integer - major version number        minor: integer - minor version number        &lt;other slots undocumented&gt;    }</CODE></PRE></DL>
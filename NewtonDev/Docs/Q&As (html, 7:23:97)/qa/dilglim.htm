<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: FilterDialog and ModalDialog Limitations</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>FilterDialog and ModalDialog Limitations</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>FilterDialog and ModalDialog Limitations  (2/5/96)</H3><DL><DD>Q:    After closing a view that was opened with <CODE>theView:FilterDialog()</CODE>, the part of the screen that was not covered by the <CODE>theView </CODE>no longer accepts any pen input. <CODE>theView </CODE>is a <CODE>protoFloatNGo</CODE>.  Is there some trick?<BR><BR>A:    There is a problem with <CODE>FilterDialog </CODE>and <CODE>ModalDialog </CODE>when used to open views that are not immediate children of the root view.  At this point we're not sure if we'll be able to fix the problem.<BR><BR>    You must not use <CODE>FilterDialog </CODE>or <CODE>ModalDialog </CODE>to open more than one non-child-of-root view at a time.  Opening more than one at a time with either of these messages causes the state information from the first to be overwritten with the state information from the second.  The result will be a failure to exit the modality when the views are closed.<BR><BR>    Here are some things you can do to avoid or fix the problem with <CODE>FilterDialog</CODE>.<BR><BR>     Redesign your application so that your modal slips are all children of the root view, created with <CODE>BuildContext</CODE>.  This is the best solution because it avoids awkward situations when the child of an application is system-modal.  (Application subviews should normally be only application-modal.)<BR><BR>    Use the <CODE>ModalDialog </CODE>message instead of <CODE>FilterDialog</CODE>.  <CODE>ModalDialog </CODE>does not have the child-of-root bug.   (<CODE>FilterDialog </CODE>is preferred, since it uses fewer system resources and is faster.)<BR><BR>    Here is some code you can use to work around the problem much like a potential patch would.  (This code should be safe if a patch is madethe body of the if statement should not execute on a corrected system.)<BR><BR><CODE><PRE>view:FilterDialog();if view.modalState then    begin        local childOfRoot := view;        while childOfRoot:Parent() &lt;&gt; GetRoot() do            childOfRoot := childOfRoot:Parent();        childOfRoot.modalState := view.modalState;    end;</PRE><BR></CODE>    This only needs to be done if the view that you send the <CODE>FilterDialog </CODE>message to is not an immediate child of the root.  You can probably improve the efficiency in your applications, since the root child is ususally your application's base view, which is a "well known" view.  That is,  you may be able to re-write the code as follows:<BR><BR><CODE><PRE>view:FilterDialog();if view.modalState then    base.modalState := view.modalState;</CODE></PRE></DL>
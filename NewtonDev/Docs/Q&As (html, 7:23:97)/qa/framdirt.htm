<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: FrameDirty is Deep, But Can Be Fooled</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>FrameDirty is Deep, But Can Be Fooled</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>FrameDirty is Deep, But Can Be Fooled  (8/19/94)</H3><DL><DD>Q:    Does the global function <CODE>FrameDirty</CODE> see changes to nested frames?<BR><BR>A:    Yes.  However, <CODE>FrameDirty</CODE> is fooled by changes to bytes within binary objects.  Since strings are implemented as binary objects, this means that <CODE>FrameDirty</CODE> will not see changes to individual characters in a string.  Since <CODE>clParagraphViews</CODE> try (as much as possible) to work by manipulating the characters in the string rather than by creating a new string, this means that <CODE>FrameDirty</CODE> can be easily fooled by normal editing of string data.<BR><BR>    Here is an NTK Inspector-based example of the problem:<BR><BR><CODE><PRE>s := GetStores()[0]:CreateSoup("Test:DTS", []);e := s:Add({slot: 'value, string: "A test entry", nested: {slot: 'notherValue}})#4410B69  {slot: value,            String: "A test entry",            nested: {slot: notherValue},            _uniqueID: 0}FrameDirty(e)#2        NILe.string[0] := $a; // modify the string w/out changing its referenceFrameDirty(e)#2        NILEntryChange(e);e.string := "A new string";    // change the string referenceFrameDirty(e)#1A       TRUEEntryChange(e);e.nested.slot := 'newValue;    // nested change, FrameDirty is deep.FrameDirty(e)#1A       TRUEs:RemoveFromStore()    // cleanup.</CODE></PRE></DL>
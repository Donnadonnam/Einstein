<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Choosing EntryFlushXMit and EntryChangeXMit</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Choosing EntryFlushXMit and EntryChangeXMit</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Choosing EntryFlushXMit and EntryChangeXMit  (4/17/96)</H3><DL><DD>Q:    What is the difference between the functions <CODE>EntryFlushXMit </CODE>and <CODE>EntryChangeXMit</CODE>?<BR><BR>A:    The most important criterion when choosing between <CODE>EntryFlushXMit </CODE>and <CODE>EntryChangeXMit </CODE>is what will be done with the entry after the flush or change.<BR><BR>    When an entry is added or changed, the system ensures that a cached entry frame exists in the NewtonScript heap.  The system then writes the data in the frame to the store, skipping <CODE>_proto </CODE>slots.  The result is that the data will be written to the store, and a cached frame will exist.  Often, this is exactly what is desired because the entry is still needed since it will soon be accessed or modified. <BR><BR>    In some cases, the data will be written to the soup with no immediate access afterwards. In other words, the data will not be used after being written to the soup.  In these cases creating or keeping a cached entry frame in the NewtonScript heap is unnecessary and just wastes space and time.  In these situations, <CODE>EntryFlushXMit </CODE>is a better option; it writes the data to the soup without creating the cached entry.<BR><BR>    If any code accesses an entry that was just flushed, a new cached frame will be read in from the soup, just like when an existing entry is read for the first time.  <BR><BR>    The rule of thumb is: if an entry will be used soon after saving to the soup, then use <CODE>AddXMit </CODE>or <CODE>EntryChangeXMit</CODE>. If the entry will not soon be used again (so it doesn't need to take up heap space with the cached frame), then use <CODE>AddFlushedXmit </CODE>or <CODE>EntryFlushXMit</CODE>.<BR><BR>    Some examples of good usage:<BR><CODE><PRE>while entry dobegin  entry.fooCount := entry.fooCount + 1;  // nil appSymbol passed so don't broadcast  EntryFlushXMit(entry, nil);     entry := cursor:Next();end;                           // Could broadcast now foreach x in kInitialData do     // if new, may not need broadcast    soup:AddFlushedXmit(Clone(x), nil);    </CODE></PRE></DL>
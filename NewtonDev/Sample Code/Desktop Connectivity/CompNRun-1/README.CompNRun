/***      Newton Developer Technical Support Sample Code****      CompNRun, a stream file used as a protocol extension by the PDILs****      by David Fedor, Newton Developer Technical Support****      Copyright © 1997 Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/This sample project creates a stream file containing a protocol extension,which is to be downloaded and executed by a PDIL application.  (See the sample"SuiteP" to see it in action.)A protocol extension is a NewtonScript function that the PDILs download from adesktop system.  It can be repeatedly called by the desktop, and executes onthe Newton device.  The calling PDIL application can specify parameters thatthe protocol extension can access by sending the message ReadCommandData() tothe extension's argument.This protocol extension, CompNRun, compiles and runs NewtonScript code whichthe desktop sends as a parameter, and sends the return value back to thedesktop.  There are actually three steps in the process: the NewtonScript codeis first compiled, and then evaluated.  Then, if the NewtonScript evaluates toa function, the desktop can optionally specify arguments to call it with.  Ifno arguments are specified, the compiled function object will be returned tothe desktop.Most of the time, CompNRun would be used to compile and evaluate aNewtonScript expression, such as "getroot().foo exists" or other such commandswhich aren't simple global function calls.  More complex code could, forexample, perform a complex query on a union soup, create a summary of theentries and send that summary to the desktop caller.  Doing that operationlocally on the Newton device would be considerably faster than sending all thedata to the desktop.CompNRun takes a frame as its parameter.  The frame must contain a "src" slot,which is the NewtonScript source that is to be compiled and executed.  If an"args" slot exists, then the result of the evaluated NewtonScript will becalled as a function.  If there is a non-nil "debug" slot, and an exception isthrown, then CurrentException() will be called and its result sent back to thedesktop.  (Note that depending on the exception, this might be a large amountof data, so use this carefully.)The result sent back to the desktop will be an array with two elements.  Thefirst is status - NIL indicates success, where values of 0, 1 and 2 indicatethat the exception was thrown during the compile, evaluation or calling phaserespectively.  The second element of the result array is the result ofevaluating the NewtonScript, or else the return value of the compiled function(if the "args" slot was present.)Also included in CompNRun is some NewtonScript code that can be evaluatedlocally inside NTK to help convert the stream file into a form that makes iteasy to add to a desktop C application.  See CompNRun.txt for moreinformation.
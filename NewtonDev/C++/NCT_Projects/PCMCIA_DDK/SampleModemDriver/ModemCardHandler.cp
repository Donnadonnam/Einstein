/*	File:		ModemCardHandler.c	Contains:	Sample Modem Card Handler	Copyright:	© 1993-1994 by Apple Computer, Inc., all rights reserved.	Derived from v1 internal.*/#ifndef __string_h	#include <string.h>#endif#ifndef __stdio_h	#include <stdio.h>#endif#ifndef __stdarg_h	#include <stdarg.h>#endif#ifndef __NEW_H	#include <New.h>#endif#ifndef __ModemCardHandler_IMPL_H	#include "ModemCardHandler.impl.h"#endif#ifndef __CARDPOWER_H	#include "CardPower.h"#endif#ifndef __PROTOCOLS_H	#include "Protocols.h"#endif#ifndef	__SERIALCHIP_H	#include "SerialChip.h"#endif#ifndef	__LONGTIME_H	#include "LongTime.h"#endif#ifndef __CARDDEFINES_H	#include "CardDefines.h"#endif#define sProductStringFuryCard		"FURY CARD 14K4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"#define sV1String4Megahertz			"PCMCIA MODEM\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"////	TCardHandlerModemSample	Card handler for modem card//PROTOCOL_IMPL_SOURCE_MACRO(_CardHandlerClassName_)			// Magic stuff, do not touchTCardHandler* _CardHandlerClassName_::New(){	// Clear out all fields.		fRemovableHandler = false;								// default to "true" if this is															//  handler is dynamically loaded!	fDeviceDriver = nil;	Clear();	return this;}void _CardHandlerClassName_::Delete(){	Clear();}void _CardHandlerClassName_::Clear(){	// Utility routine to clear out fields and dispose of driver if it exists.	if (fDeviceDriver != nil)		fDeviceDriver->Delete();	for (int i = 0; i < kCardNameNumberOfChars; i++)		fCardIdString[i] = 0;	fDeviceDriver = nil;	fCurrentSocket = nil;	fDeviceType = 0;	fConfigOptionRegPtr = nil;	fConfigIndex = 0;}NewtonErr_CardHandlerClassName_::RecognizeCard(TCardSocket* socket, TCardPCMCIA* card){	// The Card Server calls us to see if we can deal with the newly inserted card.	//	// We look at the function id if it's available (newer PCMCIA spec), 	// and accept the card if it's a "serial I/O" card.	NewtonErr err = noErr;	if (strncmp(card->GetCardProduct(), sProductStringFuryCard, strlen(sProductStringFuryCard)) == 0) ;	else if (strncmp(card->GetCardV1String4(), sV1String4Megahertz, strlen(sV1String4Megahertz)) == 0) ;	else		err = kError_Unrecognized_Card;	if (!err)		// Set to 8-bit bus		socket->SetControl(socket->GetControl() | kCardByteAccess);	return err;}NewtonErr_CardHandlerClassName_::ParseUnrecognizedCard(TCardSocket* socket, TCardPCMCIA* card){	// Card Server can't parse the CIS. This is the chance for us to parse the CIS.	// If it is our card, set up fields in TCardPCMCIA* for later use and return noErr	NewtonErr err  = noErr;	socket->PCMCIAReset();	Sleep(50*kMilliseconds);	for (ULong i=0; i<20; i++)	{		if (fCurrentSocket->IsReady())			break;		Sleep(100*kMilliseconds);	}	try	{		UByte* addr = (UByte*)(socket->AttributeMemBaseAddr() + 0x42);		for (i=0; i<strlen(sV1String4Megahertz); i++, addr+=2)		{				if ((*(UByte*)ToLittleEndianAddr(addr)) != sV1String4Megahertz[i])				{					err = kError_Unrecognized_Card;					break;				}			}		}	catch("")	{		err = kError_Unrecognized_Card;	}	end_try;	if (err == noErr)	{		TCardConfiguration *cardConfig = new TCardConfiguration;			// make the new configuration object		cardConfig->fIoAddresses[0] = 0x3f8;		cardConfig->fConfigurationNumber = 0x20;		card->AddCardConfiguration(cardConfig);		card->fNumOfConfigEntry++;		card->SetCardV1String4((char*)sV1String4Megahertz);		card->fRegisterBaseAddress = 0x100;	}	return err;}NewtonErr_CardHandlerClassName_::InstallServices(TCardSocket* socket, TCardPCMCIA* card, ULong configNumber){	// This is called after RecognizeCard. Our "service" consists of a serial chip protocol	// registered with the Name Server when card is inserted	socket->SetControl(socket->GetControl() | kCardByteAccess);	// Set to 8-bit bus	NewtonErr err = noErr;	TCardConfiguration* cardConfig;	ULong ioAddrOffset;	Clear();											// Clear everything first	fCurrentSocket = socket;							// Save socket	fDeviceType = kSerialCard;	cardConfig = card->GetCardConfiguration(configNumber);	ioAddrOffset = cardConfig->fIoAddresses[0];	fConfigIndex = cardConfig->fConfigurationNumber;	fDeviceDriver = (_CardSpecificDriverProtocolName_*)NewByName(_sCardSpecificDriverProtocolName_, _sCardSpecificDriverClassName_);	if (fDeviceDriver == 0)	{		err = kError_No_Memory;		goto exit;	}	fConfigOptionRegPtr = (UByte*)(ToLittleEndianAddr(card->fRegisterBaseAddress + socket->AttributeMemBaseAddr()));	err = fDeviceDriver->Init(socket, this, (UByte*)(socket->IOBaseAddr() + ioAddrOffset));exit:	return err;}NewtonErr_CardHandlerClassName_::CardSpecific(ULong selector, void* /*ptr*/, ULong /*something*/){	NewtonErr err = noErr;	switch (selector)	{		case kCardPowerOn:									// power on...		VccOn((int)fCurrentSocket->SocketNumber());		fCurrentSocket->SelectIOInterface();			// change to I/O mode on Newt		*fConfigOptionRegPtr = 0x80;					// assert reset (resets pcmcia bus to memory mode)		Sleep(5*kMilliseconds);							// delay		*fConfigOptionRegPtr = 0x00;					// release reset		// Some cards need 250 millisecond delay until ready maximum		// Rockwell states that power-on diagnostics can take up to 500 milliseconds, but ready line		//  should be used to determine when card is ready. VccOn delays about 200 ms already.				int i = 0;				do 		{			i++;			Sleep(100*kMilliseconds);		} 		while ((i != 10) && (!fCurrentSocket->IsReady()));		*fConfigOptionRegPtr = fConfigIndex | 0x40;		// enable I/O mode, level ints		break;	case kCardPowerOff:									// power off...		VccOff((int)fCurrentSocket->SocketNumber(), kNoTimeout);		break;		default:		break;			}	return err;}NewtonErr_CardHandlerClassName_::RemoveServices(){	// The Card Server calls this after EmergencyShutdown, but at task level. If the	// card handler has been dynamically loaded, it will be deleted after this.	//	// To "remove services", we simply have to delete our instance of the TSerialChip	// protocol, if it exists. The TSerTool will no longer find it registered with	// the NameServer. The TSerialChip should let any TSerTool using it know that it is	// going away via the SendForInterrupt mechanism if necessary.	Clear();	return noErr;}NewtonErr_CardHandlerClassName_::SuspendServices(){	// The Card Server calls this when the system powers off.  The Card Server handles Vcc	// management at this time, restoring Vcc state at ResumeServices time.	return noErr;}NewtonErr_CardHandlerClassName_::ResumeServices(TCardSocket* socket, TCardPCMCIA*, ULong /*configNumber*/){	// The Card Server calls this when the system powers on.	socket->SetControl(socket->GetControl() | kCardByteAccess);	// Set to 8-bit bus	return noErr;}NewtonErr_CardHandlerClassName_::EmergencyShutdown(){	// The Card Server calls this from interrupt level, so we can't do much. We call	// the driver which ends up doing a SendForInterrupt call to notify the serial	// tool task of this event.	//	// The Card Server will call RemoveServices later.	if (fDeviceDriver)										// turn off driver if on!		fDeviceDriver->CardRemoved();	return noErr;}NewtonErr_CardHandlerClassName_::FormatCIS(TCardSocket*, TCardPCMCIA*) 	// Format CIS{	// This is only used for unformatted SRAM memory cards which don't have CIS.	return noErr;}ULong_CardHandlerClassName_::CardStatus(){	// The system polls the status of the card occasionally to see if our battery	// is ok, and what our write-protect status is. We don't have a battery, so we just	// pass back kBatteryStatus so that the UI will not put up any alerts.	//	kBatteryStatus	=	0x0003,		Battery status (11:ok, 01:low, X0:bad)	//	kWriteProtected	=	0x0004 		Write protected	//	kCardBusy		=	0x0008 		Busy (incertion of Ready/busy)	// return status from pin replacement register in io mode	return kBatteryStatus;									// "good" battery, not WP, not busy}char*_CardHandlerClassName_::CardIdString(TCardPCMCIA* card){	// The Card Server asks for our Id string which it will send with the new card available	// message. It also uses this to check for new card re-inserted.	//	// We just use the card manufacturer and product names 		if (card != nil)	{		char* manufacturer = (char*) card->GetCardManufacturer();		char* product = (char*) card->GetCardProduct();		strncpy(fCardIdString, manufacturer, (unsigned int)kCardNameNumberOfChars-1);		strncat(fCardIdString, product, (int)kCardNameNumberOfChars-1-strlen(manufacturer));		fCardIdString[kCardNameNumberOfChars-1] = 0;	}	return (card != nil) ? fCardIdString : nil;}ULong_CardHandlerClassName_::GetNumberOfDevice(){	// We have either no or 1 device. The Card Server uses this to determine how many times to	// call GetDeviceInfo.	return (fDeviceDriver == nil ? 0 : 1);}void_CardHandlerClassName_::GetDeviceInfo(ULong deviceNumber, ULong* cardType, TObjectId* cardPhys, void** cardDriver, ULong* deviceOffset, ULong* deviceSize){	// The Card Server asks us for device info on our one device.	//	// We don't have a cardPhys because we share the one the Card Server creates, because	// we don't need our own fault monitor. When a card is unlocked we just tear things down.	if (deviceNumber == 0)	{		*cardType = fDeviceType;		*cardPhys = 0;		*cardDriver = fDeviceDriver;		*deviceOffset = 0;		*deviceSize = 0;								// we're an I/O card, no size.	}}void_CardHandlerClassName_::SetCardServerPort(TObjectId){}Boolean_CardHandlerClassName_::GetRemovableHandler(){	return fRemovableHandler;}void_CardHandlerClassName_::SetRemovableHandler(Boolean removable){	// Called when this card handler is installed. Set false if we're in ROM, true	// if we've been loaded off a card. 	fRemovableHandler = removable;}
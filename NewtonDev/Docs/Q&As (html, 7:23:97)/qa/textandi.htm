<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Text and Ink Input and Display</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Text and Ink Input and Display</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="textandi.htm">Text and Ink Input and Display</H2></A><UL><A HREF="#ProtoPhoneExpando_Bug_in_Setup1_Method"><B> </B>ProtoPhoneExpando Bug in Setup1 Method  (2/6/96)<BR></A><A HREF="#Pictures_in_clEditViews"><B> </B>Pictures in clEditViews  (2/6/96)<BR></A><A HREF="#Horizontal_Scrolling,_Clipping,_and_Text_Views"><B> </B>Horizontal Scrolling, Clipping, and Text Views  (2/7/96)<BR></A><A HREF="#How_to_Intercept_Keyboard_Events"><B> </B>How to Intercept Keyboard Events  (5/6/96)<BR></A><A HREF="#How_to_Keep_Multiple_Keyboards_Open"><B> </B>How to Keep Multiple Keyboards Open  (8/30/96)<BR></A><A HREF="#Adding_a_Local_Keyboard_to_a_ProtoKeyboardButton-based_Button"><B> </B>Adding a Local Keyboard to a ProtoKeyboardButton-based Button  (1/14/97)<BR></A><A HREF="#Getting_Digital_Ink_to_the_Desktop"><B> </B>Getting Digital Ink to the Desktop  (1/17/97)<BR></A><A HREF="#Constraints_on_Keyboards_Sizing_to_the_View"><B> </B>Constraints on Keyboards Sizing to the View  (4/7/97)<BR></A><A HREF="#Using_a_Keyboard_Equivalent_to_Close_a_Subview"><B>NEW: </B>Using a Keyboard Equivalent to Close a Subview  (5/12/97)<BR></A><A HREF="#Finding_a_KeyCommand_by_KeyMessage"><B>NEW: </B>Finding a KeyCommand by KeyMessage  (6/16/97)<BR></A></UL><A NAME="ProtoPhoneExpando_Bug_in_Setup1_Method"><H3><HR><B> </B>ProtoPhoneExpando Bug in Setup1 Method  (2/6/96)</A></H3><DL><DD>Q:    I am having a problem using <CODE>protoPhoneExpando </CODE>under Newton 2.0 OS. Something is going wrong in the <CODE>setup1 </CODE>method.  Is this a known bug?<BR><BR>A:    Yes, this is a known bug.  <CODE>protoPhoneExpando</CODE> (and the entire expando user interface) have been deprecated in the Newton 2.0 OS, and are only supported for backward compatibility.  If possible, you should redesign your application to avoid the expandos.<BR><BR>    The problem seems to be that the expando shell is sending the <CODE>setup1 </CODE>and <CODE>setup2 </CODE>messages to the template in the <CODE>lines </CODE>array.  These methods in <CODE>protoPhoneExpando </CODE>rely on information that isn't created until the view is actually opened.<BR><BR>    We're investigating solutions to this problem.  You can usually hack around the problem by placing a <CODE>labelCommands </CODE>slot in the template which has an array of one element, that element being the label you want to appear in the phone line.  For example: <CODE>labelCommands: ["phone"]</CODE>.<BR><BR>    This hack works only if your <CODE>protoPhoneExpando </CODE>doesn't use the <CODE>phoneIndex </CODE>feature.  If it does, you'll have problems that are harder to work around.</DL><A NAME="Pictures_in_clEditViews"><H3><HR><B> </B>Pictures in clEditViews  (2/6/96)</A></H3><DL><DD>Q:    Is there a API or procedure that allows an application to write objects such as shapes, PICTs, or bitmaps to a note in the Notes application?<BR><BR>A:    There is no API for Notes specifically.  The Notes "Note" view is basically a plain old <CODE>clEditView</CODE>, and <CODE>clEditViews </CODE>can contain pictures (in addition to ink, polygons, and text) in the Newton 2.0 OS.<BR><BR>    The Newton Programmer's Guide 2.0 (in the "Built-In Applications and System Data" chapter) contains a description of the types of children you can create in the Notes application.<BR><BR>    This is really a description of the frames you need to put in the <CODE>'viewChildren</CODE> slot of a <CODE>clEditView</CODE> to create editable items.  <CODE>'para</CODE> templates are text and ink text, <CODE>'poly</CODE> templates are drawings and sketch ink, and <CODE>'pict</CODE> templates are images.<BR><BR>    To add a picture to a <CODE>clEditView</CODE>, you need to create an appropriate template and then add it to the <CODE>viewChildren</CODE> array (and open the view or call <CODE>RedoChildren</CODE>) or use the <CODE>AddView</CODE> method to add it to an existing view (then <CODE>Dirty</CODE> the view.)  See the item "Adding Editable Text to a clEditView" elsewhere in the Q&amp;As for details.<BR><BR>    The template for <CODE>'pict</CODE> items needs to contain these slots:<BR><CODE>    viewStationery</CODE>:    Must have the symbol<CODE> 'pict<BR>    viewBounds</CODE>:        A bounds frame, like <CODE>RelBounds(0,0,40,40)<BR>    icon</CODE>:             A bitmap frame, see <CODE>clPictureView</CODE> docs<BR><BR>    For other slots, see the documentation for the <CODE>clPictureView </CODE>view class.</DL><A NAME="Horizontal_Scrolling,_Clipping,_and_Text_Views"><H3><HR><B> </B>Horizontal Scrolling, Clipping, and Text Views  (2/7/96)</A></H3><DL><DD>Q:    I want to draw 80 columns in a <CODE>clParagraphView</CODE> that's inside a smaller view and be able to scroll back and forth.  When I try this, it always wraps at the bounds of the parent.  How can I create a horizontal scrolling text view?<BR><BR>A:    Normal paragraph views are written so that their right edge will never go beyond their parent.  This is done to avoid the circumstance where a user could select and delete some text from the left part of a paragraph in a <CODE>clEditView</CODE>, leaving the rest of it off screen and unselectable.<BR><BR>    What happens is the <CODE>viewBounds </CODE>of the <CODE>clParagraphView</CODE> are modified during creation of the view so that the view's right edge is aligned with the parent's right edge.  After that, wrapping is automatic.<BR><BR>    The so-called "lightweight" text views do not work this way.  You can force a paragraph to be lightweight by: 1) Making sure the <CODE>viewFlag</CODE> <CODE>vReadOnly</CODE> is set, 2) making sure <CODE>vCalculateBounds</CODE> and <CODE>vGesturesAllowed</CODE>, are off, and 3) not using <CODE>tabs</CODE> or <CODE>styles</CODE>.  Lightweight text views are not editable, but you can use <CODE>SetValue</CODE> to change their <CODE>text</CODE> slots dynamically.<BR><BR>    If you must use an editable <CODE>clParagraphView</CODE> or if tabs or styles are required, there is another workaround.  The code to check for clipping only looks one or two levels up the parent chain, so you could nest the paragraph in a couple of otherwise useless views which were large enough to prevent clipping, and let the clipping happen several layers up the parent chain.<BR></DL><A NAME="How_to_Intercept_Keyboard_Events"><H3><HR><B> </B>How to Intercept Keyboard Events  (5/6/96)</A></H3><DL><DD>Q:    How do I intercept hardware keyboard events or "soft" keyboard events?<BR><BR>A:    You can implement view methods that are called whenever the user presses a key on software or external (hardware) keyboards.. There are two keyboard-related methods associated with views based on the <CODE>clParagraphView </CODE>view class: <BR>        the <CODE>viewKeyDownScript </CODE>message is sent when a key is pressed.<BR>        the <CODE>viewKeyUpScript </CODE>message is sent when a key is released.<BR><BR>    Both methods receive two arguments: the character that was pressed on the keyboard and a keyboard flags integer. The keyboard flags integer encodes which modifier keys were in effect for the key event, the unmodified key value, and the keycode. The layout of the keyboard flags integer is shown in the section below, "Keyboard Flags Integer". The modifier key constants are shown in the section "Keyboard Modifier Keys".<BR><BR>    <CODE>ViewKeyUpScript </CODE>and <CODE>ViewKeyDownScript </CODE>are currently called using parent inheritance.  Do not rely on this behavior: it may change in future ROMs.<BR><BR>    If you want the default action to occur, these method must return <CODE>nil</CODE>. The default action for <CODE>ViewKeyDownScript </CODE>is usually to insert the character into the paragraph. (There may be other default actions in the future.) If you return a non-nil value, the default action will not occur.<BR><BR>    You must include the <CODE>vSingleKeyStrokes </CODE>flag in the <CODE>textFlags </CODE>slot of your view for the system to send the <CODE>ViewKeyDownScript </CODE>or <CODE>ViewKeyUpScript </CODE>message for every key stroke.  If you do not specify <CODE>vSingleKeyStrokes</CODE>, keyboard input may be dropped if a lot of key strokes are coming in.<BR><BR>    The hard keyboard auto repeats with the following event sequence:<BR><BR>    keydown -- keydown -- keydown -- keydown...<BR><BR>    The soft keyboard auto repeats with this sequence:<BR><BR>    keydown -- keyup -- keydown -- keyup -- keydown -- keyup...<BR><BR>    Do not rely on this order, it may change in future ROMs.<BR><BR>    <B>ViewKeyDownScript<BR></B><BR>    <CODE><PRE>    ViewKeyDownScript(char, flags)</PRE><BR></CODE>    This message is sent to the key view when the user presses down on a keyboard key. This applies to a hardware keyboard or an on-screen keyboard.<BR><BR>    <CODE>char</CODE>    The character that was entered on the keyboard. Note that if a modifier key is the only key pressed (for example, the Shift key), this value will be 0.<BR><BR>    <CODE>flags</CODE>    An integer that specifies which modifier keys were pressed, the unmodified key value, and the keycode. The modifier key constants are shown in the section "Keyboard Modifier Keys".<BR><BR><BR>    <B>ViewKeyUpScript<BR></B><BR>    <CODE><PRE>    ViewKeyUpScript(char, flags)</PRE><BR></CODE>    This message is sent to the key view whenever the user releases a keyboard key that was depressed. This applies to a hardware keyboard or an on-screen keyboard.<BR><BR>    <CODE>char</CODE>    The character that was entered on the keyboard. Note that if a modifier key is the only key pressed (for example, the Shift key), this value will be 0.<BR><BR>    <CODE>flags</CODE>    An integer that specifies which modifier keys were pressed, the unmodified key value, and the keycode. The modifier key constants are shown in the section "Keyboard Modifier Keys".<BR><BR>    <B>Keyboard Flags Integer<BR></B><BR>    Bits            Description    <BR>    0 to 7        The keycode.    <BR>    8 to 23        Original keycode. The 16-bit character that would result if none of the<BR>                modifier keys were pressed.    <BR>    24            Indicates that the key was from an on-screen keyboard. (kIsSoftKeyboard)<BR>    25            Indicates that the Command key was in effect. (kCommandModifier)    <BR>    26            Indicates that the Shift key was in effect. (kShiftModifier)    <BR>    27            Indicates that the Caps Lock key was in effect. (kCapsLockModifier)    <BR>    28            Indicates that the Option key was in effect. (kOptionsModifier)    <BR>    29            Indicates that the Control key was in effect. (kControlModifier)    <BR><BR><BR>    <B>Keyboard Modifier Keys<BR></B><BR>    You use the keyboard modifier key constants to determine which modifier keys were in effect when a keyboard event occurs. <BR>    Constant                Value    <BR>    <CODE>kIsSoftKeyboard</CODE>        (1 &lt;&lt; 24)    <BR>    <CODE>kCommandModifier</CODE>    (1 &lt;&lt; 25)    <BR>    <CODE>kShiftModifier</CODE>        (1 &lt;&lt; 26)    <BR>    <CODE>kCapsLockModifier</CODE>    (1 &lt;&lt; 27)    <BR>    <CODE>kOptionsModifier</CODE>    (1 &lt;&lt; 28)    <BR>    <CODE>kControlModifier</CODE>    (1 &lt;&lt; 29)    </DL><A NAME="How_to_Keep_Multiple_Keyboards_Open"><H3><HR><B> </B>How to Keep Multiple Keyboards Open  (8/30/96)</A></H3><DL><DD>Q:    I want my <CODE>protoKeyboard</CODE>-based keyboard to be open at the same time as other keyboards. When my keyboard opens, it seems like any other  keyboard closes. How do I keep multiple keyboards open?<BR><BR>A:    When a <CODE>protoKeyboard</CODE>-based view opens, it closes the last-opened <CODE>protoKeyboard</CODE>-based view. However, you need not use <CODE>protoKeyboard</CODE>. <BR><BR>    Instead, you can base your keyboard on a different view type (for instance, <CODE>protoDragger</CODE>) and use the <CODE>RegisterOpenKeyboard</CODE> view message to register the keyboard with the system. Using <CODE>RegisterOpenKeyboard</CODE> will ensure that the caret is set up properly and allows you to track the caret changes with the <CODE>viewCaretChangedScript</CODE> view message if desired.<BR></DL><A NAME="Adding_a_Local_Keyboard_to_a_ProtoKeyboardButton-based_Button"><H3><HR><B> </B>Adding a Local Keyboard to a ProtoKeyboardButton-based Button  (1/14/97)</A></H3><DL><DD>Q:    I have an application-specific keyboard that I would like to have appear only in my application's <CODE>protoKeyboardButton</CODE>-based keyboard list.  Is this possible?<BR><BR>A:    Yes, <CODE>protoKeyboardButton</CODE> has a method called <CODE>SetKeyboardList</CODE> that lets you do this.  <CODE>SetKeyboardList</CODE> takes two arguments. The first argument is an array of keyboard symbols to add to the list.  The second argument is an array of keyboard symbols to remove from the list.  Note that the keyboard symbols of the built-in keyboards are listed on pages pages 8-26 and 8-27 of the Newton Programmer's Guide.<BR><BR>    To create a local keyboard, your keyboard view must be declared either to the keyboard button view or to a view within in its parent view chain. It is common to declare the keyboard view in your application's base view.  When you declare the keyboard view, it must be declared using the keyboard's <CODE>keyboardSymbol</CODE>.<BR><BR>    There are three additional slots that your keyboard template must have: <BR>    1) a <CODE>preallocatedContext</CODE> slot with the symbol of the keyboard<BR>    2) a <CODE>userName</CODE> slot with the name that will appear in the <CODE>protoKeyboardButton</CODE> popup<BR>    3) a <CODE>keyboardSymbol</CODE> slot with your keyboard's symbol <BR><BR>    The <CODE>preallocatedContext</CODE> slot and the <CODE>keyboardSymbol</CODE> slot must be the same symbol.  Note that the <CODE>keyboardSymbol</CODE> slot is required, but the <CODE>preallocatedContext</CODE> slot is additionally necessary to avoid exceptions on devices prior to Newton 2.1 OS.<BR><BR>    Next, in the <CODE>viewSetupDoneScript</CODE> of the <CODE>protoKeyboardButton</CODE>-based view, send the button a <CODE>SetKeyboardList</CODE> message with your keyboard's symbol.  For instance, you might have the following <CODE>viewSetupDoneScript</CODE>:<BR><BR><CODE><PRE>viewSetupDoneScript: func()    begin        :SetKeyboardList( [kMyKeyboardSymbol], nil );        // Be sure to call the inherited viewSetupDoneScript method!        inherited:?viewSetupDoneScript();</PRE><BR>        end;</CODE><BR><BR>    If you want to dynamically change the keyboard list, you can also override the <CODE>buttonClickScript</CODE>.  You must first call <CODE>SetKeyboardList</CODE>, then call the inherited <CODE>buttonClickScript</CODE>.<BR><BR>    All additions and subtractions are removed from the list when your <CODE>protoKeyboardButton</CODE>-based view is closed.</DL><A NAME="Getting_Digital_Ink_to_the_Desktop"><H3><HR><B> </B>Getting Digital Ink to the Desktop  (1/17/97)</A></H3><DL><DD>Q:    I want to get ink (for instance, a signature) from my Newton device to a desktop machine.  How do I do that?<BR><BR>A:    The easiest way to get digital ink to the desktop is to convert it into a bitmap on the Newton device, and send the bitmap up to the desktop via the Desktop Integration Libraries (DILs).  Another common technique is to convert the ink into an array of (x,y) points and send that array to the desktop for it to convert into whatever format is suitable.<BR><BR>      Take a look at the DTS Sample Code projects, "InkForm" and "InkTranslate". They offer some pointers on how to do this.  Depending on how and when you want to do the translation, you'll either want to use the view method <CODE>ViewIntoBitmap</CODE>, or the global function <CODE>GetPointsArray</CODE>, or a set of functions from the Recognition chapter, particularly <CODE>GetStroke</CODE> and <CODE>GetStrokePointsArray</CODE>.<BR><BR>      If you need DIL sample code, the DTS Sample Code project "SoupDrink"  may be helpful to you.</DL><A NAME="Constraints_on_Keyboards_Sizing_to_the_View"><H3><HR><B> </B>Constraints on Keyboards Sizing to the View  (4/7/97)</A></H3><DL><DD>Q:    I am having a problem with dynamically adjusting the size of keyboards. According to the documentation, adjusting the size of my keyboard view should cause the keys to size correctly to the bounds of the view. This does not happen.  If I set the viewbounds of the keyboard (a full alphanumeric keyboard) to anything less than 224x80, the keys scrunch up only taking up about half the view (horizontally).  They seem to size fine vertically.  This happens even if I set the viewbounds to 222 (only 2 pixels shorter.) What is going on?<BR><BR>A:    It turns out the the documentation does not give the full story. The final size of the keys in a keyboard is constrained by the smallest fractional key unit width you specify in the keyboard. To understand key units and key dimensions, read the "Key Dimensions" section of the Newton Programmer's Guide (pages 8-35,6). You can also find this information in the "Key Descriptor Constants" section of the Newton Programmer's Reference.<BR><BR>    In addition to calculating the size (in key units) of the longest key row, the <CODE>clKeyboardView</CODE> also finds the smallest key unit specified in the keyboard and uses this to constrain the final horizontal size. It calculates a minimal pixel size for the keyboard and makes sure that the final keyboard size is an integral multiple of this value. For example, if the smallest size is 10 pixels, then the final keyboard can be 10 pixels or 20 pixels, but not 15 pixels. If the view is 15 pixels, the keyboard will be 10 pixels.<BR><BR>    The calculation for this minimal size is:<BR><CODE><PRE>    m = w * (1/s)</PRE><BR></CODE><BR><CODE><PRE>m - minimal sizew - width of the longest keyboard row in key unitss   - numeric equivelent for smallest keyboard unit specified in the keyboard:    (keyHUnit = 1,  keyHHalf = 0.5, keyHQuarter = 0.25, keyHEighth = 0.125)</PRE><BR></CODE><BR>    For the built-in ASCII keyboard in current ROMs, the longest row is 14 key units, the smallest key unit used is <CODE>keyHQuarter</CODE>, so the minimal width for the ASCII keyboard is:<BR><BR><CODE><PRE>    m = 14 * (1 / 0.25) = 14 * 4 = 56 pixels.</PRE><BR></CODE><BR>    The keyboard will always be an integral multiple of 56 pixels in width. Note that 224 pixels is exactly 4 * 56. By changing the width to 223, the keyboard now becomes 168 pixels wide.</DL><A NAME="Using_a_Keyboard_Equivalent_to_Close_a_Subview"><H3><HR><B>NEW: </B>Using a Keyboard Equivalent to Close a Subview  (5/12/97)</A></H3><DL><DD>Q:    In my application, I have a linked subview that is linked to a floater view. If I open that linked subview, then use a key command to close the view (on current devices, command-W), my application closes instead of the floater. How do I make the floater respond to a "close" key command?<BR><BR>A:    There is a very subtle implementation detail of key-closing a view that is causing your problem. If you close a view using the keyboard, the following algorithm is used.<BR><BR>    The children of each view, starting at the root view, are searched in reverse order for a close box.<BR><BR>    The order of your base view's children can affect which view is first closed.  If your close box or status bar child is after the linked layout child, then your application will be closed instead of the linked layout. If your close box or status bar child is before the linked layout child, then the linked layout will be closed first.<BR><BR>    You can override this behavior by adding a <CODE>_DoCloseButton</CODE> method to your application's base view. The <CODE>_DoCloseButton</CODE> method is called when a keyboard equivalent is used to close a view.  This method takes no arguments and must return <CODE>true</CODE> if you handled the close, or return <CODE>nil</CODE> to let the system continue to search for a close box in other applications.<BR><BR>    Alternately, instead of creating your child as a linked subview, you could create it using the global function <CODE>BuildContext</CODE>. This guarantees that it will be searched for a close box before your application is searched.</DL><A NAME="Finding_a_KeyCommand_by_KeyMessage"><H3><HR><B>NEW: </B>Finding a KeyCommand by KeyMessage  (6/16/97)</A></H3><DL><DD>Q:    How do I find a <CODE>keyCommand</CODE> if all I have is the <CODE>keyMessage</CODE> symbol?<BR><BR>A:    There is a global function called <CODE>MatchKeyMessage</CODE> that will do what you want. However, the documentation was inadvertently left out of the current version of the Newton Programmers Guide for Newton 2.1 OS. The documentation should be:<BR><CODE><PRE>    MatchKeyMessage(startView, keyMessage)</PRE><BR></CODE><BR>    Finds the <CODE>keyCommand</CODE> frame for the specified message starting with the specified view.<BR><BR>    <CODE>startView</CODE> - The view from which to start searching for the message<BR>    <CODE>keyMessage</CODE> - A symbol for the command message that will be searched for. This must be the same message that is specified in the <CODE>keyMessage</CODE> slot of the <CODE>keyCommand</CODE> frame<BR><BR>    return value - Either <CODE>nil</CODE> or a <CODE>keyCommand</CODE> frame<BR><BR>    The <CODE>MatchKeyMessage</CODE> function searches for the message using the same lookup rules that are used when the system handles a key command.</DL>
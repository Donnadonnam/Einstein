<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Nested Frames and Inheritance</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Nested Frames and Inheritance</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Nested Frames and Inheritance  (10/9/93)</H3><DL><DD>    Unlike C++ and other object oriented languages, NewtonScript does not have the notion of nested frames obtaining the same inheritance scope as the enclosing frame.<BR><BR>    This is an important design issue, because sometimes you want to enclose a frame inside a frame for name scoping or other reasons. If you do so you have to explicitly state the messages sent as well as explicitly state the path to the variable:<BR><BR>    Here's an example that shows the problems:<BR><BR><CODE><PRE>myEncloser := {    importantSlot: 42,    GetImportantSlot := func()        return importantSlot,    nestedSlot := {        myInternalValue: 99,        getTheValue := func()            begin            local foo;            foo := :GetImportantSlot();            // WON'T WORK; can't find function            foo := myEncloser:GetImportantSlot();    // MAY WORK            importantSlot := 12;       // WON'T WORK; will create new slot in nestedSlot            myEncloser.importantSlot := 12;        // MAY WORK            end    }};myEncloser.nestedSlot:GetTheValue();</PRE><BR></CODE>    The proper way to accomplish this is to give the nested frame a <CODE>_parent</CODE> or <CODE>_proto</CODE> slot that references the enclosing frame.  Nesting the frame is not strictly necessary in this case, only the <CODE>_proto</CODE> or <CODE>_parent</CODE> references are used.<BR></DL>
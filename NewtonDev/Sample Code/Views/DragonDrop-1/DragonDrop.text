// Text of project DragonDrop written on 11/25/95 at 5:01 PM// Beginning of text file Project Data/***      Newton Developer Technical Support Sample Code****      DragonDrop, a drag and drop example****      by J. Christopher Bell and James Speir, Newton Developer Technical Support****      Copyright © 1994-5 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/// drag signatureconstant kDragonSignature := '|DragonDrop:PIEDTS|;// text for text converted dragon constant kTextDragon := "Text-converted Dragon";// version of this dragonconstant kVersion := 1;// class for the dragon viewconstant kDragonViewClass := '|view.Dragon:PIEDTS| ;// drag types accepted by the DragonDropView protoconstant	kDragonDropViewDropTypesArray := '[picture, text]; // End of text file Project Data// Beginning of file Dragon// Before Script for "main"/***      Newton Developer Technical Support Sample Code****      DragonDrop, a drag and drop example****      by J. Christopher Bell and James Speir, Newton Developer Technical Support****      Copyright © 1994-5 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/main :=    {viewFlags: 2049,     icon: GetPictAsBits("mainIcon", 1),     viewFormat: nil,     viewBounds: {left: 0, top: 0, right: 33, bottom: 33},     class:       // give this thing a class so we can test for type       kDragonViewClass,     viewGetDropTypesScript:       func(dropPoint)       begin       	nil;		// The dragon won't allow things to be dropped on it.       end,     debug: "main",     viewClass: 76    };constant |layout_Dragon| := main;// End of file Dragon// Beginning of file DragonDropView// Before Script for "dragondropview"/***      Newton Developer Technical Support Sample Code****      DragonDrop, a drag and drop example****      by J. Christopher Bell and James Speir, Newton Developer Technical Support****      Copyright © 1994-5 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/dragondropview :=    {viewFlags: 2593,     viewFormat: 336,     viewGetDropTypesScript:       func(dropPoint)       	// let the Drag and Drop API know which types we accept       	// NOTE: the list is sorted by what we prefer to have dropped       	kDragonDropViewDropTypesArray ;,     viewDragFeedbackScript:       func(dragInfo, dragPoint, show)       begin       	local ourBox := :LocalBox();              	// For our feedback, we draw a thick gray rectangle using the Xor transfer mode.       	// By using Xor, calling this with show=true and then show=nil will erase the        	// feedback rectangle. Note that we use DoDrawing to ensure correct clipping.       	:DoDrawing('DrawShape,       		[MakeRect(ourBox.left + 1, ourBox.top + 1,  ourBox.right - 1, ourBox.bottom - 1),       			{transferMode: modeXor, penSize:3, penPattern:vfGray}]);              	true; // let the Drag and Drop system know that you did draw something.       end,     viewDropScript:       func(dropType, dropData, dropPt)       begin       	if kDebugOn then       	begin       		print("...we got a new item of type '"&dropType&"'. It is the item:");       		print(dropData);       		print("In view Drop Script");       	end ;       	       	if dropType = 'text then begin       		if StrPos(dropData.text,"dragon",0) then begin		// Check to see if the word 'dragon' is in the string       		       			if kDebugOn then       				print("We got a Text Dragon (text which contains the word 'dragon').");       	       			local ourGlobals := :GlobalBox();       			       					// Create a new picture view which has the 'dragon' behavior.       			:AddNewDragon(	dropPt.x - ourGlobals.left, dropPt.y - ourGlobals.top);       			return true;       		end;       		       		else begin       			if kDebugOn then       				Print("We got some random Text");       			// the dropData does not come with a proto or viewClass       			dropData._proto := protoStaticText ;              			:AddNewText(dropData);       			return true;       		end;       	end;              	if dropType = 'picture then begin       		:AddNewPict(dropData);       		return true;       	end;       			       	       	return nil;       end,     AddNewDragon:       // This function will only be used in the beginning to create the initial dragon       // or, if the user writes some text in the edit view which contains the word 'dragon'              func(x, y)       begin       	local protoDragon := GetLayout("Dragon") ;              	// find out from the proto how large a dragon is...       	local width := protoDragon.viewbounds.right - protoDragon.viewbounds.left;       	local height := protoDragon.viewbounds.bottom - protoDragon.viewbounds.top;       	       	       	// position our new child accordingly.       	AddStepView(self, {_proto: protoDragon, viewBounds: RelBounds(x, y, width, height)});       	       	if kDebugOn then       	begin       		print("Added a dragon to:");       		print(viewName);       	end ;       	       	       	// AddStepView() does not automatically update the view.       	// this is a problem for things like borders (ms)       	:Dirty();       end,     viewClickScript:       func(unit)       begin       	// figure out if we hit a dragon, if so drag it       	// otherwise pass the click on              	InkOff(unit) ;              	local hitDragon ;       	local clickX := GetPoint(firstX, unit) ;       	local clickY := GetPoint(firstY, unit) ;       	       	// find the dragon child that was tapped (if any)       	hitDragon := foreach child in :ChildViewFrames() do       		if ClassOf(child) = kDragonViewClass AND IsPtInRect(clickX, clickY, child:GlobalOuterBox()) then       			break child ;              	if hitDragon then       	begin       		hitDragon:Hilite(true) ;              		// Create a frame which can be used by destination views to decide "can I accept this item"       		local ourDragReferenceFrame :=  {       			name: "Skippy",        			text: kTextDragon,        			version: kVersion,       			bounds: hitDragon.viewBounds, 	// Only use this slot when dragon is converted to text        			view: hitDragon,       		};       		       		// Create the drag-and-drop frame. The types parameter is very important to this. The       		// array contains a list of symbols representing potential formats for our data.       		local theFrame := {       			types: ['text, 'picture],        			label: "A Dragon Is On The Clipboard!",       			dragRef: ourDragReferenceFrame,       			view: hitDragon,       		};       		       		:DragAndDrop(unit, hitDragon:GlobalBox(), nil /* pinbounds */,       				nil /* copy := nil */, [theFrame]);              		hitDragon:Hilite(nil) ;              		true;       	end ;       end,     viewDropRemoveScript:       func(dragRef)       begin       	if kDebugOn then       		print("ViewDropRemoveScript");       			/* Our particular drag and drop implementation actually removes our view.       			 * In some cases, you might just modify some of your application's       			 * data structures when using the Drag and Drop API and never create/remove actual views       			 */       	       	RemoveStepView(self, dragRef.view);       	       	if kDebugOn then       	begin       		print("Removed a dragon from:");       		print(viewName);       	end ;       	       	true;	// do not let the default behavior happen       end,     viewDropMoveScript:       func(dragRef, offset, lastDragPt, copy)       begin       	dragRef.view:OffsetView(offset.x, offset.y);       	true;       end,     viewName: nil,     AddnewText:       func(textData)       begin       	AddStepView(self, textData);              	if kDebugOn then       	begin       		print("Added Some text to:");       		print(viewName);       	end ;              	:Dirty();// AddStepView() does not automatically update the view.	       end,     AddNewPict:       func(pictData)       begin       	pictData._proto := GetLayout("Dragon");              	AddStepView(self, pictData);              	if kDebugOn then       	begin       		print("Added a picture to:");       		print(viewName);       	end ;              	:Dirty();// AddStepView() does not automatically update the view.	       end,     viewGetDropDataScript:       func(dragType, dragRef)       begin       	       	if dragType = 'text and dragRef.text = kTextDragon then       	begin       		if kDebugOn then       			print("A text dragon was dragged away successfully.");       	        	       		// return the actual data that will be passed to the destination view.       		// For the 'text type, the viewBounds slot (in source coords) is required.       		return {text: kTextDragon, viewFont: userconfiguration.viewFont,        				viewBounds: dragRef.bounds};       	end;       end,     viewDropDoneScript:       func()       begin       	if kDebugOn then       		print("We are done!!  Yeah!!");       	       	return true;       end,     debug: "dragondropview",     viewClass: 74    };constant |layout_DragonDropView| := dragondropview;// End of file DragonDropView// Beginning of file DragonDrop.t// Before Script for "myapp"/***      Newton Developer Technical Support Sample Code****      DragonDrop, a drag and drop example****      by J. Christopher Bell and James Speir, Newton Developer Technical Support****      Copyright © 1994-5 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/myapp :=    {title: "DragonDrop",     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFormat: 83951953,     viewFlags: 517,     viewJustify: 240,     declareSelf: 'base,     debug: "myapp",     viewClass: 74    };explanation :=    {     text:       "Try dragging the Skippy the Dragon between these views. Then try dragging Skippy to the Notepad and then back!"     ,     viewBounds: {left: 8, top: 24, right: 224, bottom: 64},     viewJustify: 2,     debug: "explanation",     _proto: @218    };AddStepForm(myapp, explanation);View1 :=    {viewBounds: {left: 9, top: 73, right: 223, bottom: 143},     viewSetupDoneScript:       func()       begin       	// When we start this application, create a single new dragon.        	:AddNewDragon(30,30);       	       	viewName := "view1";       end,     debug: "View1",     _proto: dragondropview    };AddStepForm(myapp, View1);StepDeclare(myapp, View1, 'View1);View2 :=    {viewBounds: {left: 9, top: 153, right: 111, bottom: 223},     viewSetupFormScript:       func()       begin       	viewName := "View2";       end,     debug: "View2",     _proto: dragondropview    };AddStepForm(myapp, View2);StepDeclare(myapp, View2, 'View2);View3 :=    {viewBounds: {left: 121, top: 153, right: 223, bottom: 223},     viewSetupFormScript:       func()       begin       	viewName := "View3";       end,     debug: "View3",     _proto: dragondropview    };AddStepForm(myapp, View3);StepDeclare(myapp, View3, 'View3);_view000 :=    {viewBounds: {left: 11, top: 235, right: 225, bottom: 295},     viewFlags: 33553921,     viewFont: simpleFont18,     viewFormat: 12625,     viewLineSpacing: 20,     viewDragFeedbackScript:       func(dragInfo, dragPoint, show)       begin       	local ourBox := :LocalBox();              	// For our feedback, we draw a thick gray rectangle using the Xor transfer mode.       	// By using Xor, calling this with show=true and then show=nil will erase the        	// feedback rectangle. Note that we use DoDrawing to ensure correct clipping.       	:DoDrawing('DrawShape,       		[MakeRect(ourBox.left + 1, ourBox.top + 1,  ourBox.right - 1, ourBox.bottom - 1),       		{transferMode: modeXor, penSize:3, penPattern:vfGray}]);       	       	true; // let the Drag and Drop system know that you did draw something.       end,     viewClass: 77    };AddStepForm(myapp, _view000);_view001 :=    {viewBounds: {left: 0, top: -19, right: 0, bottom: 0},     menuLeftButtons:       [       	protoRecToggle,       ];,     viewJustify: 176,     _proto: @401    };AddStepForm(myapp, _view001);constant |layout_DragonDrop.t| := myapp;// End of file DragonDrop.t
<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Pickers, Popups and Overviews</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Pickers, Popups and Overviews</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="pickersp.htm">Pickers, Popups and Overviews</H2></A><UL><A HREF="#Determining_Which_ProtoSoupOverview_Item_Is_Hit"><B> </B>Determining Which ProtoSoupOverview Item Is Hit  (2/5/96)<BR></A><A HREF="#Displaying_the_ProtoSoupOverview_Vertical_Divider"><B> </B>Displaying the ProtoSoupOverview Vertical Divider  (2/5/96)<BR></A><A HREF="#Validation_and_Editing_in_ProtoListPicker"><B> </B>Validation and Editing in ProtoListPicker  (4/1/96)<BR></A><A HREF="#Picker_List_is_Too_Short"><B> </B>Picker List is Too Short  (4/29/96)<BR></A><A HREF="#Tabs_Do_Not_Work_With_ProtoTextList"><B> </B>Tabs Do Not Work With ProtoTextList  (5/8/96)<BR></A><A HREF="#How_to_Avoid_Problems_with_ProtoNumberPicker"><B> </B>How to Avoid Problems with ProtoNumberPicker  (8/23/96)<BR></A><A HREF="#Single_Selection_in_ProtoListPicker-based_Views"><B> </B>Single Selection in ProtoListPicker-based Views  (9/20/96)<BR></A><A HREF="#How_to_Change_Font_or_LineHeight_in_ProtoListPicker"><B> </B>How to Change Font or LineHeight in ProtoListPicker  (9/20/96)<BR></A><A HREF="#How_to_Preselect_Items_in_ProtoListPicker"><B> </B>How to Preselect Items in ProtoListPicker  (9/20/96)<BR></A><A HREF="#How_to_Get_ProtoSoupOverview_Selections"><B> </B>How to Get ProtoSoupOverview Selections  (10/3/96)<BR></A><A HREF="#Dynamically_Adding_to_ProtoTextList_Confuses_Scrolling"><B> </B>Dynamically Adding to ProtoTextList Confuses Scrolling  (1/15/97)<BR></A><A HREF="#ProtoPicker_Lists_are_Sometimes_Blank"><B>NEW: </B>ProtoPicker Lists are Sometimes Blank  (5/16/97)<BR></A><A HREF="#ProtoPeoplePicker_Name_Display_Changed_in_Newton_2_1"><B>NEW: </B>ProtoPeoplePicker Name Display Changed in Newton 2.1  (7/2/97)<BR></A><A HREF="#Setting_Default_Choices_for_Country_or_State_Pickers"><B>NEW: </B>Setting Default Choices for Country or State Pickers  (7/15/97)<BR></A></UL><A NAME="Determining_Which_ProtoSoupOverview_Item_Is_Hit"><H3><HR><B> </B>Determining Which ProtoSoupOverview Item Is Hit  (2/5/96)</A></H3><DL><DD>Q:    How do I determine which item is hit in a <CODE>protoSoupOverview</CODE>?<BR><BR>A:    There is a method called <CODE>HitItem </CODE>that gets called whenever an item is tapped. The method is defined by the overview and you should call the inherited one. Also note that <CODE>HitItem </CODE>gets called regardless of where in the line a tap occurs. If the tap occurs in the checkbox, you should do nothing, otherwise you should do something.<BR><BR>    The method is passed the index of the hit item. The index is relative to the item displayed at the top of the displayed list. This item is always the current entry of the cursor used by <CODE>protoSoupOverview</CODE>. So, you can find the actual soup entry by cloning the cursor and moving it.<BR><BR>    Here is an example of a <CODE>HitItem </CODE>method. If the item is selected (the checkbox is not tapped) then the code will set an inherited cursor (called <CODE>myCursor</CODE>) to the entry that was tapped on:<BR><BR><CODE><PRE>func(itemIndex, x, y)begin    // MUST call the inherited method for bookeeping    inherited:HitItem(itemIndex, x, y);        if x &gt; selectIndent then    begin  // get a temporary cursor based on the cursor used  // by soup overview        local tCursor := cursor:Clone();  // move it to the selected item        tCursor:Move(itemIndex) ;  // move the inherited cursor to the selected entry        myCursor:Goto(tCursor:Entry());  // usually you will close the overview and switch to  // some other view        self:Close();    end;    // otherwise, just let them check/uncheck // which is the default behaviorend</CODE></PRE></DL><A NAME="Displaying_the_ProtoSoupOverview_Vertical_Divider"><H3><HR><B> </B>Displaying the ProtoSoupOverview Vertical Divider  (2/5/96)</A></H3><DL><DD>Q:    How can I display the vertical divider in a <CODE>protoSoupOverview</CODE>?<BR><BR>A:    The mechanism for bringing up the vertical divider line was not correctly implemented in <CODE>protoSoupOverview</CODE>. You can draw one in a <CODE>viewDrawScript </CODE>as follows:<BR><BR><CODE><PRE>    // setup a cached shape for efficiency    mySoupOverview.cachedLine := nil;    mySoupOverview.viewSetupDoneScript := func()    begin       inherited:?viewSetupDoneScript();           local bounds := :LocalBox();       cachedLine := MakeRect(selectIndent - 2, 0,            selectIndent - 1, bounds.bottom);    end;        mySoupOverview.viewDrawScript := func()    begin       // MUST call inherited script       inherited:?viewDrawScript();           :DrawShape(cachedLine,             {penPattern: vfNone, fillPattern: vfGray});    end;</CODE></PRE></DL><A NAME="Validation_and_Editing_in_ProtoListPicker"><H3><HR><B> </B>Validation and Editing in ProtoListPicker  (4/1/96)</A></H3><DL><DD>Q:    I am trying to use the <CODE>ValidationFrame </CODE>to validate and edit entries in a <CODE>protoListPicker</CODE>. When I edit certains slots I get an error that a path failed. All the failures occur on items that are nested frames in my soup entry. What is going on?<BR><BR>A:    The built-in validation mechanism is not designed to deal with nested soup information. In general, you gain better flexibility by not using a <CODE>validationFrame </CODE>in your pickerDef, even if you have no nested entries. Instead, you can provide your own validation mechanism and editors:<BR><BR>     Define a <CODE>Validate </CODE>method in your picker definition<BR>     Define an <CODE>OpenEditor </CODE>method in your picker definition<BR>     Draw a layout for each editor you require<BR><BR><CODE><PRE>pickerDef.Validate(nameRef, pathArray)</PRE><BR></CODE>    <CODE>nameRef </CODE>- nameRef to validate<BR>    <CODE>pathArray </CODE>- array of paths to validate in the nameRef<BR>    returns an array of paths that failed, or an empty array<BR>    <BR>    Validate each path in <CODE>pathArray </CODE>in the given nameRef. Accumulate a list of paths that are not valid and return them.<BR><BR>    The following example assumes that <CODE>pickerDef.ValidateName </CODE>and <CODE>pickerDef.ValidatePager </CODE>have been implemented:<BR><BR><CODE><PRE>pickerDef.Validate := func(nameRef, pathArray)begin    // keep track of any paths that fail    local failedPaths := [];                                                            foreach index, path in pathArray do    begin        if path = 'name then        begin            // check if name validation fails            if NOT :ValidateName(nameRef) then                // if so, add it to array of failures                AddArraySlot(failedPaths, path);        end;        else begin            if NOT :ValidatePager(nameRef) then                AddArraySlot(failedPaths, path);        end;    end;    // return failed paths or empty array    failedPaths;end;pickerDef.OpenEditor(tapInfo, context, why)</PRE><BR></CODE>    The arguments and return value are as per <CODE>OpenDefaultEditor</CODE>. However, you need to use this instead of <CODE>DefaultOpenEditor</CODE>.<BR><BR><CODE><PRE>pickerDef.OpenEditor := func(tapInfo, context, why)begin   local valid = :Validate(tapInfo.nameRef, tapInfo.editPaths) ;    if (Length(valid) &gt; 0) then        // if not valid, open the editor        // NOTE: returns the edit slip that is opened        GetLayout("editor.t"):new(tapInfo.nameRef,            tapInfo.editPaths, why, self, 'EditDone, context);    else    begin        // the item is valid, so just toggle the selection        context:Tapped('toggle);        nil;                                        // Return &lt;nil&gt;.    end;..end;</PRE><BR>    </CODE>The example above assumes that the layout "editor.t" has a <CODE>New </CODE>method that will open the editor and return the associated View.<BR><BR>    The editor can be designed to fit your data. However, we suggest that you use a <CODE>protoFloatNGo </CODE>that is a child of the root view created with the <CODE>BuildContext </CODE>function. You are also likely to need a callback to the pickderDef so it can appropriately update the edited or new item. Finally, your editor will need to update your data soup uing an "Xmit" soup method so that the listPicker will update.<BR><BR>    In the <CODE>OpenEditor </CODE>example above, the last three arguments are used by the editor to send a callback to the pickerDef from the <CODE>viewQuitScript</CODE>. The design of the callback function is up to you, here is an example:<BR><CODE><PRE>pickerDef.EditDone := func(nameRef, context)begin   local valid = :Validate(tapInfo.nameRef, tapInfo.editPaths) ;    if (Length(valid) &gt; 0) then    begin    // Something failed. Try and revert back to original        if NOT :ValidatePager(nameRef) AND            self.('[pathExpr: savedPagerValue, nameRef]) = nameRef             then            nameRef.pager := savedPagerValue.pager;                context:Tapped(nil);        // Remove the checkmark    end;    else        // The nameRef is valid, so select it.        context:Tapped('select);        // Clear the saved value for next time.    savedPagerValue := nil;        end;</CODE></PRE></DL><A NAME="Picker_List_is_Too_Short"><H3><HR><B> </B>Picker List is Too Short  (4/29/96)</A></H3><DL><DD>Q:    I have items in my picker list with different heights that I set using the <CODE>fixedHeight </CODE>slot. When I bring up the picker, it is not tall enough to display all the items. Worse, I cannot scroll to the extra items. What is going on?<BR><BR>A:    The <CODE>fixedHeight </CODE>slot is used for two separate things. Any given pick item can use the <CODE>fixedHeight </CODE>slot to specify a different height. This works fine.<BR><BR>    However, the code in Newton 2.0 OS that determines how big the list should be also uses the <CODE>fixedHeight </CODE>slot of the first pick item (in other words, <CODE>pickItems[0]</CODE>) if it exists. It is as if the following code executes:<BR><BR><CODE><PRE>local itemHeight := kDefaultItemHeight;if pickItems[0].fixedHeight then   itemHeight := pickItems[0].fixedHeight;local totalHeight := itemHeight * Length(pickItems);</PRE><BR></CODE>    This total height is used to figure out if scrolling is required. As you can see, this can cause problems if your first item is not the tallest one. The solution is to make sure the first item in your  <CODE>pickItems</CODE> array has a <CODE>fixedHeight </CODE>slot that is sufficiently large to make scrolling work correctly. This may be fixed in future revisions of the NewtonOS.<BR><BR>    Note that there will be similar problems if your pick items contain icons. The system will use the default height unless you specify a <CODE>fixedHeight </CODE>slot in your first item. The default height is not tall enough for most icons. In other words, if you have icons in your pick items, you must have a <CODE>fixedHeight </CODE>slot in the first item that is set to the height of your icon.</DL><A NAME="Tabs_Do_Not_Work_With_ProtoTextList"><H3><HR><B> </B>Tabs Do Not Work With ProtoTextList  (5/8/96)</A></H3><DL><DD>Q:    I tried to use tabs to get columns in a <CODE>protoTextList </CODE>but they do not appear. How do I get columns?<BR><BR>A:    The text view in <CODE>protoTextList </CODE>is based on a simple text view which does not support tabs. If you want scrolling selectable columns you can use shapes to represent the rows. If you need finer control, use the <CODE>LayoutTable </CODE>view method.</DL><A NAME="How_to_Avoid_Problems_with_ProtoNumberPicker"><H3><HR><B> </B>How to Avoid Problems with ProtoNumberPicker  (8/23/96)</A></H3><DL><DD>Q:    I am thinking of using <CODE>protoNumberPicker</CODE> for input. (or) I have used <CODE>protoNumberPicker</CODE> and have encountered a bug/misfeature/problem. What should I use?<BR><BR>A:    <CODE>protoNumberPicker</CODE> has several instabilities and bugs. We recommend that you use the DTS sample code "protoNumberPicker_TDS". It provides all of the features of <CODE>protoNumberPicker</CODE> with none of the bugs. It also provides additional functionality that is not in <CODE>protoNumberPicker</CODE>. See the sample code for more detail.<BR></DL><A NAME="Single_Selection_in_ProtoListPicker-based_Views"><H3><HR><B> </B>Single Selection in ProtoListPicker-based Views  (9/20/96)</A></H3><DL><DD>Q:    How do I allow only one item to be selected in a <CODE>protoListPicker</CODE>, <CODE>protoPeoplePicker</CODE>, <CODE>protoPeoplePopup</CODE>, or<CODE> protoAddressPicker</CODE>?<BR><BR>A:    The key to getting single selection is that single selection is part of the picker definition and not an option of <CODE>protoListPicker</CODE>. That means that the particular class of nameRef you use must include single selection. In general, this requires creating your own subclass of the particular name reference class.<BR><BR>    The basic solution is to create a data definition that is a subclass of the particular class that your <CODE>protoListPicker </CODE>variant will view. That data definition will include the <CODE>singleSelect </CODE>slot. As an example, suppose you want to use a <CODE>protoPeoplePopup </CODE>that just picks individual people. You could use the following code to bring up a <CODE>protoPeoplePopup </CODE>that only allowed selecting one individual at one time:<BR><BR><CODE><PRE>    // register the modified data definition    RegDataDef('|nameref.people.single:SIG|,    {_proto: GetDataDefs('|nameRef.people|), singleSelect: true});    // then pop the thing    protoPeoplePopup:New('|nameref.people.single:SIG|,[],self,[]);    // sometime later    UnRegDataDef('|nameref.people.single:SIG|);</PRE><BR></CODE>    For other types of <CODE>protoListPickers</CODE> and classes, create the appropriate subclass. For example, a transport that uses <CODE>protoAddressPicker </CODE>for emails might create a subclass of <CODE>'|nameRef.email|</CODE> and put that subclass symbol in the <CODE>class </CODE>slot of the <CODE>protoAddressPicker</CODE>.<BR><BR>    Since many people are likely to do this, you may cut down on code in your <CODE>installScript </CODE>and <CODE>removeScript </CODE>by registering your dataDef only for the duration of the picker. That would mean registering the class just before you pop the picker and unregistering after the picker has closed. You can use the <CODE>pickActionScript </CODE>and <CODE>pickCanceledScript </CODE>methods to be notified when to unregister the dataDef.</DL><A NAME="How_to_Change_Font_or_LineHeight_in_ProtoListPicker"><H3><HR><B> </B>How to Change Font or LineHeight in ProtoListPicker  (9/20/96)</A></H3><DL><DD>Q:    How do I set a different font for the items in the <CODE>protoListPicker</CODE>?<BR><BR>A:    There is a way to change the font in the Newton 2.0 OS, however, we intend to change the mechanism in the future. Eventually, you will be able to set a <CODE>viewFont </CODE>slot in the <CODE>protoListPicker </CODE>itself and have that work (just like you can set <CODE>viewLineSpacing </CODE>slot now). In the meantime, you need a piece of workaround code. Warning: you must set the viewFont of the listPicker AND include this workaround code in the <CODE>viewSetupDoneScript</CODE>:<BR><BR><CODE><PRE>func()    begin       if listBase exists and listBase then          SetValue(listBase, 'viewFont, viewFont) ;           inherited:?viewSetupDoneScript();    end;</PRE><BR></CODE>    This will set the <CODE>viewFont </CODE>slot of the <CODE>listBase</CODE> view to the <CODE>viewFont </CODE>of the <CODE>protoListPicker</CODE>. You cannot rely on the listbase view always being there, hence the test for its existence.<BR><BR>    Note that you can use the same code to modify the <CODE>lineHeight</CODE> slot of the listPicker. Just substitute <CODE>lineHeight</CODE> for <CODE>viewFont</CODE> in the code snippet. The one caveat is that the <CODE>lineHeight</CODE> must be at least 13 pixels.</DL><A NAME="How_to_Preselect_Items_in_ProtoListPicker"><H3><HR><B> </B>How to Preselect Items in ProtoListPicker  (9/20/96)</A></H3><DL><DD>Q:    If I put name references in the <CODE>selected</CODE> array of a <CODE>protoListPicker</CODE>, it throws a <CODE>-48402</CODE> error. How do I preselect items?<BR><BR>A:    In the MessagePad 120/130 units it is not possible to preselect items in the listPicker and have it work correctly. We recommend that you use the "protoSlimPicker" DTS Sample Code instead.</DL><A NAME="How_to_Get_ProtoSoupOverview_Selections"><H3><HR><B> </B>How to Get ProtoSoupOverview Selections  (10/3/96)</A></H3><DL><DD>Q:    How do I get the selected items in <CODE>protoSoupOverview</CODE>?<BR><BR>A:    The final documentation inadvertantly left out the following documentation on the <CODE>selected</CODE> slot:<BR><BR>    <CODE>selected</CODE>    - Required. Initially set to <CODE>nil</CODE>; it is modified by <CODE>protoSoupOverview</CODE> as the user selects and deselects overview items. <BR>                This slot contains an array of soup entry aliases to the selected items when the overview is closed, or <CODE>nil</CODE> or the empty array if there is no selection. For example:<BR>                <CODE><PRE>                    [[alias: NIL, 66282812, 84, "Names"],                  [alias: NIL, 66282812, 85, "Names"]]</CODE></PRE></DL><A NAME="Dynamically_Adding_to_ProtoTextList_Confuses_Scrolling"><H3><HR><B> </B>Dynamically Adding to ProtoTextList Confuses Scrolling  (1/15/97)</A></H3><DL><DD>Q:    I am adding items to a <CODE>protoTextList</CODE> after it is displayed. I add an item and scroll to highlight that item. However, the state of the scroll arrows does not correctly get updated. Sometimes it will indicate that there are more items to scroll when it is really at the end of the list.<BR><BR>A:    There is a problem with Newton 2.0 OS devices (although not Newton 2.1 OS devices) that causes the <CODE>protoTextList</CODE> to reset the scroll distance when you update the listItems array. The workaround is to always scroll the list to the top before calling <CODE>SetupList</CODE> when you add items. Then you can scroll the list to where you want it. Note that this workaround is safe to use in Newton 2.1 OS as well. In other words, if you are adding items to a <CODE>protoTextList</CODE>, use this workaround unless your application is Newton 2.1 OS-specific. This method will add a single item to the <CODE>protoTextList</CODE>, set the highlighted item to the new item and scroll if required. It will also make sure the item is unique.<BR><BR><CODE><PRE>    AddListItem := func(newItem)    begin         // Insert the item if not already in Array        local index := BInsert(listItems, item, '|str&lt;|, nil, true);        // item must be in the array and index will point to the item.        if NOT index then        begin            :Notify(kNotifyAlert, kAppName, "Duplicate entry.");            return nil;        end;        // workaround a bug in 2.0 that causes the        // scroll arrows to get out of sync        // do this by scrolling to the top        :DoScrollScript(-viewOriginY) ;        self:SetUpList();        // Setting the selection slot will highlight the item        selection := index;        // scroll to show the new item        if index &gt;= viewLines then            :DoScrollScript((index - viewLines + 1) * lineHeight) ;        self:RedoChildren();        return true;    end ;</CODE></PRE></DL><A NAME="ProtoPicker_Lists_are_Sometimes_Blank"><H3><HR><B>NEW: </B>ProtoPicker Lists are Sometimes Blank  (5/16/97)</A></H3><DL><DD>Q:    I have a <CODE>protoPicker</CODE> that I reuse in my application. Sometimes the picker will be blank when I open it. What's happening?<BR><BR>A:    <CODE>ProtoPicker</CODE> does not correctly reset the <CODE>viewOriginY</CODE> slot if you  display a list that requires scrolling, and then display one that does not require scrolling. The solution is to manually reset the <CODE>viewOriginY</CODE> slot to 0 if you dynamically change the contents of the picker.</DL><A NAME="ProtoPeoplePicker_Name_Display_Changed_in_Newton_2_1"><H3><HR><B>NEW: </B>ProtoPeoplePicker Name Display Changed in Newton 2.1  (7/2/97)</A></H3><DL><DD>Q:    In Newton OS 2.0, the <CODE>protoPeoplePicker</CODE> displayed names as "last, first", but in Newton 2.1 OS it displays "first last". How can I make <CODE>protoPeoplePicker</CODE> display the original way?<BR><BR>A:    You will need to create a subclass of the <CODE>nameRefDataDef</CODE> for people that will display the name in "last, first" format. The good news is that this workaround will work on both Newton 2.0 and Newton 2.1. The basic steps are:<BR><BR>    1. Register your own subclass of <CODE>nameRefDataDef</CODE> that does the right thing<BR><BR>    2. Use this new data def class in the <CODE>dataClass</CODE> slot of your <CODE>peoplePicker</CODE><BR><BR>    3. Unregister your subclass when you are done (for instance, when quitting the application)<BR><BR><BR>    Here is some code that can be used to register a subclass. Put the following in a text file in your project:<BR><BR><CODE><PRE>    // create a unique symbol for the the data def    DefineGlobalConstant('kMyDataDefSym,        Intern("nameRef.people.lastFirst:" & kAppSymbol)) ;    DefineGlobalConstant('kMyGetFunc,        func(item, fieldPath, format)        begin            // if this is a person, not a company, modify stuff            local entry := EntryFromObj(item) ;                if fieldPath = 'name AND format = 'text AND entry AND                 IsFrame(entry) AND ClassOf(entry) = 'person then            begin                local nameFrame := entry.name ;                if nameFrame AND nameFrame.first AND nameFrame.last then                    return nameFrame.last & ", " & nameFrame.first ;                else                    return inherited:Get(item, fieldPath, format) ;            end             else                return inherited:Get(item, fieldPath, format) ;        end    ) ;</PRE><BR></CODE>    <BR>        Put this code into the <CODE>viewSetupFormScript</CODE> of the base view of your application:<BR>    <BR>            <CODE><PRE>            // register my modified people data def        RegDataDef(kMyDataDefSym, {_proto: GetDataDefs('|nameRef.people|),                        Get: kMyGetFunc}) ;</PRE><BR></CODE>    <BR>        Put this code into the <CODE>viewQuitScript</CODE> of the base view of your application:<BR>    <BR><CODE><PRE>        // unregister my modified people data def        UnRegDataDef(kMyDataDefSym) ;</PRE><BR></CODE>    <BR><BR>        Use the <CODE>kMyDataDefSym</CODE> constant as the value for the <CODE>dataClass</CODE> slot of your <CODE>protoPeoplePicker</CODE> or <CODE>protoPeoplePopup</CODE><BR>                        </DL><A NAME="Setting_Default_Choices_for_Country_or_State_Pickers"><H3><HR><B>NEW: </B>Setting Default Choices for Country or State Pickers  (7/15/97)</A></H3><DL><DD>Q:    How do I set a default country for <CODE>protoCountryTextPicker</CODE> or default state for <CODE>protoUSstatesTextPicker</CODE>?<BR><BR>A:    You can specify a default country/state by adding a slot called <CODE>'default</CODE> to the <CODE>params</CODE> frame. The slot must contain the name of the country (<CODE>protoCountryTextPicker</CODE>) or state (<CODE>protoUSstatesTextPicker</CODE>) as a string. For example, if you wanted the <CODE>protoCountryTextPicker</CODE> to default to Canada, you could do the following in the <CODE>viewSetupFormScript</CODE>:<BR><BR><CODE><PRE>    // get a writeable copy of the params frame    self.params := Clone(params);    params.default := "Canada";</CODE></PRE></DL>
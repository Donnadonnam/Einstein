/***      Newton Developer Technical Support Sample Code****      CompNRun, a stream file used as a protocol extension by the PDILs****      by David Fedor, Newton Developer Technical Support****      Copyright © 1997 Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/// The parameter is a frame://    src:   The NewtonScript source which should be compiled//    args:  If specified, then the compiled src must be a function; it//           will be called with the specified arguments.  (If there are//           no arguments needed for your function, put NIL here.)//    debug: If this slot is non-NIL and something throws, CurrentException() //           will be copied to element 1 of the returned array (see below).//// This protocol extension will return an array to the caller://    element 0: either NIL (no problems), or an integer specifying//               what was being done when the throw happened.//               0=compiling, 1=evaluating, 2=calling the function//    element 1: the statement result, or the return value of calling the function//// This routine is intentionally compact & terse since it gets downloaded// to the Newton device during a PDIL session, and thus lives in the heap.theStream := func(ep) begin	local param := ep:ReadCommandData();	local ret;	local obj;	local step:=0;	// used to tell where the throw happened	try		obj:= compile(param.src);			// compile it		step:=1;		obj:=call obj with ();				// evaluate it		step:=2;		ret := [nil, (if param.args exists then call obj with (param.args) else obj)];	onexception |evt.ex| do begin		// tell the caller that a throw happened, and optionally what it was.		ret := [step, if param.debug then CurrentException()];	end;	ep:WriteCommand("CRun",ret,true);	// send the result to the desktopend;/*// And now for a useful little inspector trick, handy to convert the stream into// a good form for inserting into a C application as static data.  Edit the file// name and path at the bottom, select the whole block, and hit whatever key// you've set up to execute NewtonScript locally (see below for details).// Then copy the data out of the inspector window into your C source file!//// If you're using WinNTK, the stream file can be read directly.  With MacNTK,// it is more work since LoadDataFile() doesn't exist on MacNTK (yet).  You// should use something like Clipboard Magician or Res to get the stream file// converted into a resource, which can then be read with GetResource().// I put the data in a "STRM" resource inside the stream file; it could// be placed anywhere if the filename and resource information below is// changed appropriately.//// For WinNTK, to make shift-enter to execute NewtonScript locally,// make a file in NTK's directory called GlblData.f containing this code://     protoeditor:DefineKey( {key:$\n, shift:true}, 'EvaluateSelection);// For MacNTK, do the same but name the file "GlobalData" (no quotes).// You must quit and restart NTK to have the definition take effect.// NOTE: $\n is the key above shift, not the one on the keypad.//// This will work similarly to the way you execute NewtonScript in the inspector// window, but it runs inside of NTK and a connection to a Newton device isn't// necessary.  You can evaluate NewtonScript code in any window, and the result// will be printed to the inspector window.	call func(filename, rsrcType, rsrcID) begin		local f,data,i,t;		if rsrcType then begin			f:=OpenResFileX(filename);			data:=GetResource(rsrcType, rsrcID,'stream);			CloseResFileX(f);		end else			data:=LoadDataFile(filename, 'stream);	// we're on WinNTK so just read the data.	  		write("{");		local hex:="0123456789ABCDEF";		for i:=0 to length(data)-1 do begin			t:=extractbyte(data,i);			if t<0 then t:=256+t;			write("0x" & hex[t div 16] & hex[t mod 16] & ", ");			if band(i,15)=15 then write("\n ");		end;		write("};\n");	// choose one of the following lines, depending on whether you're	// on WinNTK or MacNTK... and change the path as appropriate.//	end with ("c:\\CompNRun\\CompNRun.stm", nil, nil)	end with ("Innards:CompNRun:CompNRun.stream", "STRM", 128)*/
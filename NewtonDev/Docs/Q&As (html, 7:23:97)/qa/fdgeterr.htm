<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Error -28801 or -28706 from FDget</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Error -28801 or -28706 from FDget</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Error -28801 or -28706 from FDget  (5/13/96)</H3><DL><DD>Q:    Why does the <CODE>FDget </CODE>function return error -28801 (Out of heap memory) or -28706 (Invalid parameter)?  I don't think I'm out of memory, and I don't always get this error code so my parameters must be right. What is wrong?<BR><BR>A:    Sometimes these error codes are accurate and indicate that not enough memory could be allocated or that a parameter was invalid.  Sometimes they are the result of a bug caused by having multiple copies of a rectangle slot inside a frame.<BR><BR>    The protocol which is used to send frames can perform an optimization for certain rectangle frames, which transmits them in a compact form (5 bytes instead of up to 60).  However, if a given frame holds the exact same rectangle frame in more than one slot, the data will not be handled correctly and will either result in one of these error codes, or alternatively it might substitute some other object in place of the frame, or might possibly crash.<BR><BR>    This is a relatively uncommon problem, since all of the values in the frame must be between 0 and 255, and the frame must have the same rectangle in it twice - two frames with equivalent data would not trigger the problem.  For example, frame "A" would cause the problem, but frames "B", "C" and "D" would not.<BR><BR><CODE><PRE>A:={first: {left:3, right: 30, top:10, bottom:90}};A.second := A.first;           // triggers the problemB:={first: {left:3, right: 30, top:10, bottom:90}};B.second := clone(B.first);    // cloning avoids the problemC:={first: {left:3, right: 30, top:10, bottom:90, foo: nil}};C.second := C.first;           // no problem since C.foo existsD:={first: {left:3, right: 30, top:10, bottom:1000}};D.second := D.first;       // no problem since D.bottom is &gt;255</PRE><BR></CODE><BR>    To work around this problem, you can clone the frame (as in frame "B") or add another slot to the frame (as in frame "C") or ensure that the values are not between 0 and 255 (frame "D").<BR><BR>    Note: this has been fixed in the 1.0.2 Windows DILs.</DL>
// Text of project ListPickerArray written on 11/21/95 at 6:09 PM// Beginning of text file ProjectData/***      Newton Developer Technical Support Sample Code**		**      ListPicker,  Demostrates the basic list picker.****      by Stephen Harris, Newton Developer Technical Support****      Copyright © 1993-1995 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*//*This listPicker demonstrates the basic entries that are needed for a listPicker that   uses an array of items that are internal to the application.*/constant kAppTitle := "The ListPicker";//Random data generator for items that will be displayed in the listPickerDefConst('kCanonicalEntry,  '{		first: nil,		second: nil,	});// *** kRandomDataGeneratorFuncDefConst('kRandomDataGeneratorFunc, func()	begin		local item := clone(kCanonicalEntry);		item.first :=  Capitalize(GetRandomWord(4, 12)) ;		item.second := Capitalize(GetRandomWord(4, 12)) ;		item;	end);// End of text file ProjectData// Beginning of text file pickerDef.f//Copyright © 1993-1995 by Apple Computer, Inc.  All rights reserved//listPicker defs//used to define the pickerDef at compile time.  May include all of the slots for the pickerDef.// the constant is used in the slot myListPicker.pickerDefDefConst('kMyBasicDataDef,{	 _proto: protoNameRefDataDef,		// Required	 validationFrame: nil,				// must override since no editing supported	 name:  "Random Data ",				// name at top left of picker	 //singleSelect: true,				// allow only one row select at a time	 primaryPath: 'second,				// path in entry used for sorting the list});// End of text file pickerDef.f// Beginning of file ListPickerArray.tappBase :=    {viewBounds: {left: 0, top: 0, right: 240, bottom: 320},     viewFlags: 1,     declareSelf: 'base,     viewJustify: 0,     viewQuitScript:       func()       begin       		// memory reclamation project       	myListPicker.selected := nil;       	reOrienting:= nil;       end,     viewSetupFormScript:       func()       begin       	//set up app display       	local b := GetAppParams();       	self.viewBounds := RelBounds(b.appAreaLeft, b.appAreaTop,       		b.appAreaWidth, b.appAreaHeight);       	       	//populate myListPicker       	if NOT reOrienting then       		:generateData();       end,     GenerateData:       func()       begin       	// Create entries for the listPicker selected array.        	// the key function to use is makeNameRef(object, makeObjectthisClass)       	// which returns an object for the selectedArray. The object needs to       	// be of class 'nameRef.  The pickerDef has a class slot that is set       	// to 'nameRef so the assigned object will be a 'nameRef.               	// Note: You could pass 'nameRef as the second arguement to makeNameRef instead       	//		 of using a class slot in the pickerDef       	       	local theListPicker := myListPicker;       	theListPicker.selected := Array(20,nil);              	for i := 0 to 19 do       	begin       		local item := theListPicker.pickerDef:MakeNameRef(       				call kRandomDataGeneratorFunc with (), nil);       		// need to manually set the selected state to not selected       		item._unselected := true;       		theListPicker.selected[i] := item;       	end;              	// select the first item in the listPicker.       	//*** Note that if singleSelect is set to true       	// you must make sure that you select only one item              	theListPicker.selected[0]._unselected := nil;       end,     title: kAppTitle,     ReorientToScreen:       func()       begin       	reOrienting:= true;				//set to not rebuild the selected array during rotation       	:syncView();       	       	// stop the selected array from being purged of       	// non-selected items when it closes       	myListPicker.dontPurge:= true;              	:RedoChildren();              	// reset the purge slot so that listPicker       	// will purge when it closes normally       	myListPicker.dontPurge:= nil;              	reOrienting:= nil;				//the rotation is completed       end,     reOrienting: nil,     debug: "appBase",     viewClass: 74    };_view000 :=    {viewBounds: {left: 0, top: 0, right: 150, bottom: 20}, _proto: @229};AddStepForm(appBase, _view000);mylistpicker :=    {viewFlags: 513,     viewBounds: {left: 0, top: 20, right: 0, bottom: -45},     pickerDef:       {       	_proto: kmyBasicDataDef,	// defined in the pickerDef.f file       	class:  'nameRef,      		// always include        	columns:       	[	// Column 1       		{       			fieldPath: 'first,	// field to display in column       			tapWidth: 100,			// width for checkbox & name combined, offset from the right margin		       			doRowHilite: true,       		},       		       		// Column 2       		{       			fieldPath: 'second,	// field to display in column       			tapWidth: 0, 			// width from preceeding column to right bounds       			doRowHilite: true,       		},       	],       	       },     suppressCloseBox:       //suppress the listpickers close box       true,     suppressFolderTabs:       //suppress filing show bar       true,     suppressNew:       //suppress new entries button for listPicker       true,     viewJustify: 240,     dontpurge:       // determines if listPicker will purge the selected array when closed       nil,     selected: nil,     debug: "mylistpicker",     _proto: @461    };AddStepForm(appBase, mylistpicker);StepDeclare(appBase, mylistpicker, 'mylistpicker);_view001 :=    {     buttonClickScript:       func()       begin       	whatSelected:open();       end,     text: "What is selected",     viewBounds: {left: 0, top: 6, right: 100, bottom: 24},     viewJustify: 8396950     ,     _proto: @226    };AddStepForm(appBase, _view001);_view002 := {_proto: @219};AddStepForm(appBase, _view002);WhatSelected :=    {viewBounds: {left: -1, top: 72, right: 106, bottom: 188},     debug: "WhatSelected",     _proto: @180    };AddStepForm(appBase, WhatSelected);StepDeclare(appBase, WhatSelected, 'WhatSelected);_view003 :=    {     buttonClickScript:       func(textIndex)       begin       	print("selected index " & textIndex);       end,     viewBounds: {left: 0, top: 0, right: 0, bottom: 116},     viewFont: ROM_fontSystem9,     viewLines: 6,     viewSetupFormScript:       func()       begin       	// call the getSelected fucntion with true to return only the items       	// that are currently selected'       	// NOTE: as items are selected nameRef's are created and put in the selected array.        	// GetSelected returns an array of the selected items and removes all other nameRef's       		       	local myArray := [];       	foreach item in myListPicker:getSelected(true) do       		AddArraySlot(myArray,(item.first && item.second));              	self.listItems := myArray;              	:SetupList();       end,     listItems: nil,     viewJustify: 48,     viewFormat: 1,     useScrollers: true,     _proto: @228    };AddStepForm(WhatSelected, _view003);constant |layout_ListPickerArray.t| := appBase;// End of file ListPickerArray.t
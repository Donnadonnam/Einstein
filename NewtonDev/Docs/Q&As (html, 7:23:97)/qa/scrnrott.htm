<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Screen Rotation and Linked Views or BuildContext Slips</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Screen Rotation and Linked Views or BuildContext Slips</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Screen Rotation and Linked Views or BuildContext Slips  (3/10/97)</H3><DL><DD>Q:    I've got a linked view open, and I'm trying have it rotate with <CODE>ROM_DefRotateFunc</CODE>. When I rotate the screen the base view rotates properly, but the linked view closes.  Do I need to add a <CODE>ReorientToScreen</CODE> slot to the linked view?<BR><BR>A:    When the user requests a screen rotation, the OS first checks each immediate child of the root view to see if it will still operate on the rotated screen.  Having a <CODE>ReorientToScreen</CODE> slot in the view tells the OS that this view is OK, so the slot is used first as a token ("magic cookie") to tell the OS that this view knows about rotation.  Later during the rotation operation, the <CODE>ReorientToScreen</CODE> message is sent to your application's base view and to other views that are immediate children of the root view.  That method then performs its second function, which is to completely handle resizing the view and its children for the new screen size. (Even views which are small enough so that no resizing is necessary need a <CODE>ReorientToScreen</CODE> method.  That method may need to move the base view to ensure that it remains on-screen after rotation.)<BR><BR>    It's convenient to use the <CODE>ROM_DefRotateFunc</CODE> for this script, since it fills the magic cookie requirement and handles resizing for most views.  <CODE>ROM_DefRotateFunc</CODE> is very simple: it send a close and then an open message to the view.  Since well-written applications take screen size into account when they open, this works fine in most cases.  However, applications that keep track of internal state that isn't preserved when the app is closed can't use <CODE>ROM_DefRotateFunc</CODE>, because when the app reopens on the rotated screen, it will look different.  Opening a linked subview is one example of this; it doesn't usually make sense to remember that a slip is open, since it's usually closed when your application is closed.<BR><BR>    Adding a <CODE>ReorientToScreen</CODE> method to your linked views wouldn't help; since they are descendents of your base view and not children of the root view, the OS wouldn't handle these views.  (It's up to your application to keep its kids under control.)  You could change your application so that it kept track of whether the linked views were open or closed, and restored them to the same state when it was reopened.  However, this might be confusing to users who closed your app and then opened it again much later.<BR><BR>    A better workaround is to implement your own <CODE>ReorientToScreen</CODE> method, which either resizes the views so they fit on the new screen, or which closes and reopens the views such that the floaters also re-open.  By using the <CODE>ReorientToScreen</CODE> message to handle the special case, you get to do something different during rotation versus during opening at the user request (for example, after tapping on the Extras icon.)<BR><BR>    Slips created with <CODE>BuildContext</CODE> also must be handled carefully during rotation.  Because they are themselves children of the root view, they'll each need their own <CODE>ReorientToScreen</CODE> method or the screen may not be rotatable when they are open or they won't reopen after rotation.  If you use <CODE>ROM_DefRotateFunc</CODE>, the slip itself will be closed and reopened, and care may need to be taken to ensure the slip properly handles being reopened, and that its connection to its controlling application is not lost.<BR></DL>
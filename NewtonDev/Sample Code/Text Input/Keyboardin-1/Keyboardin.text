// Text of project Keyboardin written on 2/4/97 at 11:35 AM// Beginning of file Keyboardin.t// Before Script for baseView// Copyright ©1996-7 Apple Computer, Inc.  All rights reserved.baseView :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 5,     viewJustify: 240,     declareSelf: 'base,     DisplayPrint:       func( text, args )       begin       	Write( text );       	Write( " --> " );       	Print( args );       end,     ViewCaretActivateScript:       // viewCaretActivateScript is called when this view either gains       // or loses the key view focus.       func( active )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewCaretActivateScript in baseView", active );       	       	nil;       end,     ViewKeyDownScript:       // viewKeyDownScript is called when the user presses a key on either       // the software keyboard or the hardware keyboard       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyDownScript in baseView", [key, flags] );       	       	nil;       end,     ViewKeyRepeatScript:       // viewKeyRepeatScript is called when the user holds down a key       // the software keyboard or the hardware keyboard       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyRepeatScript in baseView", [key, flags] );       	       	nil;       end,     ViewKeyStringScript:       // viewKeyStringScript is called when the views vSingleKeystrokes       // textFlag is not set, and the Newton cannot keep up with the        // users typing pace.  A batch of keystrokes will be passed to the       // viewKeyStringScript method       func( string )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyStringScript in baseView", string );              	nil;       end,     ViewKeyUpScript:       // viewKeyUpScript is called when the user releases a key on either       // the software keyboard or the hardware keyboard       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyUpScript in baseView", [key, flags] );       	       	nil;       end,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	// Remove all the key commands registered with the base view.  If you       	// don't remove the registered key commands, they will waste NewtonScript       	// heap space.       	// Key commands are also cleaned up when a view is closed and disposed of,       	// however, the base application view is never disposed of until the       	// application is deleted from the system, so we need to explicity remove them.       	       	// Again, this method is called conditionally so that this sample       	// will work on Newton 2.0 OS.       	:?ClearKeyCommands();       	       	// Be sure to call the inherited method       	inherited:?viewQuitScript();       end,     viewSetupFormScript:       func()       begin       	// Register our key commands with the base view.  We will have to unregister these       	// commands in the viewQuitScript.  If you just need to register one command, you       	// can use the view method AddKeyCommand instead of AddKeyCommands.       	       	// This method is called conditonally so that this sample will work on        	// Newton 2.0 OS as well.       	:?AddKeyCommands( keyCommandArray );       end,     keyCommandArray:       [       	{       		char:		$g,       		modifiers:	kCommandModifier,       		keyMessage:	'DoGKeyCommand,       		name:		"Do G Key",       		category:	"Keyboardin",       	},       	{       		char:		$b,       		modifiers:	kCommandModifier,       		keyMessage:	'DoBKeyCommand,       		name:		"Do B Key",       		category:	"Keyboardin",       	},       ],     DoGKeyCommand:       func( keyView )       begin       	:DisplayPrint( "In DoGKeyCommand", keyView );       end,     DoBKeyCommand:       func( keyView )       begin       	:DisplayPrint( "In DoBKeyCommand", keyView );       end,     viewClass: 74 /* clView */    };ViewA :=    {viewBounds: {left: 2, top: -40, right: 45, bottom: -30},     viewFlags: 15873,     viewFont: simpleFont18,     viewFormat: 12625,     viewLineSpacing: 20,     viewSetupFormScript:       func()       begin       	// Register our key command with ViewA.  We will have to unregister these       	// commands in the viewQuitScript.         	       	// This method is called conditonally so that this sample will work on        	// Newton 2.0 OS as well.       	:?AddKeyCommand( keyCommand );       	       	// Make this view the key view       	SetKeyView( self, 0 );       end,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	// Remove all the key commands registered with ViewA.  If you       	// don't remove the registered key commands, they will waste NewtonScript       	// heap space.       	// Key commands are also cleaned up when a view is closed and disposed of,       	// so calling ClearKeyCommands is not necessary in this view.  Its a good       	// idea to call it anyway.       	       	// Again, this method is called conditionally so that this sample       	// will work on Newton 2.0 OS.       	:?ClearKeyCommands();       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     keyCommand:       {       	char:		$l,       	modifiers:	kCommandModifier,       	keyMessage:	'DoLKeyCommand,       	name:		"Do L Key",       	category:	"Keyboardin",       },     ViewKeyDownScript:       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyDownScript in View A", [key, flags] );       	       	nil;       end,     ViewKeyUpScript:       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyUpScript in View A", [key, flags] );       	       	nil;       end,     ViewKeyRepeatScript:       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyRepeatScript in View A", [key, flags] );       	       	nil;       end,     ViewCaretActivateScript:       func( active )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewCaretActivateScript in View A", active );       	       	nil;       end,     ViewKeyStringScript:       func( string )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyStringScript in View A", string );              	nil;       end,     textFlags: nil,     viewJustify: 469762176,     DoLKeyCommand:       func( keyView )       begin       	:DisplayPrint( "In DoLKeyCommand", keyView );       end,     viewClass: 81 /* clParagraphView */    };AddStepForm(baseView, ViewA);StepDeclare(baseView, ViewA, 'ViewA);baseView_v218_0 :=    {text: "View A",     viewBounds: {left: 0, top: -19, right: 104, bottom: -5},     viewJustify: 8407040,     _proto: @218 /* protoStaticText */    };AddStepForm(baseView, baseView_v218_0);baseView_v164_0 :=    {text: "Use vSingleKeystrokes Flag",     viewBounds: {left: 0, top: -19, right: 150, bottom: -5},     valueChanged:       func()       begin       	if viewValue then       		SetValue( viewA, 'textFlags, vSingleKeystrokes );       	else       		SetValue( viewA, 'textFlags, nil );       end,     viewValue: nil,     viewJustify: 8407040,     _proto: @164 /* protoCheckBox */    };AddStepForm(baseView, baseView_v164_0);ViewB :=    {viewBounds: {left: -45, top: -40, right: -2, bottom: -30},     viewFlags: 15873,     viewFont: simpleFont18,     viewFormat: 12625,     viewLineSpacing: 20,     viewSetupFormScript:       func()       begin       	// Register our key commands with ViewB.  We will have to unregister these       	// commands in the viewQuitScript.  If you just need to register one command, you       	// can use the view method AddKeyCommand instead of AddKeyCommands.       	       	// This method is called conditonally so that this sample will work on        	// Newton 2.0 OS as well.       	:?AddKeyCommands( keyCommandArray );       end,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	// Remove all the key commands registered with ViewB.  If you       	// don't remove the registered key commands, they will waste NewtonScript       	// heap space.       	// Key commands are also cleaned up when a view is closed and disposed of,       	// so calling ClearKeyCommands is not necessary in this view.  Its a good       	// idea to call it anyway.       	       	// Again, this method is called conditionally so that this sample       	// will work on Newton 2.0 OS.       	:?ClearKeyCommands();       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     keyCommandArray:       [       	{       		char:		$h,       		modifiers:	kCommandModifier,       		keyMessage:	'DoHKeyCommand,       		name:		"Do H Key",       		category:	"Keyboardin",       	},       	{       		char:		$j,       		modifiers:	kCommandModifier,       		keyMessage:	'DoJKeyCommand,       		name:		"Do J Key",       		category:	"Keyboardin",       	},       	{       		char:		$k,       		modifiers:	kCommandModifier,       		keyMessage:	'DoKKeyCommand,       		name:		"Do K Key",       		category:	"Keyboardin",       	},       ],     ViewKeyDownScript:       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyDownScript in View B", [key, flags] );       	       	nil;       end,     ViewKeyRepeatScript:       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyRepeatScript in View B", [key, flags] );       	       	nil;       end,     ViewKeyStringScript:       func( string )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyStringScript in View B", string );              	nil;       end,     ViewKeyUpScript:       func( key, flags )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewKeyUpScript in View B", [key, flags] );       	       	nil;       end,     ViewCaretActivateScript:       func( active )       begin       	// DisplayPrint is a method of the base view       	:DisplayPrint( "In ViewCaretActivateScript in View B", active );       	       	nil;       end,     textFlags: nil,     viewJustify: 469762208,     DoHKeyCommand:       func( keyView )       begin       	:DisplayPrint( "In DoHKeyCommand", keyView );       end,     DoJKeyCommand:       func( keyView )       begin       	:DisplayPrint( "In DoJKeyCommand", keyView );       end,     DoKKeyCommand:       func( keyView )       begin       	:DisplayPrint( "In DoKKeyCommand", keyView );       end,     viewClass: 81 /* clParagraphView */    };AddStepForm(baseView, ViewB);StepDeclare(baseView, ViewB, 'ViewB);baseView_v218_0 :=    {text: "View B",     viewBounds: {left: 0, top: -19, right: 104, bottom: -5},     viewJustify: 8407040,     _proto: @218 /* protoStaticText */    };AddStepForm(baseView, baseView_v218_0);baseView_v164_0 :=    {text: "Use vSingleKeystrokes Flag",     viewBounds: {left: 0, top: -19, right: 150, bottom: -5},     valueChanged:       func()       begin       	if viewValue then       		SetValue( viewB, 'textFlags, vSingleKeystrokes );       	else       		SetValue( viewB, 'textFlags, nil );       end,     viewValue: nil,     viewJustify: 8407040,     _proto: @164 /* protoCheckBox */    };AddStepForm(baseView, baseView_v164_0);baseView_v163_0 := {_proto: @163 /* protoLargeClosebox */};AddStepForm(baseView, baseView_v163_0);baseView_v386_0 :=    {text: "Open Async Confirm",     viewBounds: {left: 0, top: 18, right: 116, bottom: 46},     popup:       [       	{item: "okCancel", symbol: 'okCancel},       	{item: "okCancelDefaultOK", symbol: 'okCancelDefaultOK},       	{item: "okCancelDefaultCancel", symbol: 'okCancelDefaultCancel},       	{item: "yesNo", symbol: 'yesNo},       	{item: "yesNoDefaultYes", symbol: 'yesNoDefaultYes},       	{item: "yesNoDefaultNo", symbol: 'yesNoDefaultNo},	       ],     viewFlags: 515,     pickActionScript:       func(itemSelected)       begin       	AsyncConfirm(       		"Can you see the difference?",       		popup[itemSelected].symbol,       		func(button) :DisplayPrint( "AsyncConfirm callback", button ) );              	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     viewJustify: 8388630,     _proto: @386 /* protoPopupButton */    };AddStepForm(baseView, baseView_v386_0);myPicker :=    {     labelCommands:       [       	"Regular Item",       	{keyMessage: 'DoBKeyCommand},       	{keyMessage: 'DoGKeyCommand},       ],     text: "Label",     viewBounds: {left: 0, top: 59, right: 150, bottom: 73},     viewJustify: 8388624,     labelActionScript:       func(cmd)       begin       	:DisplayPrint( "In labelActionScript", cmd );       end,     alwaysCallPickActionScript:       // This slot must be set to true in order for this proto to work correctly.       // Refer to the keyboard documentation for more information about how to       // use this slot.       true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(baseView, myPicker);StepDeclare(baseView, myPicker, 'myPicker);constant |layout_Keyboardin.t| := baseView;// End of file Keyboardin.t
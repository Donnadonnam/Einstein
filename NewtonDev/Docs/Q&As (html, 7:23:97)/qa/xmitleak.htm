<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Why Xmit Functions Seem to Leak Memory</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Why Xmit Functions Seem to Leak Memory</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B>CHANGED: </B>Why Xmit Functions Seem to Leak Memory  (5/5/97)</H3><DL><DD>Q:    I've noticed that the system seems to leak a little bit of memory every time I call an Xmit soup function, but not if I call the non-xmitting versions of the functions.  For example, executing this code shows a little less free memory each time <CODE>Stats()</CODE> is called:<BR><CODE><PRE>    gc(); stats();    soup:AddToDefaultStoreXmit({ foo : "a test string"}, '|bar:SIG|);    gc(); stats();    soup:AddToDefaultStoreXmit({ foo : "another test string"}, '|bar:SIG|);    gc(); stats();</PRE><BR></CODE><BR><BR>A:    There is no leak.  What's actually going on is that the Xmit versions of the soup methods do their broadcasting in deferred actions.  That's good, because it means that broadcast handlers that might throw or have other side effects won't break your code.  A little bit of heap memory is used to keep track of the deferred action and its arguments.  This memory is released after the deferred action executes, which is typically immediately after control returns to the top level.<BR><BR>    If you select all the test code in the NTK Inspector and press the Enter key, NTK compiles the entire selection and executes it as a single operations, so control doesn't return to the top level (thus allowing the deferred actions to execute) until after the last operation.  The deferred action created by each call to the Xmitting function will still be pending, so the space won't have been released yet, and stats reflect this.  If the example is executed one line at a time, you'll see that no memory is actually leaked.<BR><BR>    If you pass <CODE>nil</CODE> for the <CODE>changeSym</CODE> argument to the Xmit functions, no notification occurs and the deferred action is not created. Normally, this is a bad idea, since you want other applications to know about your soup changes. However, Xmit notification may not be necessary for specialized applications that use only their own application soups and do not publish information about reading/writing soup data for extensibility. <BR><BR>    If you are modifying a very large number of entries (for instance, creating a new soup of thousands of entries), you might pass <CODE>nil</CODE> for the <CODE>changeSym</CODE> to void immediate notification. Afterwards, use the <CODE>XmitSoupChange</CODE> global function with the <CODE>'whatThe</CODE> symbol. (See the documentation for <CODE>XmitSoupChange</CODE> for more information.)</DL>
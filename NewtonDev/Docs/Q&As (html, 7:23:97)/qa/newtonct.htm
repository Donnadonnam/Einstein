<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Newton C++ Tools</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Newton C++ Tools</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="newtonct.htm">Newton C++ Tools</H2></A><UL><A HREF="#Packed_Structures_in_C++_Tools"><B> </B>Packed Structures in C++ Tools  (2/28/97)<BR></A></UL><A NAME="Packed_Structures_in_C++_Tools"><H3><HR><B> </B>Packed Structures in C++ Tools  (2/28/97)</A></H3><DL><DD>Q:    Do the Newton C++ Tools support a concept of packed structures?  Some compilers provide a keyword (<CODE>packed</CODE>) to prevent aligning of the fields by the compiler.  I tried to use the keyword and got an error.  How can I ensure that a structure is packed?<BR><BR>A:    While there is no supported way to do this in the current tools, the ARM compiler does have an experimental directive, <CODE>__packed</CODE>, which is probably worth a try.  Using this directive may cause the compiler to stop with an internal error in some circumstances, so be prepared.  You should ensure that the structure produced has the correct alignment by using the C <CODE>sizeof</CODE> and <CODE>offsetof</CODE> functions, since this directive does introduce a compiler dependency.  Accessing elements in <CODE>__packed</CODE> structures can be considerably less efficient than using non-packed structures: use them only when necessary.  For example:<BR><CODE><PRE>    __packed struct T { char c; int i; };</PRE><BR></CODE>    produces a structure that is 5 bytes wide.  Without the <CODE>__packed</CODE> directive, it would be 8 bytes wide and the integer field would begin 4 bytes from the structure start, so that it was word aligned.<BR><CODE>    </CODE><BR>    We believe the internal error in the compiler can be avoided by taking the sizeof the structure before using it.  An easy way to do this is to add a dummy function right after the structure is declared.  For example:<BR><CODE>        inline void dummyT() { (void)sizeof(T); }</CODE><BR><BR>    Primitive types can also be declared <CODE>__packed</CODE>, which means that the compiler will not make assumptions about the alignment of pointers to them.  That is, if you know an int starts two bytes into a word-aligned data structure, the wrong thing will happen if you simply cast the pointer to <CODE>int</CODE>.  Instead, you can used an <CODE>unaligned int</CODE> type.  This generates considerably less efficient code than is needed for working with aligned values, but it's still more efficient that trying to extract the proper bytes and shift/add them into an integer youself.  For example:<BR><CODE><PRE>    typedef __packed int UNALIGNED_INT;    int IntAt(UNALIGNED_INT* p) { return *p; }</PRE><BR></CODE><BR>    This directive does not work properly with bitfield specifiers.  For example:<BR>        <CODE><PRE>        __packed struct Foo {        unsigned flag1 : 1;        unsigned flag2 : 1;        unsigned data1 : 6;        unsigned short data2;</PRE><BR>        }</CODE><BR>    will not produce what you expect.  Instead, avoid the bitfield specifiers and take advantage of C++ inline functions to access the partial bytes:<BR>        <CODE><PRE>        __packed struct Foo {        char stuff;        unsigned short data2;        int Flag1() { return (stuff & 0x80) != 0; }        int Flag2() { return (stuff & 0x40) != 0; }        int Data1() { return stuff & 0x3F; }        int Data2() { return data2; }    };    inline void dummyFoo() { (void)sizeof(Foo); }</PRE><BR></CODE><BR>    The result is a 3-byte wide data structure with the bitfields easily accessible.<BR><CODE><BR></CODE>    Note that the ProtocolGen tool (part of the DDKs) does not understand the <CODE>__packed</CODE> directive.  ProtocolGen does not make use of structure sizes, so it's OK to NOP out the <CODE>__packed</CODE> keyword for that tool.   Here's an easy way to do that:<BR><CODE><PRE>    #ifdef PROTOCOLGEN    #define __packed</PRE><BR>        #endif</CODE><BR></DL>
/***      Newton Developer Technical Support Sample Code** **      StdAppSize, a hack for normal applications on multiple screens****      by Bob Ebert, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/ // "Standard" function for opening an application's base view to properly show up// on different screen sizes and different orientations.  Call this function from// your base view's viewSetupFormScript before calling the inherited:?viewSetupFormScript// If you use this function, you do not need to provide a viewJustify or viewBounds slot// for your base view.  The function creates one.// WARNING:  There is a pathological case to watch out for.  If the minWidth or minHeigh// happen to exactly match the current screen width or height, and the max height or// width (the opposite one) is less than the current screen height or width, the message// "screen to short/narrow" will appear.  Because you view isn't full screen in one dimension,// the border is required.  Because the border takes away from the useable dimension in the// other direction, the resulting view is too small to open.  If you absolutely require a view// that has borders on only 2 of the 4 sides for some screen size, this can be done, but// it's beyond the scope of this function--write your own viewSetupFormScript!!// Set one of these to TRUE to quickly test your app at minimum or maximum size.// (For max size, you may have to rely on "DV" to check the sizes of subviews,// because they can be off-screen.)  There will be no borders when you are running// your app this way.constant kTestMinAppSize := nil;constant kTestMaxAppSize := nil;DefineGlobalConstant('kStdAppSizeFunc, func(baseView, appName, minWidth, minHeight, maxWidth, maxHeight)	begin		// start by being as big as possible, will shrink later		baseView.viewJustify := vjParentCenterH + vjParentCenterV;		if kTestMinAppSize then			baseView.viewBounds := SetBounds(0,0,minWidth, minHeight);		else if kTestMaxAppSize then			baseView.viewBounds := SetBounds(0,0,maxWidth, maxHeight);		else			baseView.viewBounds := SetBounds(0,0,							GetAppParams().appAreaWidth,							GetAppParams().appAreaHeight);				// shrink if needed for max width/height		local bordersize := BAND(baseView.viewformat, vfPenMask)>>vfPenShift							+BAND(baseView.viewformat, vfInsetMask)>>vfInsetShift;		local fullScreenWidth := baseView.viewBounds.right-2*borderSize;		local fullScreenHeight := baseView.viewBounds.bottom-2*borderSize;		if fullScreenWidth > maxWidth or fullScreenHeight > maxHeight then			begin				// not full screen, so inset remainder and room for border				baseView.viewBounds.right := Min(fullScreenWidth, maxWidth);				baseView.viewBounds.bottom := Min(fullScreenHeight, maxHeight);			end;		else			begin	         // really are full screen, so no border, no clickable (assumes dragger)				baseView.viewFormat := vfNone;				baseView.viewFlags := BAND(baseView.viewFlags, BNOT(vClickable));			end;			// check for screen to small		local message;		if baseView.viewBounds.right < minWidth then			message := "The display is to narrow for " & appName & " to open"		else if baseView.viewBounds.bottom < minHeight then			message := "The display is to short for " & appName & " to open";		if message then			begin				baseView.viewBounds := RelBounds(-999, -999, 0, 0);	// removed in viewQuitScript				GetRoot():Notify(kNotifyAlert, kAppName, message);				AddDelayedCall(func(v)					begin						RemoveSlot(v, 'viewbounds);						v:Close();					end,					[baseview], 1);			end;	end);
// Text of project ListPickerPopUp written on 11/21/95 at 6:08 PM// Beginning of text file ProjectData/***      Newton Developer Technical Support Sample Code****      ListPicker,  Demostratest the protoListPicker that uses and array with a popUp****      by Stephen Harris, Newton Developer Technical Support****      Copyright © 1993-1995 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/// This sample demonstrates the use of a listPicker with a column that does a // popUp action.  The data for the listpicker is in an array that exist in the// application.// App stuffconstant kAppTitle := "The ListPicker";// Define a basic entry frame for dataDefConst('kCanonicalEntry,  '{		first: nil,		second: nil,	});// Generate the Random data for the PickerDefConst('kRandomDataGeneratorFunc, func()	begin		local item := clone(kCanonicalEntry);		item.first := Capitalize(GetRandomWord(4, 12));		item.second := Capitalize(GetRandomWord(4, 12));		item;	end);// set up some items to displayed in the popUp for the second column of the // picker.DefConst('kListStringArray, 		[			 "Wyld",			 "Jim",			 "Weasel",			 "Jeff",			 'pickSeparator,			 "Willis",		]);		// End of text file ProjectData// Beginning of text file pickerDef.f// Copyright © 1993-1995 by Apple Computer, Inc.  All rights reserved.// listPicker defs// used to define the pickerDef at compile time.  May include all of the slots for the pickerDef.// In the listPicker.pickerDef proto to this DataDef.  DefConst('kMyBasicDataDef,{	_proto: protoNameRefDataDef,		// Required	validationFrame: nil,				// must override since no editing supported	name:  "My Data Picker",			// name at top left of picker if folderTabs present	// method that is called for columns that can have a popup 	MakePopup: func(nameRef, fieldPath)	begin		if fieldPath = 'second then							// only pop if second column		begin			local Listlen := length(kListStringArray);			local pop := array(ListLen, nil);			for i := 0 to ListLen - 1 do				pop[i]:= clone(kListStringArray[i]);			pop;		end;	end,	// default PopVal method assumes that the popup is an array of frames	// specialize the method for a picked item that is just a string		PopVal: func(item)	begin		if ClassOf(item) = 'frame then			inherited:PopVal(item) ;		else			item;	end,				});						//************// End of text file pickerDef.f// Beginning of file ListPickerPopUp.t// Before Script for "appBase"// Copyright © 1993-1995 by Apple Computer, Inc.  All rights reserved.// this code will be executed before the template is processedappBase :=    {viewBounds: {left: 0, top: 0, right: 220, bottom: 301},     viewFlags: 1,     declareSelf: 'base,     viewJustify: 0,     viewQuitScript:       func()       begin       	// memory reclamation project       	myListPicker.selected := nil;       	reOrienting:= nil;       end,     viewSetupFormScript:       func()       begin       	//set up app display       	local b := GetAppParams();       	self.viewBounds := RelBounds(b.appAreaLeft, b.appAreaTop,       		b.appAreaWidth, b.appAreaHeight);       	       	//populate myListPicker       	if NOT reOrienting then       		:generateData();       end,     GenerateData:       func()       begin       	// Create entries for the listPicker selected array.        	// the key function to use is makeNameRef(object, makeObjectthisClass)       	// which returns an object for the selectedArray.       	// Note: the object needs to be a subclass of nameRef or of class nameRef       	//       If no class is specified, the object will be of class nameRef              	// Note: You could pass the class as the second arguement to makeNameRef       	//		   instead of using a class slot in the pickerDef       	       	local theListPicker := myListPicker;       	theListPicker.selected := Array(20,nil);              	for i := 0 to 19 do       	begin       		local item := theListPicker.pickerDef:MakeNameRef(       				call kRandomDataGeneratorFunc with (), nil);       		       		// set the state to not selected       		item._unselected := true;       		       		theListPicker.selected[i] := item;       	end;              	// select the first item in the listPicker.       	//*** Note that if singleSelect is set to true       	// you must make sure that you select only one item              	theListPicker.selected[0]._unselected := nil;              end,     title: kAppTitle,     ReorientToScreen:       func()       begin       	reOrienting:= true;				//set to not rebuild the selected array during rotation       	:syncView();       	       	// stop the selected array from being purged of       	// non-selected items when it closes       	myListPicker.dontPurge:= true;              	:RedoChildren();              	// reset the purge slot so that listPicker       	// will purge when it closes normally       	myListPicker.dontPurge:= nil;              	reOrienting:= nil;				//the rotation is completed       end,     reOrienting: nil,     debug: "appBase",     viewClass: 74    };_view000 :=    {viewBounds: {left: 5, top: 0, right: 169, bottom: 20}, _proto: @229};AddStepForm(appBase, _view000);mylistpicker :=    {viewFlags: 513,     viewBounds: {left: 0, top: 20, right: 0, bottom: -45},     viewJustify: 240,     pickerDef:       {       	_proto: kmyBasicDataDef,	// defined in the pickerDef.f file       	class:  'nameRef,      		// always include        	columns:       	[	// Column 1       		{       			fieldPath: 'first,	// field to display in column       			tapWidth: 100,			// width for checkbox & name combined, offset from the right margin		       			doRowHilite: true,       		},       		       		// Column 2       		{       			fieldPath: 'second,	// field to display in column       			tapWidth: 0, 			// width from preceeding column to right bounds              			// do not hilite this row since it is a popup list       			doRowHilite: nil,	       		},       	],       },     selected: nil,     suppressNew: true,     suppressCloseBox: true,     suppressFolderTabs: true,     dontpurge:       // determines if listPicker will purge the selected array when closed       nil,     debug: "mylistpicker",     _proto: @461    };AddStepForm(appBase, mylistpicker);StepDeclare(appBase, mylistpicker, 'mylistpicker);_view001 :=    {     buttonClickScript:       func()       begin       	whatSelected:open();       end,     text: "What is selected",     viewBounds: {left: 0, top: 6, right: 110, bottom: 24},     viewJustify: 8396950     ,     _proto: @226    };AddStepForm(appBase, _view001);_view002 := {_proto: @219};AddStepForm(appBase, _view002);whatSelected :=    {viewBounds: {left: 0, top: 72, right: 100, bottom: 188},     debug: "whatSelected",     _proto: @180    };AddStepForm(appBase, whatSelected);StepDeclare(appBase, whatSelected, 'whatSelected);_view003 :=    {     buttonClickScript:       func(textIndex)       begin       	print("selected index " & textIndex);       end,     viewBounds: {left: 0, top: 0, right: 0, bottom: 116},     viewFont: ROM_fontSystem9,     viewLines: 6,     viewSetupFormScript:       func()       begin       	// call the getSelected fucntion with true to return only the items       	// that are currently selected'       	// NOTE: as items are selected nameRef's are created and put in the selected array.        	// GetSelected returns an array of the selected items and removes all other nameRef's              	local myArray := [];       	foreach item in myListPicker:getSelected(true) do       		AddArraySlot(myArray,(item.first && item.second));                     	self.listItems := myArray;       	:SetupList();       end,     listItems: nil,     viewJustify: 48,     viewFormat: 1,     useScrollers: true,     _proto: @228    };AddStepForm(whatSelected, _view003);constant |layout_ListPickerPopUp.t| := appBase;// End of file ListPickerPopUp.t
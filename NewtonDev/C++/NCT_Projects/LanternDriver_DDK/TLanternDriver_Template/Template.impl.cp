/*	File:		Template.impl.cp	Contains:	Lantern driver for the Template Wireless Card				You may incorporate this sample code into your applications without				restriction.  This sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  You are not				permitted to modify and redistribute the source as "DDK Sample Code."				If you are going to re-distribute the source, we require that you				make it clear in the source that the code was descended from				Apple-provided sample code, but that you've made changes.					Copyright:	й 1997 by Apple Computer, Inc., all rights reserved.	Obtained from NIE2.0 F1C2 build. 9/4/97*/#ifndef	__TEMPLATE_IMPL_H#include "Template.impl.h"#endif#ifndef	__LANTERNEVENTS_H#include "LanternEvents.h"#endif#ifndef	__DELAYTIMER_H#include "DelayTimer.h"#endif#ifndef	__REGISTERRDWR_H#include "RegisterRdWr.h"#endif#ifndef __TEMPLATEEVENT_H#include "TemplateEvents.h"#endif#ifndef __TEMPLATEERRORS_H#include "TemplateErrors.h"#endif////	***** Compiler flags *****//////	***** Definitions *****//////	Constants//#define kTemplateTimerEvent	'tmpl','timr',0	// Timer evevt ////	Event tracing definitions////		NOTE: Event trace records real time events for the debugger.//			  This feature depends on which debugger is used and may not be available to developers//enum kTemplateEventTraceCodes											// Event trace codes{	kTemplateEventInit = 1,	kTemplateEventEnable,	kTemplateEventDisable,	kTemplateEventTimerExpired,	kTemplateEventInterruptHandler,	kTemplateEventSendBuffer,	kTemplateEventSendCBufferList,	kTemplateEventGetDeviceAddress,	kTemplateEventAddMulticastAddress,	kTemplateEventDelMulticastAddress,	kTemplateEventGetLinkIntegrity,			kTemplateEventSetPromiscuous,		kTemplateEventGetThroughput,		kTemplateEventDescSize};// Macros for generate event trace code. It checks run time #ifdef kDB__pHISTORYCOLLECT	#define ADD_TRACE_EVENT(id, byte, short)		TRACE_MESSAGE(fEventTraceCollector, id, byte, short);	#define ADD_TRACE_ADDR()						TRACE_FUNCTION(fEventTraceCollector);#else	#define ADD_TRACE_EVENT(id, byte, short)	#define ADD_TRACE_ADDR()#endif////	***** Protocol class routines *****//PROTOCOL_IMPL_SOURCE_MACRO(TTemplateDriver)	// Magic stuff, do not touch.											// (For protocol class)////	TLanternDriver* TTemplateDriver::New()////		Protocol class constructor////			Allocate and set up local varibles here.////			This is called when the card is inserted. The variables fCardSocket, fCardPCMCIA and //			fDriverAPI are NOT set up right now. They are only available later in Init().////			If there is a embeded class in the protocol class, the constructor of the class //			is not executed when the protocol class is initialized. This is the limitation of //			the protocol class. It need be initialized here in the NEW(). For example://			//				PROTOCOL TTemplateDriver : ...//				{//					...//					TFoo	fFoo;			// A embeded class//					...//				}////				TTemplateDriver::New()//				{//					...//					new (&fFoo) TFoo;		// Execute the constructor//					...//				}//TLanternDriver* TTemplateDriver::New(){	fTickTime = new TTime;	  #ifdef kDB__pHISTORYCOLLECT	// Set up event trace collector begin	BEGIN_TRACE_DECLARATIONS(		ClassInfo()->ImplementationName(), 		512, 		(kTemplateEventDescSize - 1),		fEventTraceCollector, 		fEventTraceCauseDescs	);	// Set up event trace code and display string mapping	DEFINE_TRACE_ENTRY(kTemplateEventInit,					"Init               ");	DEFINE_TRACE_ENTRY(kTemplateEventEnable,				"Enable             ");	DEFINE_TRACE_ENTRY(kTemplateEventDisable,				"Disable            ");	DEFINE_TRACE_ENTRY(kTemplateEventTimerExpired,			"TimerExpired       ");	DEFINE_TRACE_ENTRY(kTemplateEventInterruptHandler,		"InterruptHandler   ");	DEFINE_TRACE_ENTRY(kTemplateEventSendBuffer,			"SendBuffer         ");	DEFINE_TRACE_ENTRY(kTemplateEventSendCBufferList,		"SendCBufferList    ");	DEFINE_TRACE_ENTRY(kTemplateEventGetDeviceAddress,		"GetDeviceAddress   ");	DEFINE_TRACE_ENTRY(kTemplateEventAddMulticastAddress,	"AddMulticastAddress");	DEFINE_TRACE_ENTRY(kTemplateEventDelMulticastAddress,	"DelMulticastAddress");	DEFINE_TRACE_ENTRY(kTemplateEventGetLinkIntegrity,		"GetLinkIntegrity   ");	DEFINE_TRACE_ENTRY(kTemplateEventGetThroughput,			"GetThroughput      ");	DEFINE_TRACE_ENTRY(kTemplateEventSetPromiscuous,		"SetPromiscous      ");	END_TRACE_DECLARATIONS(0);  #endif	return this;													// Always return this}////	TTemplateDriver::Delete()////		Protocol class destructor////			Clean up and free all momory allocations//			This is called when the card is removed.//void TTemplateDriver::Delete(){	delete fTickTime;	fTickTime = nil;  #ifdef kDB__pHISTORYCOLLECT	TRACE_RELEASE(fEventTraceCollector, fEventTraceCauseDescs);		// Remove enent trace stuff  #endif}////	***** Lantern task service routines *****//////	NewtonErr TTemplateDriver::Init()////		Driver initialization////			This is called when the card has been inserted in the system.//			It should intialize the driver and set up the card here.//NewtonErr TTemplateDriver::Init(){	ADD_TRACE_EVENT(kTemplateEventInit, 0, 0);	NewtonErr err = noErr;	//еее Add your code here (to check if the card is working correctly)		//	Add Lantern request functions	fDriverAPI->AddEventHandler(kLanternSendBuffer, (DriverProcPtr) &TTemplateDriver::SendBuffer);	fDriverAPI->AddEventHandler(kLanternSendCBufferList, (DriverProcPtr) &TTemplateDriver::SendCBufferList);	fDriverAPI->AddEventHandler(kLanternGetDeviceAddress, (DriverProcPtr) &TTemplateDriver::GetDeviceAddress);	fDriverAPI->AddEventHandler(kLanternAddMulticastAddress, (DriverProcPtr) &TTemplateDriver::AddMulticastAddress);	fDriverAPI->AddEventHandler(kLanternDelMulticastAddress, (DriverProcPtr) &TTemplateDriver::DelMulticastAddress);	fDriverAPI->AddEventHandler(kLanternGetLinkIntegrity, (DriverProcPtr) &TTemplateDriver::GetLinkIntegrity);		// Add Optional handlers	fDriverAPI->AddEventHandler(kLanternSetPromiscuous, (DriverProcPtr) &TTemplateDriver::SetPromiscuous);	fDriverAPI->AddEventHandler(kLanternGetThroughput, (DriverProcPtr) &TTemplateDriver::GetThroughput);		// Add private timer services handler	fDriverAPI->AddEventHandler(kTemplateTimerEvent, (DriverProcPtr) &TTemplateDriver::TimerExpired);	fTimerPosted = false;exit:		ADD_TRACE_EVENT(kTemplateEventInit, 9, err);	return err;}////	NewtonErr TTemplateDriver::Enable()////		Enable: set up card and start Rx////			This method is called whenever the services of the card are required by clients.//			It is called once when the first client requires services. Subsequent clients//			do not cause this call to be repeated. Clients of an Ethernet card can be AppleTalk,//			TCP/IP or a protoLanternClient from NewtonScript.////			*** NOTE ***////				It is imperative that you do not access the card memory unless//				the driver is enabled.  If you access card memory at any other//				time the Lantern subsystem may be halted.//NewtonErr TTemplateDriver::Enable(){	ADD_TRACE_EVENT(kTemplateEventEnable, 0, 0);	NewtonErr err = noErr;	Boolean powerOn;	// Turn on card power	fDriverAPI->PowerOn(&powerOn);									// Turn on card power	fStatus |= kStatusCardPowerOn;									// Remember it for destructor to power off	//еее Add your code here	if (!fTimerPosted)	{		// This posts the event to our own task so we get the event		fTimerPosted = true;		*fTickTime = GetGlobalTime() + TTime(kTimerTime, kMilliseconds);		fDriverAPI->PostLocalEvent(fTickTime, kTemplateTimerEvent);	}	exit:		ADD_TRACE_EVENT(kTemplateEventEnable, 9, err);	return err;}////	NewtonErr TTemplateDriver::Disable()////		Disable: stop Rx and Tx operations////			This method is called when there no more clients that require the services of the card,//			or it has been determined that the card is no longer available in the system.//NewtonErr TTemplateDriver::Disable(){	ADD_TRACE_EVENT(kTemplateEventDisable, 0, 0);	NewtonErr err = noErr;	fDriverAPI->PowerOff();											// Turn off card power and remember it	fStatus &= ~kStatusCardPowerOn;	//еее Add your code here		exit:	ADD_TRACE_EVENT(kTemplateEventDisable, 9, err);	return err;}////	ULong TTemplateDriver::TimerExpired()////		This is a general purpose timer routine.  You may implement as many different timers//		as needed for your particular implementation by adding different events and eventhandlers//		for each timer.////		The three parts to defining this as a timer is to////			1. Add an eventhandler to handle your specifically defined event//			2. Call PostLocalEvent with a delay for the time to send the event//			3. Implement the timer event handler method.////		This timer periodically checks the link integrity (although for this chipset it cannot//		be detected so it just returns true).////			You can send this event out to clients that the link status has changed. //			This is not a necessary event but should be implemented if the link integrity //			can be detected by interrupt (or by timed event polling). If you detect //			the link is bad (packet errors say) you may send this event but should keep //			accepting further requests.////void TTemplateDriver::TimerExpired(void){	if (fStatus & kStatusCardPowerOn)	{		//еее Add your code here		// Should grab the link Integrity and post it here		// Boolean linkIntegrity = GetLinkIntegrity();		// if (linkIntegrity != fLinkIntegrity)		//	fDriverAPI->PostEvent(kLanternLinkIntegrity, (ULong) (fLinkIntegrity = linkIntegrity));				// This posts the event to our own task so we get the event		fTimerPosted = true;		*fTickTime = *fTickTime + TTime(kTimerTime, kMilliseconds);		fDriverAPI->PostLocalEvent(fTickTime, kTemplateTimerEvent);	}	else	{		// else timer services are cancelled.		fTimerPosted = false;	}}////	NewtonErr TTemplateDriver::InterruptHandler()////		Interrupt handler (called from task level, not in interrupt level)////			This method is called after an interrupt line on the card is asserted.//			This method is dispatched as a priority event from the system interrupt handler//			and as such is not 'true' interrupt code, consequently it does not have to execute as //			time critical or out-of-state code. However, as a priority event, it is dispatched//			before any other pending RPCs waiting on the driver. The current minimum time between//			a card interrupt and this method executing is apTemplateately 50 mSecs but could be longer//			depending on OS loading.////			There is a fundamental assumption that a Lantern device is capable of buffering inbound //			data for at least as long as required for the interrupt event to be dispatched. For high //			bit rate cards (wired Ethernet) on a busy network (e.g. large AppleTalk nets) this may//			cause loss of packets. As a data link layer, lost packets are allowable, however some//			protocols, especially AppleTalk on the Newton, may be fragile to loosing certain packets.//void TTemplateDriver::InterruptHandler(){	NewtonErr err = noErr;	ADD_TRACE_EVENT(kTemplateEventInterruptHandler, 0, 0);	//еее Add your code here		fDriverAPI->InterruptDone();									// This call is optional (here it's not really needed)		ADD_TRACE_EVENT(kTemplateEventInterruptHandler, 9, err);}////	***** Lantern client service routines *****//////	void	  TTemplateDriver::SendBuffer(Ptr thePacket, Size packetSize)//	void	  TTemplateDriver::SendCBufferList(CBufferList* thePacket)////		Send a packet in the buffer ptr or the CBufferList////			These events is sent to a driver when Lantern needs data to be sent. The//			driver should send data asynchronously. The driver should buffer data //			to be sent as it may receive more data to send.//void TTemplateDriver::SendBuffer(Ptr thePacket, Size packetSize){	ADD_TRACE_EVENT(kTemplateEventSendBuffer, 0, 0);	NewtonErr err = noErr;	//еее Add your code here	fDriverAPI->PostReply(err);		ADD_TRACE_EVENT(kTemplateEventSendBuffer, 9, err);}void TTemplateDriver::SendCBufferList(CBufferList* thePacket){	ADD_TRACE_EVENT(kTemplateEventSendCBufferList, 0, 0);	NewtonErr err = noErr;	//еее Add your code here	fDriverAPI->PostReply(err);	ADD_TRACE_EVENT(kTemplateEventSendCBufferList, 9, err);}////	void TTemplateDriver::GetDeviceAddress()////		Return the 6-byte device Ethernet hardware address//void TTemplateDriver::GetDeviceAddress(UByte* addr, Size size){	ADD_TRACE_EVENT(kTemplateEventGetDeviceAddress, 0, 0);	NewtonErr err = noErr;		//еее Change the following as needed		if (size <= sizeof(fEthernetAddr)) {		memcpy((char*)addr, (char*)fEthernetAddr,size);	}	else {		err = eLANTERN_DriverValueRangeError;	}		fDriverAPI->PostReply(err);	ADD_TRACE_EVENT(kTemplateEventGetDeviceAddress, 9, err);}////	void TTemplateDriver::AddMulticastAddress(UChar* addr)////		Add a multicast address//void TTemplateDriver::AddMulticastAddress(UChar* addr){	ADD_TRACE_EVENT(kTemplateEventAddMulticastAddress, 0, 0);	NewtonErr err = noErr;		//еее Add your code here	fDriverAPI->PostReply(err);										// Reply	ADD_TRACE_EVENT(kTemplateEventAddMulticastAddress, 9, err);}////	void TTemplateDriver::DelMulticastAddress(UChar* addr)////		Delete a multicast address//void TTemplateDriver::DelMulticastAddress(UChar* addr){	ADD_TRACE_EVENT(kTemplateEventDelMulticastAddress, 0, 0);	NewtonErr err = noErr;		//еее Add your code here	fDriverAPI->PostReply(err);										// Reply	ADD_TRACE_EVENT(kTemplateEventDelMulticastAddress, 9, err);}////	void TTemplateDriver::GetLinkIntegrity()////		Get the link integrity flag//void TTemplateDriver::GetLinkIntegrity(){	NewtonErr err = noErr;	ADD_TRACE_EVENT(kTemplateEventGetLinkIntegrity, 0, 0);	ULong linkIntegrity = true;	//еее Add your code here	// linkIntegrity = GetLinkIntegrity();						// Get link status	fDriverAPI->PostReply(err, 1, linkIntegrity);				// Reply	ADD_TRACE_EVENT(kTemplateEventGetLinkIntegrity, 9, (ULong) linkIntegrity);}void TTemplateDriver::SetPromiscuous(ULong promiscuous){	NewtonErr err = noErr;	ADD_TRACE_EVENT(kTemplateEventSetPromiscuous, 0, 0);	//еее Change the following if supported	err = eLANTERN_DriverUnhandledEvent;	fDriverAPI->PostReply(err);				// Reply	ADD_TRACE_EVENT(kTemplateEventSetPromiscuous, 9, err);}void TTemplateDriver::GetThroughput(void){	NewtonErr err = noErr;	ADD_TRACE_EVENT(kTemplateEventGetThroughput, 0, 0);	//еее Change the following if supported	err = eLANTERN_DriverUnhandledEvent;	fDriverAPI->PostReply(err);				// Reply	ADD_TRACE_EVENT(kTemplateEventGetThroughput, 9, err);}////	***** Card routines *****//#ifdef forDebug////	void TTemplateDriver::DumpBuffer(UChar* buffer, ULong size, ULong startingAddr)////		Dump buffer data//void TTemplateDriver::DumpBuffer(UChar* buffer, ULong size, ULong startingAddr){	for (ULong i = 0; i < ((size+15) / 16); i++)	{		if ((i & 7) == 0)			printf("\n");		printf("%04X.%04X:", startingAddr + i*16, i*16);		for (ULong j = 0; j < 16; j++)		{			if ((j&3) == 0) printf(" ");			printf("%02X ", buffer[j]);			if (j == 7) printf("-");		}		printf("  ");		for (j = 0; j < 16; j++)		{			if ((j&7) == 0) printf(" ");			char ch = buffer[j];			if ((ch < ' ') || (127 < ch))				ch = '.';			printf("%c", ch);		}		printf("\n");		buffer += 16;	}	printf("\n");}#endif
// Text of project Tool Time written on 9/25/97 at 11:30 AMDefConst('|streamFile_Tool Time Stream File.stream|, ReadStreamFile("Tool Time Stream File.stream"));|streamFile_Tool Time Stream File.stream|:?install();// Beginning of text file Project Constants/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*//********************************************************************//*				Generic Application Constants						*//********************************************************************/ constant kVersionString 						:= "1.1d5 ©1996-97";constant kPageHeight 							:= 65534;constant kHeaderViewFont						:= 1058816;constant kCircleDiameter						:= 6;constant kAboutString 							:= kVersionString && "\nBy Ryan Robertson, DTS Comms Geek";constant kConnectFloaterTitleString			:= "^0 Connect Options";constant kInfoFloaterTitleString				:= "^0 Information";constant kExtraFloaterTitleString			:= "^0 Extras";constant kToolPrefsFloaterTitleString		:= "^0 Preferences";constant kLinkEndpointsTitleString			:= "Link Endpoints";constant kEndpointConnectedLogString 		:= "^0 connected";constant kEndpointDisconnectedLogString	:= "^0 disconnected";/********************************************************************//*								Test Mode View Constants  		 				  *//********************************************************************/constant kDataTypeString				:= "Data Type";constant kSendDataFloaterTitle		:= "Send Data Options";constant kSendDataButtonString		:= "Send Data";constant kReceiveDataFloaterTitle	:= "Receive Data Options";constant kReceiveDataButtonString	:= "Set Specification";constant kErrorValidatingSpecString	:= "Sorry, there was an error validating the input specification.";/********************************************************************//*								Preference View Constants  					  *//********************************************************************/constant kModulePrefsSlotSymbol	:= 'modulePrefs;DefineGlobalConstant( 'kPrefsSoupTemplate, 				{			version: 				1, 			font: 					ROM_fontSystem9, 			viewMode: 				kTerminalModeSymbol,			supressAlerts:			nil,			autoDisconnect:		nil,			profile:					nil,			clearTerminalLine:	nil,			modulePrefs: 			{}		});		constant kSupressAlertPathName		:= 'supressAlerts;constant kFontPathName					:= 'font;constant kAutoDisconnectPathName		:= 'autoDisconnect;constant kProfilePathName				:= 'profile;constant kViewModePathName				:= 'viewMode;constant kClearTerminalPathName		:= 'clearTerminalLine;constant kAutoDisconnectString		:= "Disconnect automatically when closing";constant kClearTerminalString			:= "Clear terminal line after send.";constant kSupressAlertsString			:= "Supress Alerts";constant kProfileDataString			:= "Profile Data Rates";constant kTerminalFontString			:= "Terminal Font";constant kPrefsSlipTitleString		:= "Tool Time Prefs";/********************************************************************//*								Status Bar Constants								  *//********************************************************************/ //	---------------------- Connect Button Constants constant kConnectButtonString 		:= "  Connection";constant kConnectItemString			:= "Connect ^0";constant kDisconnectItemString		:= "Disconnect ^0";constant kEndpointTypeSymbol			:= 'endpoint;constant kConnectedTypeSymbol			:= 'connectedEndpoint;constant kPreflightTypeSymbol			:= 'preflight;constant kPostflightTypeSymbol		:= 'postflight; constant kDisconnectAllTypeSymbol	:= 'disconnectAll;constant kConnectButtonSymbol			:= '_connectionButton;constant kDisconnectAllItemString	:= "Disconnect All";//	---------------------- Options Button Constantsconstant kEndpointExtraListItem	:= "^0 Extras";constant kToolExtraListItem		:= "^0 Extras";constant kToolInfoListItem			:= "^0 Information";constant kEndpointInfoListItem	:= "^0 Information";constant kDataOptionsText 			:= "  Options";constant kToolExtraSymbol			:= 'toolExtra;constant kToolInfoSymbol			:= 'toolInfo;constant kEndpointExtraSymbol		:= 'endpointExtra;constant kEndpointInfoSymbol		:= 'endpointInfo;constant kSendDataSymbol			:= 'send;constant kReceiveDataSymbol		:= 'receive;constant kLinkEndpointsSymbol		:= 'link;constant kTestDataOptionsArray 	:= 	'[{item: "Send Data", type: send},{item: "Receive Data", type: receive}];constant kAnalyzeDataOptionsArray := 	'[{item: "Link Endpoints", type: link}];//	---------------------- Mode Button Constantsconstant kModeButtonText 			:= "  Mode";   constant kModeOptionsArray := '[{item: "Terminal", symbol: terminal, mark: nil},	  					   	    		{item: "Test", symbol: test, mark: nil},	  					   	    		{item: "Echo", symbol: echo, mark: nil}];	  					   	    //		{item: "Analyzer", symbol: analyzer, mark: nil}];//	---------------------- Action Button Constantsconstant kClearScreenText 			:= "Clear Screen";constant kPrintToInspectorText	:= "Print terminal to inspector";constant kPrettyPrintText			:= "Pretty print to inspector";//	---------------------- Send Button Constantsconstant kSendButtonString			:= "Send";//	---------------------- Info Button Constantsconstant kToolPrefItemString					:= "^0 Prefs";/********************************************************************//*						Notify Strings													*//********************************************************************/ constant kUnknownErrorString			:= "An unknown error has occurred.";constant kReallyDisconnectString		:= "There are connected tools.  Would you like to disconnect all tools and close?";constant kNoEndpointNameString		:= "Sorry, you must enter an endpoint name.";constant kNoToolsInstalledString 	:= "Sorry, there are no installed tools.";constant kConnectFloaterErrorString := "There was an error opening the connect slip.";constant kNoOverviewSupportString 	:= "Sorry, overview is not supported.";constant kNoConnectedToolsString		:= "Sorry, there are no connected tools.";constant kNoModeOptionsString			:= "Sorry, there are currently no options available.";constant kNoSizeInformation 			:= "You must enter the size of the object to send.";constant kNoEndpointForSendString	:= "Sorry, the requested endpoint is not connected.";constant kLinkBrokenString				:= "Sorry, your link has been broken.";	  					   	    /********************************************************************//*							Data Generation Constants							  *//********************************************************************/ constant kByteArray 				:= '[0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF];constant kASCIIString 			:= " !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~";/********************************************************************//*							Resource Constants									  *//********************************************************************/ /*OpenResFile( HOME & "Tool Time.rsrc" );DefineGlobalConstant( 'kWriteIcon, GetPictAsBits( "writeIcon", nil ) );DefineGlobalConstant( 'kReadIcon, GetPictAsBits( "readIcon", nil ) );CloseResFile();*/// End of text file Project Constants// Beginning of text file TestMode Constants/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/DefineGlobalConstant( 'kNumericInputLineTemplate,						{							_proto:					protoLabelInputLine,							label:					"Label",							viewBounds:				SetBounds(  0, 30, 150, 55 ),							entryFlags:				vVisible + vClickable + vGesturesAllowed + vNumbersAllowed,							target:					nil,									textSetup:				func()														begin															if testModeFloaterBase.(target) then																NumberStr( testModeFloaterBase.(target) );															else																"";														end,							textChanged:			func()														begin															local number;															if number := StringToNumber( entryLine.text ) then																testModeFloaterBase.(target) := Floor( number );															else																testModeFloaterBase.(target) := 0;														end,						} );DefineGlobalConstant( 'kCheckboxTemplate, 						{							_proto:					protoCheckbox,							viewValue:				nil,							text:						"text",							viewBounds:				SetBounds( 10, 25, 170, 41 ),							valueChanged:			func()														begin															testModeFloaterBase.(target) := viewValue;														end,							viewSetupFormScript:	func()														begin															self.viewValue := testModeFloaterBase.(target);															inherited:?viewSetupFormScript();														end,						} );// End of text file TestMode Constants// Beginning of text file TestMode Send Constants/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant kSendSizeTypeString				:= "Send Size Settings";constant kSendFlagsTypeString				:= "Send Flags Slot Settings";constant kSendChunkString					:= "Binary Target Settings";constant kSendBinaryGenerationString	:= "Binary Generation Settings";constant kSendFrameGenerationString		:= "Frame Generation Settings";constant kSendStringGenerationString	:= "String Generation Settings";constant kSendNumberGenerationString	:= "Number Generation Settings";constant kSendBytesGenerationString		:= "Bytes Generation Settings";DefineGlobalConstant( 'kOutputInformationTemplate,	{		size:			0,		useVBO:		nil,		spec:			nil,		flagsTemp:	0,	} );DefineGlobalConstant( 'kOutputSpecifications, 	{		binary:	{form: 'binary, target: {offset: 0, length: 0}},		frame:	{form: 'frame},		number:	{form: 'number},		string:	{form: 'string},		bytes:	{form: 'bytes},	});	DefineGlobalConstant( 'kFlagsCheckboxTemplate,						{							_proto:					protoCheckbox,							viewValue:				nil,							text:						"text",							viewBounds:				SetBounds( 10, 25, 170, 41 ),							target:					nil,							helperTarget:			nil,							boxValue:				nil,							boxIndex:				nil,							valueChanged:			func()														begin															// we have to do some weird stuff here because one of the flags can															// have a value of zero.  We have to make sure to nil out the flags															// when none of the boxes are checked															if viewValue then																begin																	if NOT testModeFloaterBase.(target) then																		testModeFloaterBase.(target) := boxValue;																	else																		testModeFloaterBase.(target) := testModeFloaterBase.(target) + boxValue;																																			testModeFloaterBase.(helperTarget) := testModeFloaterBase.(helperTarget) + boxIndex;																end;															else																begin																	testModeFloaterBase.(target) := testModeFloaterBase.(target) - boxValue;																																		testModeFloaterBase.(helperTarget) := testModeFloaterBase.(helperTarget) - boxIndex;																	if testModeFloaterBase.(helperTarget) = 0 then																		testModeFloaterBase.(target) := nil;																end;														end,							viewSetupFormScript:	func()														begin															if testModeFloaterBase.(target) then																viewValue := (band( testModeFloaterBase.(target), boxValue ) = boxValue);																															if viewValue then																testModeFloaterBase.(helperTarget) := testModeFloaterBase.(helperTarget) + boxIndex;																															inherited:?viewSetupFormScript();														end,						});DefineGlobalConstant( 'kBinaryGenerationTemplate,		{				title:			"Binary Generation",				height:			75,				width:			170,				children:							[						{							_proto:					kCheckboxTemplate,							text:						"Send from a virtual binary object",							viewBounds:				SetBounds( 10, 25, 170, 41 ),							target:					[pathExpr: 'outputInformation, 'useVBO],						},						{							_proto:					kNumericInputLineTemplate,							label:					"Byte Count",							viewBounds:				SetBounds( 0, 50, 170, 75 ),							target:					[pathExpr: 'outputInformation, 'size],						},					],		} );DefineGlobalConstant( 'kStringGenerationTemplate,		{				title:			"String Generation",				height:			50,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"String Length",							viewBounds:				SetBounds( 0, 25, 170, 50 ),							target:					[pathExpr: 'outputInformation, 'size],						},					],		} );		DefineGlobalConstant( 'kFrameGenerationTemplate,		{				title:			"Frame Generation",				height:			50,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"Numer of Slots",							viewBounds:				SetBounds( 0, 25, 170, 50 ),							target:					[pathExpr: 'outputInformation, 'size],						},					],		} );		DefineGlobalConstant( 'kNumberGenerationTemplate,		{				title:			"Number Generation",				height:			50,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"How Many",							viewBounds:				SetBounds( 0, 25, 170, 50 ),							target:					[pathExpr: 'outputInformation, 'size],						},					],		} );		DefineGlobalConstant( 'kBytesGenerationTemplate,		{				title:			"Bytes Generation",				height:			50,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"Byte Count",							viewBounds:				SetBounds( 0, 25, 170, 50 ),							target:					[pathExpr: 'outputInformation, 'size],						},					],		} );		DefineGlobalConstant( 'kSendChunkTemplate,		{				title:			"Target Settings",				height:			85,				width:			150,				children:					[						{							_proto:					kNumericInputLineTemplate,							label:					"Offset",							viewBounds:				SetBounds( 0, 30, 150, 55 ),							target:					[pathExpr: 'outputInformation, 'spec, 'target, 'offset],						},						{							_proto:					kNumericInputLineTemplate,							label:					"Chunk Size",							viewBounds:				SetBounds(  0, 60, 150, 85 ),							target:					[pathExpr: 'outputInformation, 'spec, 'target, 'length],						},					],		} );		DefineGlobalConstant( 'kSendFlagsTemplate,		{				title:			"Send Flags",				height:			81,				width:			150,				children:					[						{							_proto:					kFlagsCheckboxTemplate,							text:						"kPacket",							viewBounds:				SetBounds( 10, 25, 100, 41 ),							boxValue:				kPacket,							boxIndex:				1,							target:					[pathExpr: 'outputInformation, 'spec, 'sendFlags],							helperTarget:			[pathExpr: 'outputInformation, 'flagsTemp]						},						{							_proto:					kFlagsCheckboxTemplate,							text:						"kMore",							viewBounds:				SetBounds( 10, 45, 100, 61 ),							boxValue:				kMore,							boxIndex:				2,							target:					[pathExpr: 'outputInformation, 'spec, 'sendFlags],							helperTarget:			[pathExpr: 'outputInformation, 'flagsTemp]						},						{							_proto:					kFlagsCheckboxTemplate,							text:						"kEOP",							viewBounds:				SetBounds( 10, 65, 100, 81 ),							boxValue:				kEOP,							boxIndex:				3,							target:					[pathExpr: 'outputInformation, 'spec, 'sendFlags],							helperTarget:			[pathExpr: 'outputInformation, 'flagsTemp],						},					],		} );// End of text file TestMode Send Constants// Beginning of text file TestMode Receive Constants/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant kTerminateSpecString				:= "Terminate Spec Settings";constant kTerminationTypeString			:= "Termination Slot Settings";constant kReceiveFlagsTypeString			:= "Receive Flags Slot Settings";constant kDiscardAfterTypeString			:= "Discard After Slot Settings";constant kRequestTimeoutTypeString		:= "Request Timeout Slot Settings";constant kPartialFreqTypeString			:= "Partial Frequency Slot Settings";constant kTargetInformationString		:= "Target Slot Settings";DefineGlobalConstant( 'kInputSpecifications,		{			binary:					{					form: 			'binary, 					target: 			{useVBO: nil, length: 0, offset: 0, data: nil},					termination:	{useEOP: nil, byteCount: 0},					rcvFlags:		nil,					reqTimeout:		0,					terminate:		nil,				}, 			bytes:				{					form: 			'bytes, 					termination:	{byteCount: 0},					rcvFlags:		nil,					discardAfter:	0,					reqTimeout:		0,					partialFrequency:	0,					terminate:		nil,				}, 			number:				{					form: 			'number, 					rcvFlags:		nil,					discardAfter:	0,					reqTimeout:		0,					terminate:		nil,				},			string:				{					form: 			'string, 					termination:	{useEOP: nil, byteCount: 0},					rcvFlags:		nil,					discardAfter:	0,					reqTimeout:		0,					partialFrequency:	0,					terminate:		nil,				},			frame:				{					form: 			'frame, 					rcvFlags:		nil,					terminate:		nil,					reqTimeout:		0,				},		});DefineGlobalConstant( 'kTerminateSpecTemplate, 		{				title:			"Terminate Specification",				height:			41,				width:			170,				children:							[						{							_proto:					kCheckboxTemplate,							text:						"Terminate Input Specification",							viewBounds:				SetBounds( 10, 25, 170, 41 ),							target:					[pathExpr: 'specification, 'terminate],						},					],		} );DefineGlobalConstant( 'kRequestTimeoutTemplate, 		{				title:			"Request Timeout",				height:			55,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"Request Timeout",							viewBounds:				SetBounds( 0, 30, 170, 55 ),							target:					[pathExpr: 'specification, 'reqTimeout],						},					],		} );DefineGlobalConstant( 'kDiscardAfterTemplate, 		{				title:			"Discard After",				height:			55,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"Discard After",							viewBounds:				SetBounds( 0, 30, 170, 55 ),							target:					[pathExpr: 'specification, 'discardAfter],						},					],		} );		DefineGlobalConstant( 'kPartialFreqTimeoutTemplate, 		{				title:			"Partial Frequency",				height:			55,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"Request Timeout",							viewBounds:				SetBounds( 0, 30, 170, 55 ),							target:					[pathExpr: 'specification, 'partialFrequency],						},					],		} );		DefineGlobalConstant( 'kReceiveFlagsTemplate, 		{				title:			"Receive Flags",				height:			41,				width:			170,				children:							[						{							_proto:					protoCheckbox,							viewValue:				nil,							text:						"kPacket",							viewBounds:				SetBounds( 10, 25, 170, 41 ),							valueChanged:			func()														begin															if viewValue then																specification.rcvFlags := kPacket;															else																specification.rcvFlags := nil;														end,							viewSetupFormScript:	func()														begin															self.viewValue := specification.rcvFlags = kPacket;															inherited:?viewSetupFormScript();														end,						}					],		} );DefineGlobalConstant( 'kTerminationInfoTemplate, 		{				title:			"Termination Information",				height:			76,				width:			170,				children:							[						{							_proto:					kNumericInputLineTemplate,							label:					"Byte Count",							viewBounds:				SetBounds( 0, 30, 170, 55 ),							target:					[pathExpr: 'specification, 'termination, 'byteCount],						},						{							_proto:					kCheckboxTemplate,							text:						"Use EOP",							viewBounds:				SetBounds( 10, 60, 170, 76 ),							target:					[pathExpr: 'specification, 'termination, 'useEOP],						},					],		} );		DefineGlobalConstant( 'kTargetInformationTemplate,		{				title:			"Target Information",				height:			105,				width:			170,				children:							[						{							_proto:					kCheckboxTemplate,							text:						"Receive into a virtual binary object",							viewBounds:				SetBounds( 10, 25, 170, 41 ),							target:					[pathExpr: 'specification, 'target, 'useVBO],						},						{							_proto:					kNumericInputLineTemplate,							label:					"Total Binary Size",							viewBounds:				SetBounds( 0, 50, 170, 75 ),							target:					[pathExpr: 'specification, 'target, 'length],						},						{							_proto:					kNumericInputLineTemplate,							label:					"Offset",							viewBounds:				SetBounds( 0, 80, 170, 105 ),							target:					[pathExpr: 'specification, 'target, 'offset],						},					],		} );// End of text file TestMode Receive Constants// Beginning of file protoDynamicFloaterfloaterBase :=    {viewBounds: {left: 0, top: 0, right: 184, bottom: 282},     viewJustify: 80,     viewSetupChildrenScript:       func()       begin       	// Make sure the stepChildren are in the NewtonScript heap       	if IsReadOnly( self.stepChildren ) then       		self.stepChildren := Clone( self.StepChildren );       	       	// add the tool options view to the slip, be sure to set the viewbound correctly       	self.childView :=        			{       				_proto: 			childTemplate,                  	viewBounds: 	SetBounds( 0, childTopOffset, childTemplate.width, childTopOffset+childTemplate.height ),       			};       	                    	AddArraySlot( self.stepChildren, childView );       end,     viewSetupFormScript:       func()       begin       	// Make sure that the viewbounds are in the NewtonScript heap       	if IsReadOnly( self.viewBounds ) then       		self.viewBounds := Clone( self.viewBounds );              	// Adjust the viewBounds so the options fit in the window       	if childTemplate then        		begin       			self.viewBounds.bottom := childTopOffset + childTemplate.height + childBottomOffset;       			self.viewBounds.right := childTemplate.width;       			SetKeyView( self, nil );       		end        	else       		AddDeferredSend( self, 'Close, [] );       end,     floaterTitle: "",     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	// remove the RAM based stepChildren array.  Then nil out the other RAM based slots       	RemoveSlot( self, 'stepChildren );       	RemoveSlot( self, 'childView );       	RemoveSlot( self, 'childTemplate );       	RemoveSlot( self, 'floaterTitle );       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     childTemplate: nil,     childView: nil,     childTopOffset: 0,     childBottomOffset: 0,     _proto: @179 /* protoFloater */    };floaterBase_v229_0 :=    {viewBounds: {left: 0, top: 0, right: 80, bottom: 16},     viewSetupFormScript:       func()       begin       	self.title :=  floaterTitle;       	       	inherited:?viewSetupFormScript();		// this method is defined internally       end,     title: "",     _proto: @229 /* protoTitle */    };AddStepForm(floaterBase, floaterBase_v229_0);// After Script for floaterBasethisView := floaterBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoDynamicFloater| := floaterBase;// End of file protoDynamicFloater// Beginning of file protoFontPickerfontPickerBase :=    {viewBounds: {left: 0, top: 0, right: 122, bottom: 51},     viewFlags: 1,     viewFormat: 0,     viewSetupFormScript:       func()       begin       	self.userFont := DeepClone( :GetPreferenceItem( path ) );       end,     userFont: {family: 'espy, face: 0, size: 9},     path: nil,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	:SetPreferenceItem( path, self.userFont );              	inherited:?viewQuitScript();		// this method is defined internally       end,     viewClass: 74 /* clView */    };fontPickerBase_v386_0 :=    {text: "Font",     popup: [],     viewBounds: {left: 10, top: 2, right: 54, bottom: 14},     viewFlags: 515,     buttonClickScript:       func()       begin       	popup := MakeFontMenu( userFont, nil, 'none, 'none );       					       	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     pickActionScript:       func(item)       begin       	// set the font family correctly       	userFont.family := popup[item].family;       	       	// finally, update the sample text       	SetValue( sampleTextView, 'viewFont, userFont );              	inherited:?PickActionScript(item);		// call the inherited version to unhilite the button       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(fontPickerBase, fontPickerBase_v386_0);fontPickerBase_v386_0 :=    {text: "Size",     popup: [],     viewBounds: {left: 10, top: 2, right: 54, bottom: 14},     viewFlags: 515,     pickActionScript:       func(item)       begin       	// set the font size       	userFont.size := popup[item].size;       		       	// finally, update the sample text       	SetValue( sampleTextView, 'viewFont, userFont );              	inherited:?PickActionScript( item );		// call the inherited version to unhilite the button       end,     buttonClickScript:       func()       begin       	popup := MakeFontMenu( userFont, 'none, nil, 'none );              	inherited:?ButtonClickScript();	// call the inherited version to do popup       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(fontPickerBase, fontPickerBase_v386_0);sampleTextView :=    {text: "Sample",     viewBounds: {left: 9, top: 24, right: 111, bottom: 50},     viewJustify: 8388610,     viewSetupFormScript:       func()       begin       	self.viewFont := userFont;       end,     _proto: @218 /* protoStaticText */    };AddStepForm(fontPickerBase, sampleTextView);StepDeclare(fontPickerBase, sampleTextView, 'sampleTextView);// After Script for fontPickerBasethisView := fontPickerBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoFontPicker| := fontPickerBase;// End of file protoFontPicker// Beginning of file protoObjectPrinter_v74_0 :=    {     PrintArray:       func( object, termination )       begin       	local str := "[";       	if ClassOf( object ) <> 'array then       		str := str & SPrintObject(ClassOf(object)) & ": ";       	       	:AddBody( str );       	       	foreach slot, value in object do       		:PrintObject( value, ", " );              	:AddBody( "]"&termination );       end,     PrintBinary:       func( object, termination )       begin       	if kDebugOn then       		:DebugPrint( "In PrintBinary", [object, termination] );              	:AddBody( "<" & SPrintObject(ClassOf(object)) & ", length" && NumberStr(Length(object)) & "> " );       	:AddBody( :StrHexDump( object, 1 ) );       	:AddBody( termination );       end,     printFrame:       func( frame, termination )       begin       	:AddBody( "{" );              	foreach slot, object in frame do       		begin       			:AddBody( SPrintObject(slot)&": " );       						       			// Handle self-refs       			if frame.(slot) = frame then       				:AddBody( "<1>" );       			else       				:PrintObject( object, ", " );       		end;       		       	:AddBody( "}"&termination );       end,     PrintObject:       func( object, termination )       begin       	if kDebugOn then       		:DebugPrint( "In PrintObject", [object, termination] );       		       	if IsSymbol( object ) then       		begin       			:AddBody( "'" & SPrintObject( object ) );       			:AddBody( termination );       		end;       	else if IsString( object ) then       		begin       			:AddBody( object );       			:AddBody( termination )       		end;       	else if IsNumber( object ) then       		begin       			:AddBody( NumberStr(object) );       			:AddBody( termination )       		end;       	else if IsImmediate( object ) then       		begin       			if object then       				:AddBody( "true" );       			else       				:AddBody( "nil" );       				       			:AddBody( termination );       		end;       	else if IsBinary( object ) then       		:PrintBinary( object, termination );       	else if IsFunction( object ) then       		:PrintFunction( object, termination );       	else if IsFrame( object ) then       		:PrintFrame( object, termination );       	else if IsArray( object ) then       		:PrintArray( object, termination );       	else       		begin       			:AddBody( "Unknown Object" );       			:AddBody( termination );       		end;       end,     Instantiate:       func( context )       begin       	{       	 _proto: 		self,       	 _parent: 		context,       	}       end,     Dispose:       func()       begin       	nil;       end,     PrintFunction:       func( function, termination )       begin       	local argCount := GetFunctionArgCount( function );       	       	local string := ParamStr( "<function, ^?0^1 arg|^1 args|>", [argCount = 1, argCount] );       	       	:AddBody( string );       	:AddBody( termination );       end,     StrHexDump:       func( theObject, theSpacing )       begin       	StrHexDump( theObject, theSpacing )       end,     viewClass: 74 /* clView */    };// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/RemoveSlot( thisView, 'viewClass );constant |layout_protoObjectPrinter| := _v74_0;// End of file protoObjectPrinter// Beginning of file protoTestModeFloatertestModeFloaterBase :=    {viewBounds: {left: 0, top: 0, right: 230, bottom: 295},     viewJustify: 80,     GetDataTypeItems:       func( theType )       begin       	// Should be implemented by user of protoTestModeFloater       end,     ChangeDataType:       func( newType )       begin       	// Setup the data type       	:SetupDataType( newType );       	       	// Let the overview adjust itself       	itemsOverview:RedoChildren();       end,     OpenDataItemViewer:       func( dataItem )       begin       	// Should be implemented by user of protoTestModeFloater       end,     toolInstance: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin	       	// Setup the slot for the data item viewers to use       	// We cannot just override the declareSelf slot becase       	// the closebox relies on that slot being set to a certain       	// value.       	self.testModeFloaterBase := self;       		       	inherited:?ViewSetupFormScript();       end,     SetupDataType:       func( theType )       begin       	// Should be implemented by user of protoTestModeFloater       end,     testModeFloaterBase: nil,     EndpointConnected:       func( theToolInstance )       begin       	:RedoChildren();       end,     viewSetupChildrenScript:       func()       begin       	// Setup the data type.       	// Make sure this matches the default value of the radio cluster!!!       	:SetupDataType( dataTypeCluster:GetDataType() );       end,     EndpointDisconnected:       func( theToolInstance )       begin       	:RedoChildren();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	self.toolInstance := nil;       	self.testModeFloaterBase := nil;       	       	inherited:?ViewQuitScript();       end,     _proto: @179 /* protoFloater */    };testModeFloaterBase_v190_0 :=    {labelCommands: [],     text: "Endpoint",     viewBounds: {left: 8, top: 30, right: -10, bottom: 46},     alwaysCallPickActionScript: true,     viewJustify: 8388656,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.labelCommands := [];       	       	// Find all the connected instances and add each one to the popup list       	foreach toolManager in toolTimeBase.toolManagers do       		begin       			local theInstances := toolManager:GetToolInstances();       			       			foreach toolInstance in theInstances do       				begin       					if toolInstance:IsConnected() then       						AddArraySlot( self.labelCommands, {item: toolInstance:GetInstanceName(), instance: toolInstance} );       				end;       		end;       		       	if Length( self.labelCommands ) = 0 then       		AddDeferredSend( testModeFloaterBase, 'Close, [] );       	else       		testModeFloaterBase.toolInstance := labelCommands[0].instance;		// Setup the initial toolInstance in the floater              	inherited:?ViewSetupFormScript();       end,     textSetup:       func()       begin       	if Length( labelCommands ) > 0 then       		begin       			// return the text for the first item       			labelCommands[0].item;       		end;       	else       		"";       end;,     labelActionScript:       func(cmd)       begin       	testModeFloaterBase.toolInstance := labelCommands[cmd].instance;       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v190_0);testModeFloaterBase_v218_0 :=    {text: kDataTypeString,     viewBounds: {left: 10, top: 5, right: 100, bottom: 21},     viewJustify: 8192,     _proto: @218 /* protoStaticText */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v218_0);dataTypeCluster :=    {viewBounds: {left: 0, top: 5, right: 192, bottom: 60},     clusterChanged:       func()       begin       	:ChangeDataType( clusterValue );       end,     viewJustify: 8208,     clusterValue: 'binary,     GetDataType:       func()       begin       	// return the current cluster value       	clusterValue;       end,     _proto: @203 /* protoRadioCluster */    };AddStepForm(testModeFloaterBase, dataTypeCluster);StepDeclare(testModeFloaterBase, dataTypeCluster, 'dataTypeCluster);dataTypeCluster_v202_0 :=    {buttonValue: 'binary,     viewBounds: {left: 0, top: 0, right: 94, bottom: 16},     text: "Binary",     _proto: @202 /* protoRadioButton */    };AddStepForm(dataTypeCluster, dataTypeCluster_v202_0);dataTypeCluster_v202_0 :=    {buttonValue: 'string,     viewBounds: {left: 0, top: 19, right: 94, bottom: 35},     text: "String",     _proto: @202 /* protoRadioButton */    };AddStepForm(dataTypeCluster, dataTypeCluster_v202_0);dataTypeCluster_v202_0 :=    {buttonValue: 'frame,     viewBounds: {left: 0, top: 38, right: 60, bottom: 54},     text: "Frame",     viewJustify: 20,     _proto: @202 /* protoRadioButton */    };AddStepForm(dataTypeCluster, dataTypeCluster_v202_0);dataTypeCluster_v202_0 :=    {buttonValue: 'number,     viewBounds: {left: 107, top: 0, right: 192, bottom: 16},     text: "Number",     _proto: @202 /* protoRadioButton */    };AddStepForm(dataTypeCluster, dataTypeCluster_v202_0);dataTypeCluster_v202_0 :=    {buttonValue: 'bytes,     viewBounds: {left: 107, top: 19, right: 192, bottom: 35},     text: "Bytes",     _proto: @202 /* protoRadioButton */    };AddStepForm(dataTypeCluster, dataTypeCluster_v202_0);itemsOverview :=    {     Abstract:       func( theItem, bbox )       begin       	// Create the abstract shape       	local theFontHeight 		:= FontHeight( self.viewFont );       	       	local halfWidth := (bbox.bottom - bbox.top) DIV 2;       	       	local theCircleTop 		:= halfWidth - kCircleDiameter DIV 2;       	local theCircleBottom	:= halfWidth + kCircleDiameter DIV 2;       	       	local theTextTop 			:= halfWidth - theFontHeight DIV 2;       	local theTextBottom 		:= halfWidth + theFontHeight DIV 2;              	[       		MakeText( theItem.title, bbox.left + kCircleDiameter + 4, bbox.top + 4, bbox.right, bbox.top + theFontHeight ),       		       		{fillPattern: vfBlack},       		MakeRoundRect( bbox.left, bbox.top + theCircleTop, bbox.left + kCircleDiameter, bbox.top + theCircleBottom, kCircleDiameter ),       	]       end,     viewBounds: {left: 10, top: 10, right: -10, bottom: 145},     nothingCheckable: true,     viewJustify: 8432,     HitItem:       func(index, xcoord, ycoord)       begin       	// Clone the cursor and move it to the tapped item.       	local c := cursor:Clone();       	c:Move( index );              	// Open a view based on the pref item template       	:OpenDataItemViewer( c:Entry() );       end,     viewSetupChildrenScript:       func()       begin       	// This is a hack, but it saves space       	self.cursor := {_proto: @505}:New( '{}, :GetDataTypeItems(dataTypeCluster:GetDataType();) );              	// Be sure to call the inherited method       	inherited:?viewSetupChildrenScript();       end,     autoDeselect: true,     selectIndent: 0,     lineHeight: 20,     _proto: @460 /* protoSoupOverview */    };AddStepForm(testModeFloaterBase, itemsOverview);StepDeclare(testModeFloaterBase, itemsOverview, 'itemsOverview);testModeFloaterBase_v386_0 :=    {text: "Options",     viewBounds: {left: 5, top: -18, right: 55, bottom: -5},     popup:       [       	{item: "Flush NewtonScript Buffer", value: 'flushInput},       	{item: "Flush Partial Buffer", value: 'flushPartial},       	'pickSeparator,       	{item: "Flush Out Buffer Async", value: 'flushOutAsync},       	{item: "Flush Out Buffer Sync", value: 'flushOutSync},       	'pickSeparator,       	{item: "Flush In Buffer Async", value: 'flushInAsync},       	{item: "Flush In Buffer Sync", value: 'flushInSync},       	'pickSeparator,       	{item: "Force Input", value: 'forceInput},       	{item: "Force Partial", value: 'forcePartial},       	'pickSeparator,       	{item: "Cancel Asynchronously", value: 'cancelAsync},       	{item: "Cancel Synchronously", value: 'cancelSync},       ],     viewFlags: 515,     viewJustify: 8388742,     pickActionScript:       func(itemSelected)       begin       	// Send the helper command off to the tool instance       	toolInstance:DoHelper( popup[itemSelected].value );       	       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v386_0);// After Script for testModeFloaterBasethisView := testModeFloaterBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoTestModeFloater| := testModeFloaterBase;// End of file protoTestModeFloater// Beginning of file TestMode Item.lyt_v180_0 :=    {     viewSetupFormScript:       func()       begin       	// Setup the bounds for this floater       	self.viewBounds := Clone( self.viewBounds );       	self.viewBounds.bottom := template.height + 30;       	self.viewBounds.right := template.width + 26;       	       	// be sure to call the inherited       	inherited:?viewSetupFormScript();       end,     template: nil,     viewJustify: 80,     viewBounds: {left: 0, top: 0, right: 100, bottom: 100},     viewSetupChildrenScript:       func()       begin       	self.stepChildren := Clone( self.stepChildren );       	       	ArrayMunger( self.stepChildren, Length(self.stepChildren), nil, template.children, 0, nil );       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	RemoveSlot( self, 'stepChildren );       	RemoveSlot( self, 'viewBounds );       	       	inherited:?ViewQuitScript();       end,     _proto: @180 /* protoFloatNGo */    };_v180_0_v229_0 :=    {title: "",     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	// Setup the title slot       	self.title := template.title;       	       	inherited:?ViewSetupFormScript();       end,     _proto: @229 /* protoTitle */    };AddStepForm(_v180_0, _v180_0_v229_0);// After Script for _v180_0thisView := _v180_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_TestMode Item.lyt| := _v180_0;// End of file TestMode Item.lyt// Beginning of file SendModeFloater.lyttestModeFloaterBase :=    {viewBounds: {left: 0, top: 0, right: 230, bottom: 295},     viewJustify: 80,     GetDataTypeItems:       func( theType )       begin       	// Return the appropriate items for the current type       	sendDataTypeItems.(theType)       end,     sendDataTypeItems:       {       	binary:	       		[       			{title: kSendBinaryGenerationString, template: kBinaryGenerationTemplate},       			{title: kSendChunkString, template: kSendChunkTemplate},       			{title: kSendFlagsTypeString, template: kSendFlagsTemplate},       		],       	string:	       		[       			{title: kSendStringGenerationString, template: kStringGenerationTemplate},       			{title: kSendFlagsTypeString, template: kSendFlagsTemplate},       		],       	number:	       		[       			{title: kSendNumberGenerationString, template: kNumberGenerationTemplate},       			{title: kSendFlagsTypeString, template: kSendFlagsTemplate},       		],       	bytes:	       		[       			{title: kSendBytesGenerationString, template: kBytesGenerationTemplate},       			{title: kSendFlagsTypeString, template: kSendFlagsTemplate},       		],	       	frame:	       		[       			{title: kSendFrameGenerationString, template: kFrameGenerationTemplate},       			{title: kSendFlagsTypeString, template: kSendFlagsTemplate},       		],       },     OpenDataItemViewer:       func( theDataItem )       begin       	// Grab the template for this dataItem       	if call kViewIsOpenFunc with (testModeItemView) then       		testModeItemView:Close();       	       	testModeItemView.template := theDataItem.template;		       	testModeItemView:Open();       end,     SetupDataType:       func( theType )       begin       	// Close the item view if it is open       	if call kViewIsOpenFunc with (testModeItemView) then       		testModeItemView:Close();              	// Setup the specification       	outputInformation := TotalClone( kOutputInformationTemplate );       	outputInformation.spec := TotalClone( kOutputSpecifications.(theType) );       	outputInformation.spec.sendFlags := toolInstance:?GetDefaultSendFlags();       end,     outputInformation: nil,     GenerateBinary:       func( size, useVBO )       begin       	if size = 0 then       		return nil;       		       	local target, i;       	       	// create the object       	if useVBO then       		target := GetStores()[0]:NewVBO( 'binary, size );       	else       		target := MakeBinary( size, 'binary );       	       	for i := 0 to size-1 do       		StuffByte( target, i, kByteArray[i mod 16] );       		       	target;       end,     GenerateBytes:       func( size )       begin       	if size = 0 then       		return nil;              	local i;       	local byteArray := Array( size, nil );       	       	for i := 0 to size-1 do       		byteArray[i] := kByteArray[i mod 16];              	byteArray;       end,     GenerateFrame:       // need to make so that it randomly chooses stuff to stuff into the slots       // and tells what that info is (ie: slot1:string, slot2:binary, etc)       func( numSlots )       begin       	if numSlots = 0 then       		return nil;              	local frame := {};       	local randArray := ['GenerateBinary, 'GenerateBytes, 'GenerateNumbers, 'GenerateString];       	SetRandomSeed( Ticks() );              	for i := 0 to numSlots-1 do       		begin       			local slotName := Intern( "slot" & NumberStr(i) );       			local index := Random( 0, 3 );       			if index = 0 then       				frame.(slotName) := :GenerateBinary( 20, nil );       			else       				frame.(slotName) := Perform( self, randArray[index], [20] );       		end;       	       	// Return the frame       	frame;       end              ,     GenerateNumbers:       func( size )       begin       	if size = 0 then       		return nil;              	SetRandomSeed( Ticks() );       	local i;              	if size > 1 then       		begin       			local numArray := Array( size, nil );       			for i := 0 to size -1 do       				numArray[i] := Random(0x0000000, 0xfffffff);       				return numArray;       		end       	else       		return Random(0x0000000, 0xfffffff);       end,     GenerateString:       func( size )       begin       	if size = 0 then       		return nil;              	// This is a real hack, but it works for now       	       	local str := Clone("");       	       	while (size > 0) do       		begin       			StrMunger( str, StrLen(str), nil, kASCIIString, 0, size );       			size := size - StrLen( kASCIIString );       		end;       		       	str;       end,     GenerateOutputData:       func()       begin       	// Grab the type of output       	local theType := outputInformation.spec.form;       	       	local theData;       	if theType = 'binary then       		theData := :GenerateBinary( outputInformation.size, outputInformation.useVBO );       	else if theType = 'bytes then       		theData := :GenerateBytes( outputInformation.size );       	else if theType = 'frame then       		theData := :GenerateFrame( outputInformation.size );       	else if theType = 'number then       		theData := :GenerateNumbers( outputInformation.size );       	else if theType = 'string then       		theData := :GenerateString( outputInformation.size );       		       	// return the data       	theData;       end,     ValidateSpecification:       func( theData, theSpec )       begin       	// Make sure that the length slot is set correctly in the target frame.       	// If it is not, then the output will never complete.       	if theSpec.form = 'binary AND theSpec.target.length = 0 then       		theSpec.target.length := Length( theData );              	// return the specification       	theSpec;       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	self.outputInformation := nil;       	       	inherited:?ViewQuitScript();       end,     _proto: testModeFloaterBase    };testModeItemView := LinkedSubview(_v180_0,    {viewBounds: {left: 3, top: 3, right: 75, bottom: 27}});AddStepForm(testModeFloaterBase, testModeItemView);StepDeclare(testModeFloaterBase, testModeItemView, 'testModeItemView);testModeFloaterBase_v229_0 :=    {title: kSendDataFloaterTitle, _proto: @229 /* protoTitle */};AddStepForm(testModeFloaterBase, testModeFloaterBase_v229_0);testModeFloaterBase_v226_0 :=    {     buttonClickScript:       func()       begin       	local theData := :GenerateOutputData();       	       	// Make sure there is data to output and that the tool is still connected       	if NOT theData then       		:NotifyAlert( kNoSizeInformation, kAppName );       	else if toolInstance:IsConnected() then       		begin       			// Validate the specification and send it on its way.       			local theSpec := :ValidateSpecification( theData, TotalClone( outputInformation.spec) );       			toolInstance:DoOutput( theData, nil, theSpec );       		end;       	else       		:NotifyAlert( kNoEndpointForSendString, kAppName );       		       	inherited:?ButtonClickScript();       end,     text: kSendDataButtonString,     viewBounds: {left: -55, top: -18, right: -25, bottom: -5},     viewJustify: 8388774,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local buttonWidth := StdButtonWidth( self.text );       	       	self.viewBounds := Clone( self.viewBounds );       	self.viewBounds.left := self.viewBounds.right - buttonWidth;       	       	inherited:?ViewSetupFormScript();       end,     _proto: @226 /* protoTextButton */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v226_0);testModeFloaterBase_v163_0 :=    {viewBounds: {left: -18, top: -18, right: -5, bottom: -5},     _proto: @163 /* protoLargeClosebox */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v163_0);// After Script for testModeFloaterBasethisView := testModeFloaterBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_SendModeFloater.lyt| := testModeFloaterBase;// End of file SendModeFloater.lyt// Beginning of file ReceiveModeFloater.lyttestModeFloaterBase :=    {viewBounds: {left: 0, top: 0, right: 230, bottom: 295},     viewJustify: 80,     GetDataTypeItems:       func( theType )       begin       	// Return the appropriate items for the current type       	receiveDataTypeItems.(theType)       end,     OpenDataItemViewer:       func( theDataItem )       begin       	// Grab the template for this dataItem       	if call kViewIsOpenFunc with (testModeItemView) then       		testModeItemView:Close();       	       	testModeItemView.template := theDataItem.template;		       	testModeItemView:Open();       end,     SetupDataType:       func( theType )       begin       	// Close the item view if it is open       	if call kViewIsOpenFunc with (testModeItemView) then       		testModeItemView:Close();       		       	// Setup the specification       	specification := TotalClone( kInputSpecifications.(theType) );       	specification.rcvFlags := toolInstance:?GetDefaultReceiveFlags();       end,     receiveDataTypeItems:       {       	binary:	       		[       			{title: kTerminateSpecString, template:	kTerminateSpecTemplate},       			{title: kTerminationTypeString, template: kTerminationInfoTemplate},       			{title: kTargetInformationString, template: kTargetInformationTemplate},       			{title: kReceiveFlagsTypeString, template: kReceiveFlagsTemplate},       			{title: kRequestTimeoutTypeString, template: kRequestTimeoutTemplate},       		],       	string:	       		[       			{title: kTerminateSpecString, template: kTerminateSpecTemplate},       			{title: kTerminationTypeString, template: kTerminationInfoTemplate},       			{title: kReceiveFlagsTypeString, template: kReceiveFlagsTemplate},       			{title: kDiscardAfterTypeString, template: kDiscardAfterTemplate},       			{title: kRequestTimeoutTypeString, template: kRequestTimeoutTemplate},       			{title: kPartialFreqTypeString, template: kPartialFreqTimeoutTemplate},       		],       	number:	       		[       			{title: kTerminateSpecString, template: kTerminateSpecTemplate},       			{title: kReceiveFlagsTypeString, template: kReceiveFlagsTemplate},       			{title: kDiscardAfterTypeString, template: kDiscardAfterTemplate},       			{title: kRequestTimeoutTypeString, template: kRequestTimeoutTemplate},       		],       	bytes:	       		[       			{title: kTerminateSpecString, template: kTerminateSpecTemplate},       			{title: kTerminationTypeString, template: kTerminationInfoTemplate},       			{title: kReceiveFlagsTypeString, template: kReceiveFlagsTemplate},       			{title: kDiscardAfterTypeString, template: kDiscardAfterTemplate},       			{title: kRequestTimeoutTypeString, template: kRequestTimeoutTemplate},       			{title: kPartialFreqTypeString, template: kPartialFreqTimeoutTemplate},       		],	       	frame:	       		[       			{title: kTerminateSpecString, template: kTerminateSpecTemplate},       			{title: kReceiveFlagsTypeString, template: kReceiveFlagsTemplate},       			{title: kRequestTimeoutTypeString, template: kRequestTimeoutTemplate}       		],       },     specification: nil,     ValidateSpecification:       func( theSpec )       begin       	// Setting discard after to nil will let us test the default value       	if theSpec.discardAfter = 0 then       		theSpec.discardAfter := nil;       		       	// Check on what kNoTimeout param is       	if theSpec.reqTimeout = 0 then       		theSpec.reqTimeout := nil;	       	       	// Create the binary object       	if theSpec.form = 'binary then       		begin       			if theSpec.target.useVBO then       				theSpec.target.data := GetStores()[0]:NewVBO( 'binary, theSpec.target.length );       			else       				theSpec.target.data := MakeBinary( theSpec.target.length, 'binary );       		end;       		       	// Return the specification       	theSpec;       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	self.specification := nil;       	       	inherited:?ViewQuitScript();       end,     _proto: testModeFloaterBase    };testModeItemView := LinkedSubview(_v180_0,    {viewBounds: {left: 3, top: 3, right: 75, bottom: 27}});AddStepForm(testModeFloaterBase, testModeItemView);StepDeclare(testModeFloaterBase, testModeItemView, 'testModeItemView);testModeFloaterBase_v229_0 :=    {title: kReceiveDataFloaterTitle, _proto: @229 /* protoTitle */};AddStepForm(testModeFloaterBase, testModeFloaterBase_v229_0);testModeFloaterBase_v226_0 :=    {     buttonClickScript:       func()       begin       	try       		local theSpecification := :ValidateSpecification( TotalClone( specification ) );       	onexception |evt.ex| do       		begin       			:NotifyAlert( kErrorValidatingSpecString, kAppName );       			return;       		end;       	       	// Make sure that the endpoint is still connected       	if toolInstance:IsConnected() then       		toolInstance:DoSetInputSpec( theSpecification );       	else       		:NotifyAlert( kNoEndpointForSendString, kAppName );       		       	inherited:?ButtonClickScript();       end,     text: kReceiveDataButtonString,     viewBounds: {left: -55, top: -18, right: -25, bottom: -5},     viewJustify: 8388774,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local buttonWidth := StdButtonWidth( self.text );       	       	self.viewBounds := Clone( self.viewBounds );       	self.viewBounds.left := self.viewBounds.right - buttonWidth;       	       	inherited:?ViewSetupFormScript();       end,     _proto: @226 /* protoTextButton */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v226_0);testModeFloaterBase_v163_0 :=    {viewBounds: {left: -18, top: -18, right: -5, bottom: -5},     _proto: @163 /* protoLargeClosebox */    };AddStepForm(testModeFloaterBase, testModeFloaterBase_v163_0);// After Script for testModeFloaterBasethisView := testModeFloaterBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_ReceiveModeFloater.lyt| := testModeFloaterBase;// End of file ReceiveModeFloater.lyt// Beginning of file Connect Floater.lytfloaterBase :=    {     ContinueButtonClick:       func( theConnectAction )       begin       	// Make sure that the endpoint name is filled in       	local theEndpointName := endpointNameView.entryLine.text;       	if NOT StrFilled( theEndpointName ) then       		begin       			context:NotifyAlert( kNoEndpointNameString, kAppName );       			return;       		end;              	// Update the preferences for this type of endpoint       	local theToolPrefs := toolManager:GetToolPrefs();       	context:SetPreferenceItem( [pathExpr: kModulePrefsSlotSymbol, toolManager.symbol], theToolPrefs );       		       	// Create a new instance.  Creating an instance will set the associated state       	// machine into motion.       	toolManager:CreateNewInstance( theEndpointName, theConnectAction );       		       	// Close the floater       	AddDeferredSend( self:Parent(), 'close, [] );       end,     context: nil,     viewSetupFormScript:       func()       begin       	// Setup the child template for the dynamic floater       	self.childTemplate := toolManager.endpointOptionsTemplate;       	       	// Setup the title       	local toolName := toolManager:GetCommToolName();       	self.floaterTitle := ParamStr( kConnectFloaterTitleString, [toolName] );       	       	context:RememberOpenView( self );       	       	inherited:?viewSetupFormScript();       end,     toolManager: nil,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	context:UnrememberOpenView( self );       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     floaterTitle: "",     childBottomOffset: 20,     childTopOffset: 60,     _proto: floaterBase    };endpointNameView :=    {viewBounds: {left: 0, top: 21, right: -5, bottom: 60},     alwaysCallPickActionScript: true,     label: "Name",     viewJustify: 8388656,     viewLineSpacing: 30,     viewSetupDoneScript:       func()       begin       	// Hilite the text so it is easily changable       	AddDeferredSend( self.entryLine, 'SetHilite, [0, 9999, true] );              	inherited:?viewSetupDoneScript();		// this method is defined internally       end,     textSetup:       func()       begin       	toolManager:GetDefaultInstanceName();       end,     _proto: @189 /* protoLabelInputLine */    };AddStepForm(floaterBase, endpointNameView);StepDeclare(floaterBase, endpointNameView, 'endpointNameView);_defaultButton :=    {     buttonClickScript:       func()       begin       	:ContinueButtonClick( kConnectSymbol );       end,     text: "Connect",     viewBounds: {left: -74, top: -18, right: -26, bottom: -5},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(floaterBase, _defaultButton);StepDeclare(floaterBase, _defaultButton, '_defaultButton);floaterBase_v226_0 :=    {     buttonClickScript:       func()       begin       	:ContinueButtonClick( kListenSymbol );       end,     text: "Listen",     viewBounds: {left: -125, top: -18, right: -82, bottom: -5},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(floaterBase, floaterBase_v226_0);floaterBase_v163_0 := {_proto: @163 /* protoLargeClosebox */};AddStepForm(floaterBase, floaterBase_v163_0);// After Script for floaterBasethisView := floaterBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Connect Floater.lyt| := floaterBase;// End of file Connect Floater.lyt// Beginning of file Generic Tool Floater.lytfloaterBase :=    {     viewSetupFormScript:       func()       begin       	context:RememberOpenView( self );       	       	inherited:?viewSetupFormScript();       end,     toolInstance: nil,     context: nil,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	context:UnrememberOpenView( self );       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     childTopOffset: 20,     childBottomOffset: 10,     _proto: floaterBase    };floaterBase_v166_0 := {_proto: @166 /* protoCloseBox */};AddStepForm(floaterBase, floaterBase_v166_0);// After Script for floaterBasethisView := floaterBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Generic Tool Floater.lyt| := floaterBase;// End of file Generic Tool Floater.lyt// Beginning of file LinkFloater.lyt_v180_0 :=    {viewBounds: {left: 0, top: 0, right: 160, bottom: 95},     viewJustify: 80,     linkedEndpoints: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.linkedEnpoints := [];       	       	inherited:?ViewSetupFormScript();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	// Tell each of the instances to start analyze mode       	linkedEndpoints[0]:DoStartAnalyzer();       	linkedEndpoints[1]:DoStartAnalyzer();       	       	toolTimeBase.analyzeLinkArray := self.linkedEndpoints;       	self.linkedEndpoints := nil;       	       	inherited:?ViewQuitScript();       end,     _proto: @180 /* protoFloatNGo */    };_v180_0_v229_0 :=    {title: kLinkEndpointsTitleString, _proto: @229 /* protoTitle */};AddStepForm(_v180_0, _v180_0_v229_0);_v180_0_v190_0 :=    {labelCommands: ["item 1","item 2"],     text: "Link",     viewBounds: {left: 1, top: 23, right: 151, bottom: 37},     alwaysCallPickActionScript: true,     labelActionScript:       func(cmd)       begin       	linkedEndpoints[0] := labelCommands[cmd].instance;       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.labelCommands := [];       	       	// Find all the connected instances and add each one to the popup list       	foreach toolManager in toolTimeBase.toolManagers do       		begin       			local theInstances := toolManager:GetToolInstances();       			       			foreach toolInstance in theInstances do       				begin       					if toolInstance:IsConnected() then       						AddArraySlot( self.labelCommands, {item: toolInstance:GetInstanceName(), instance: toolInstance} );       				end;       		end;       		       	linkedEndpoints[0] := labelCommands[0].instance;		// Setup the initial toolInstance in the floater              	inherited:?ViewSetupFormScript();       end,     textSetup:       func()       begin       	if Length( labelCommands ) > 0 then       		begin       			// return the text for the first item       			labelCommands[0].item;       		end;       	else       		"";       end;,     _proto: @190 /* protoLabelPicker */    };AddStepForm(_v180_0, _v180_0_v190_0);_v180_0_v190_0 :=    {labelCommands: ["item 1","item 2"],     text: "with",     viewBounds: {left: 1, top: 47, right: 151, bottom: 61},     alwaysCallPickActionScript: true,     labelActionScript:       func(cmd)       begin       	linkedEndpoints[1] := labelCommands[cmd].instance;       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.labelCommands := [];       	       	// Find all the connected instances and add each one to the popup list       	foreach toolManager in toolTimeBase.toolManagers do       		begin       			local theInstances := toolManager:GetToolInstances();       			       			foreach toolInstance in theInstances do       				begin       					if toolInstance:IsConnected() then       						AddArraySlot( self.labelCommands, {item: toolInstance:GetInstanceName(), instance: toolInstance} );       				end;       		end;       		       	linkedEndpoints[1] := labelCommands[0].instance;		// Setup the initial toolInstance in the floater              	inherited:?ViewSetupFormScript();       end,     textSetup:       func()       begin       	if Length( labelCommands ) > 0 then       		begin       			// return the text for the first item       			labelCommands[0].item;       		end;       	else       		"";       end;,     _proto: @190 /* protoLabelPicker */    };AddStepForm(_v180_0, _v180_0_v190_0);// After Script for _v180_0thisView := _v180_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_LinkFloater.lyt| := _v180_0;// End of file LinkFloater.lyt// Beginning of file Preferences.t_v179_0 :=    {viewBounds: {left: 0, top: 0, right: 230, bottom: 190},     viewJustify: 80,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	inherited:?viewQuitScript();		// this method is defined internally       	       	'postQuit;       end,     ViewPostQuitScript:       func()       begin       	:PreferencesChanged();       end,     _proto: @179 /* protoFloater */    };_v179_0_v229_0 :=    {title: kPrefsSlipTitleString,     viewBounds: {left: 6, top: 0, right: 102, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(_v179_0, _v179_0_v229_0);_v179_0_v164_0 :=    {text: kProfileDataString,     viewBounds: {left: 15, top: 5, right: -15, bottom: 21},     path: kProfilePathName,     viewSetupFormScript:       func()       begin       	self.viewValue := :GetPreferenceItem( path );       end,     valueChanged:       func()       begin       	:SetPreferenceItem( path, viewValue );       end,     viewJustify: 8244,     _proto: @164 /* protoCheckBox */    };AddStepForm(_v179_0, _v179_0_v164_0);_v179_0_v164_0 :=    {text: kSupressAlertsString,     viewBounds: {left: 15, top: 2, right: -15, bottom: 19},     path: kSupressAlertPathName,     viewSetupFormScript:       func()       begin       	self.viewValue := :GetPreferenceItem( path );       end,     valueChanged:       func()       begin       	:SetPreferenceItem( path, viewValue );       end,     viewJustify: 8244,     _proto: @164 /* protoCheckBox */    };AddStepForm(_v179_0, _v179_0_v164_0);_v179_0_v164_0 :=    {text: kAutoDisconnectString,     viewBounds: {left: 15, top: 2, right: -15, bottom: 19},     path: kAutoDisconnectPathName,     viewSetupFormScript:       func()       begin       	self.viewValue := :GetPreferenceItem( path );       end,     valueChanged:       func()       begin       	:SetPreferenceItem( path, viewValue );       end,     viewJustify: 8244,     _proto: @164 /* protoCheckBox */    };AddStepForm(_v179_0, _v179_0_v164_0);_v179_0_v164_0 :=    {text: kClearTerminalString,     viewBounds: {left: 15, top: 2, right: -15, bottom: 19},     path: kClearTerminalPathName,     viewSetupFormScript:       func()       begin       	self.viewValue := :GetPreferenceItem( path );       end,     valueChanged:       func()       begin       	:SetPreferenceItem( path, viewValue );       end,     viewJustify: 8244,     _proto: @164 /* protoCheckBox */    };AddStepForm(_v179_0, _v179_0_v164_0);_v179_0_v218_0 :=    {text: kTerminalFontString,     viewBounds: {left: 16, top: 5, right: 112, bottom: 21},     viewJustify: 8196,     _proto: @218 /* protoStaticText */    };AddStepForm(_v179_0, _v179_0_v218_0);_v179_0_v0_6 :=    {viewBounds: {left: 0, top: 2, right: 125, bottom: 56},     viewJustify: 8208,     path: kFontPathName,     _proto: fontPickerBase    };AddStepForm(_v179_0, _v179_0_v0_6);_v179_0_v166_0 := {_proto: @166 /* protoCloseBox */};AddStepForm(_v179_0, _v179_0_v166_0);// After Script for _v179_0thisView := _v179_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Preferences.t| := _v179_0;// End of file Preferences.t// Beginning of file AboutFloater.lyt_v180_0 :=    {viewBounds: {left: 0, top: 0, right: 220, bottom: 110},     viewJustify: 80,     _proto: @180 /* protoFloatNGo */    };_v180_0_v218_0 :=    {text: kAboutString,     viewBounds: {left: 10, top: 25, right: -10, bottom: -25},     viewJustify: 240,     _proto: @218 /* protoStaticText */    };AddStepForm(_v180_0, _v180_0_v218_0);_v180_0_v229_0 :=    {title: kAppName,     viewBounds: {left: 0, top: 0, right: 72, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(_v180_0, _v180_0_v229_0);// After Script for _v180_0thisView := _v180_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_AboutFloater.lyt| := _v180_0;// End of file AboutFloater.lyt// Beginning of file Test Tool.lytbaseView :=    {     ToolMonitorInstalled:       func( monitorSymbol, monitorFrame )       begin       	// We don't current do anything here.  This is mainly present for future compatibility.       	nil;       end,     RememberOpenView:       func( theView )       begin       	AddArraySlot( toolTimeBase.rememberedViews, theView );       end,     KeyScrollUpLine:       func( keyView )       begin       	terminalView:LineUp();       end,     viewSetupDoneScript:       func()       begin       	self.rememberedViews := [];       	       	// Register a power off function       	RegPowerOff( 	kAppSymbol,       						func(what, why)       						begin       							if what = 'okToPowerOff then       								begin       									// If the shutdown was not because the unit was idle then       									// send the base application an EmergencyShutdown message.       									if why <> 'idle then       										begin       											// Shut down each tool synchronously       											GetRoot().(kAppSymbol):EmergencyShutdown();       											       											return true;       										end;       								end;              							nil;       						end	);              	// Register all our key commands       	:AddKeyCommands( keyCommandArray );       	       	inherited:?viewSetupDoneScript();       end,     EndpointDisconnected:       func( theToolInstance )       begin       	// If we are in test mode and either the send or receive floater is open,       	// then let it know that a new endpoint is ready.       	// If we are in terminal mode, then tell the inputSendButton to       	// update itself.       	if :GetViewMode() = kTestModeSymbol then       		begin       			if call kViewIsOpenFunc with (sendModeFloater) then       				sendModeFloater:EndpointDisconnected( theToolInstance );       				       			if call kViewIsOpenFunc with (receiveModeFloater) then       				receiveModeFloater:EndpointDisconnected( theToolInstance );       		end;       	else if :GetViewMode() = kTerminalModeSymbol then       		begin			       			// Notify the send button       			inputSendButton:EndpointDisconnected( theToolInstance );       		end;       	else if :GetViewMode() = kAnalyzeModeSymbol then       		begin       			if call kViewIsOpenFunc with (linkEndpointsFloater) then       				linkEndpointsFloater:Close();       				       			// Make sure one of the linked endpoints did not go away       			if LSearch( toolTimeBase.linkEndpointsFloater, theToolInstance, 0, '|=|, nil ) then       				begin       					toolTimeBase.linkEndpointsFloater := nil;       					:NotifyAlert( kLinkBrokenString, kAppName );       				end;       		end;       		       	// Print a notification to the terminal view so the user knows when the endpoint       	// was disconnected       	local instanceName := theToolInstance:GetInstanceName();       	terminalView:AddHeader( ParamStr( kEndpointDisconnectedLogString, [instanceName]) );       	       	// Decrement the count of connected items       	toolTimeBase.connectedCount := toolTimeBase.connectedCount - 1;       	       	// Finally, close any windows that the endpoint had open       	foreach slot, view in toolTimeBase.rememberedViews do       		begin       			if view.toolInstance = theToolInstance then       				begin       					view:Close();       					RemoveSlot( toolTimeBase.rememberedViews, slot );       				end;       		end;       end,     viewFormat: 0,     analyzeLinkArray: nil,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	// Syncronously disconnect and dispose of all the tool instances.       	:EmergencyShutdown();              	// Dispose of all the tool managers       	foreach toolManager in toolManagers do       		begin       			// Save off the tool preferences       			local theToolPrefs := toolManager:GetToolPrefs();       			:SetPreferenceItem( [pathExpr: kModulePrefsSlotSymbol, toolManager.symbol], theToolPrefs );       			       			// Dispose of the manager       			toolManager:Dispose();       		end;       	       	// Unregister the power off handler       	UnregPowerOff( kAppSymbol );       	       	// nil out some variables       	self.toolManagers := nil;       	self.toolInstances := nil;       	self.doingEmergencyShutdown := nil;       	self.analyzeLinkArray := nil;       	       	// Close all the remembered views       	if Length( self.rememberedViews ) > 0 then       		foreach view in self.rememberedViews do       			view:Close();       	self.rememberedViews := nil;       	       	:ClearKeyCommands();       	       	inherited:?viewQuitScript();		// this method is defined internally       	       	'postQuit;       end,     connectedCount: nil,     toolManagers: nil,     ToolManagerInstalled:       func( toolSymbol, toolManagerFrame )       begin       	// Add this tool manager to the tool managers array       	if toolTimeBase AND toolTimeBase.toolManagers then       		begin       			// Grab the preferences for this tool       			local thePrefs := :GetPreferenceItem( [pathExpr: kModulePrefsSlotSymbol, toolManagerFrame.symbol] );              			AddArraySlot( toolTimeBase.toolManagers, toolManagerFrame:New( toolTimeBase, thePrefs ) );       		end;       end       ,     GetViewMode:       func()       begin       	// Return the current view mode       	toolTimeBase.currentViewMode;       end,     DebugPrint:       func( name, info)       begin       	write( name && "-->" ); print(info);       end,     ToolMonitorRemoved:       func( monitorSymbol )       begin       	// We don't current do anything here.  This is mainly present for future compatibility.       	nil;       end,     viewFlags: 5,     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     SetPreferenceItem:       func( path, value )       begin       	if kDebugOn then       		:DebugPrint( "In SetPreferenceItem", [path, value] );       		       	// Store the value in the preferences frame       	toolTimeBase.preferencesFrame.(path) := value;       end,     PreferencesChanged:       func()       begin       	if kDebugOn then       		:DebugPrint( "In PreferencesChanged", preferencesFrame );              	// Make sure the base view is open before trying to pass this       	// notification on.       	if call kViewIsOpenFunc with (toolTimeBase) then       		begin       			// Notify the terminal view that the font has changed       			local theFont := :GetPreferenceItem( kFontPathName );       			terminalView:?ChangeFont( theFont );       		end;       end,     PrintToTerminal:       func( theObject, theHeader, theInstance )       begin       	// Check and see if there is only one endpoint active.  If there is, then       	// don't print the instance name.  If there is not, then print the        	// instance name.       	local theRealHeader;       	if connectedCount > 1 then       		theRealHeader := theHeader;       	       	// Special case each of the modes to speed things up       	// as much as possible.       	local mode := :GetViewMode();       	if mode = kEchoModeSymbol then       		theInstance:DoOutput( theObject, nil, {form: 'bytes} );       	else if mode = kAnalyzeModeSymbol AND toolTimeBase.analyzeLinkArray then       		begin       			// Grab the correct instance to send this data out of       			if theInstance = toolTimeBase.analyzeLinkArray[0] then       				toolTimeBase.analyzeLinkArray[1]:DoOutput( theObject, nil, {form: 'bytes} );       			else       				toolTimeBase.analyzeLinkArray[0]:DoOutput( theObject, nil, {form: 'bytes} );       		end;              	terminalView:AddObject( theObject, theRealHeader );       end,     ToolManagerRemoved:       func( toolSymbol )       begin       	// See if this tool manager is installed and remove it.       	if toolTimeBase AND toolTimeBase.toolManagers then       		begin       			local pos := LSearch( toolTimeBase.toolManagers, toolSymbol, 0, '|=|, 'symbol );       			if pos then       				begin       					toolTimeBase.toolManagers[pos]:Dispose();       					RemoveSlot( toolTimeBase.toolManagers, pos );       				end;       		end;       end,     viewScrollDownScript:       func()       begin       	terminalView:PageDown();       end,     viewOverviewScript:       func()       begin       	:NotifyAlert( kNoOverviewSupportString, kAppName );       end,     keyCommandArray:       [       	{       		name: 			"Line Up",       	 	char: 			$\1E,       		modifiers: 		kCommandModifier,       		keyMessage: 	'KeyScrollUpLine,       	},       	{       		name: 			"Line Down",       		char: 			$\1F,       		modifiers: 		kCommandModifier,       		keyMessage: 	'KeyScrollDownLine       	},       	{       		name: 			"Connection",       		char: 			$k,       		modifiers: 		kCommandModifier,        		keyMessage: 	'KeyDoConnection,       	},       ],     viewJustify: 240,     GetOptionsButtonList:       func()       begin       	local theList := [];       	local theExtrasList := [];       	local theManagerList := [];       	local theEndpointInfoList := [];       	local theToolInfoList := [];       	local thePopupList := [];       	       	// If we are in test mode, then add the send and receive items       	if :GetViewMode() = kTestModeSymbol AND connectedCount > 0 then       		theList := TotalClone( kTestDataOptionsArray );       		       	if :GetViewMode() = kAnalyzeModeSymbol AND connectedCount > 2 then       		theList := TotalClone( kAnalyzeDataOptionsArray );       					       	// Loop through the current tool managers and build up the connection extras       	// list.       	foreach toolManager in toolTimeBase.toolManagers do       		begin       			// Add all the manager extra items       			if toolManager:GetToolExtrasTemplate() then       				begin       					local theManagerName := toolManager:?GetCommToolName();       					if theManagerName then       						AddArraySlot( theManagerList, {item: ParamStr( kToolExtraListItem, [theManagerName]), manager: toolManager, type: kToolExtraSymbol} );       				end;       			       			// Add the tool info items       			if toolManager:GetToolInfoTemplate() then       				begin       					local theManagerName := toolManager:?GetCommToolName();       					if theManagerName then       						AddArraySlot( theToolInfoList, {item: ParamStr( kToolInfoListItem, [theManagerName]), manager: toolManager, type: kToolInfoSymbol} );       				end;		       			       			// Grab all the instances for the manager manager       			local instances := toolManager:GetToolInstances();       			       			// If the instance is connected, then send of an event to the state       			// machine.       			foreach instance in instances do       				begin       					local theInstanceName := instance:GetInstanceName();       					if instance:IsConnected() then       						begin       							// Add all the endpoint extra items       							if toolManager:GetEndpointExtrasTemplate() then       								AddArraySlot( theExtrasList, {item: ParamStr( kEndpointExtraListItem, [theInstanceName] ), instance: instance, type: kEndpointExtraSymbol} );       								       							// Add all the information items       							if toolManager:GetEndpointInfoTemplate( 'user ) then       							 AddArraySlot( theEndpointInfoList, {item: ParamStr( kEndpointInfoListItem, [theInstanceName] ), instance: instance, type: kEndpointInfoSymbol} );       						end;       				end;       		end;              	if Length( theManagerList ) > 0 then       		ArrayMunger( thePopupList, Length(thePopupList), nil, theManagerList, 0, nil );              	// Add the tool info to the list       	if Length( theToolInfoList ) > 0 then       		begin       			if Length( thePopupList ) > 0 then       				AddArraySlot( thePopupList, 'pickseparator );       						       			// Munge the extras into the end of the popup array       			ArrayMunger( thePopupList, Length(thePopupList), nil, theToolInfoList, 0, nil );       		end;       		       	// Add the extras to the list       	if Length( theExtrasList ) > 0 then       		begin       			if Length( thePopupList ) > 0 then       				AddArraySlot( thePopupList, 'pickseparator );       						       			// Munge the extras into the end of the popup array       			ArrayMunger( thePopupList, Length(thePopupList), nil, theExtrasList, 0, nil );       		end;       	       	if Length( theEndpointInfoList ) > 0 then       		begin       			if Length( thePopupList ) > 0 then       				AddArraySlot( thePopupList, 'pickSeparator );       				       			// Munge the endpoint info list into the end of the popup array       			ArrayMunger( thePopupList, Length(thePopupList), nil, theEndpointInfoList, 0, nil );       		end;       		       	// Add the send and receive options to the list       	if Length( theList ) > 0 then       		begin       			if Length( thePopupList ) > 0 then       				AddArraySlot( thePopupList, 'pickseparator );       						       			// Munge the the send/receive into the end of the popup array       			ArrayMunger( thePopupList, Length(thePopupList), nil, theList, 0, nil );       		end;       		       	// return the list       	thePopupList;       end,     ChangeViewMode:       func( newMode )       begin       	currentViewMode := newMode;       	:SetPreferenceItem( kViewModePathName, newMode );       	       	// Tell the instances that the mode has changed       	foreach manager in toolTimeBase.toolManagers do       		begin       			// Grab all the instances for a manager       			local instances := manager:GetToolInstances();       			       			// If the instance is connected, then send of an event to the state       			// machine.       			foreach instance in instances do       				begin       					if instance:IsConnected() then       						instance:DoChangeViewMode( newMode );       				end;       		end;       		       	toolTimeBase:RedoChildren();       end,     KeyDoConnection:       func( keyView )       begin       	// Do the button press       	PressButton( kConnectButtonSymbol );       end,     ViewPostQuitScript:       func()       begin       	// Flush the prefs frame changes       	if preferencesFrame then        		begin       			EntryChangeXmit( preferencesFrame, nil );       			preferencesFrame := nil;       		end;       		       	// Clear out the tool time base var       	self.toolTimeBase := nil;       end,     DoOptionsButton:       func( item )       begin       	if kDebugOn then       		:DebugPrint( "In DoOptionsButton", item );              	if item.type = kToolExtraSymbol then       		begin       			local theExtrasFloater := BuildContext( GetLayout("Generic Tool Floater.lyt") );       			local toolManager := item.manager;       			       			// Setup the title       			local instanceName := toolManager:GetCommToolName();              			try       				// Setup a couple of slots and open the view       				theExtrasFloater.context := toolTimeBase;       				theExtrasFloater.toolManager := toolManager;       				theExtrasFloater.childTemplate := toolManager:GetToolExtrasTemplate();       				theExtrasFloater.floaterTitle := ParamStr( kExtraFloaterTitleString, [instanceName] );       				theExtrasFloater:Open();       			onexception |evt.ex| do       				nil;       		end;       	else if item.type = kToolInfoSymbol then       		begin       			local theExtrasFloater := BuildContext( GetLayout("Generic Tool Floater.lyt") );       			local toolManager := item.manager;       			       			// Setup the title       			local instanceName := toolManager:GetCommToolName();              			try       				// Setup a couple of slots and open the view       				theExtrasFloater.context := toolTimeBase;       				theExtrasFloater.toolManager := toolManager;       				theExtrasFloater.childTemplate := toolManager:GetToolInfoTemplate();       				theExtrasFloater.floaterTitle := ParamStr( kInfoFloaterTitleString, [instanceName] );       				theExtrasFloater:Open();       			onexception |evt.ex| do       				nil;       		end;       	else if item.type = kEndpointExtraSymbol then       		begin	       			local theInstance := item.instance;       			local theExtrasFloater := BuildContext( GetLayout("Generic Tool Floater.lyt") );              			// Setup the title       			local instanceName := theInstance:GetInstanceName();              			try       				// Setup a couple of slots and open the view       				theExtrasFloater.toolInstance := theInstance;       				theExtrasFloater.context := toolTimeBase;       				theExtrasFloater.childTemplate := theInstance:GetEndpointExtrasTemplate();       				theExtrasFloater.floaterTitle := ParamStr( kExtraFloaterTitleString, [instanceName] );       				theExtrasFloater:Open();       			onexception |evt.ex| do       				nil;       		end;       	else if item.type = kEndpointInfoSymbol then       		:OpenEndpointInfo( item.instance, 'user );       	else if item.type = kSendDataSymbol then       		begin       			if call kViewIsOpenFunc with (sendModeFloater) then       				sendModeFloater:Close();       			       			sendModeFloater:Open();       		end;       	else if item.type = kReceiveDataSymbol then       		begin       			if call kViewIsOpenFunc with (receiveModeFloater) then       				receiveModeFloater:Close();       			       			receiveModeFloater:Open();       		end;       	else if item.type = kLinkEndpointsSymbol then       		begin       			if call kViewIsOpenFunc with (linkEndpointsFloater) then       				linkEndpointsFloater:Close();       				       			linkEndpointsFloater:Open();       		end;       end,     viewScrollUpScript:       func()       begin       	terminalView:PageUp();       end,     EndpointConnected:       func( theToolInstance )       begin       	// Open the information floater       	:OpenEndpointInfo( theToolInstance, 'connect );              	// If we are in test mode and either the send or receive floater is open,       	// then let it know that a new endpoint is ready.       	// If we are in terminal mode, then tell the send button to update itself.       	if :GetViewMode() = kTestModeSymbol then       		begin       			if call kViewIsOpenFunc with (sendModeFloater) then       				sendModeFloater:EndpointConnected( theToolInstance );       				       			if call kViewIsOpenFunc with (receiveModeFloater) then       				receiveModeFloater:EndpointConnected( theToolInstance );       		end;       	else if :GetViewMode() = kTerminalModeSymbol then       		begin       			// Notify the send button       			inputSendButton:EndpointConnected( theToolInstance );       		end;       		       	// Tell the endpoint what the view mode is       	theToolInstance:DoChangeViewMode( :GetViewMode() );       		       	// Print a notification to the terminal view so the user knows when the endpoint       	// was connected       	local instanceName := theToolInstance:GetInstanceName();       	terminalView:AddHeader( ParamStr( kEndpointConnectedLogString, [instanceName]) );              	// Increment the count of connected items       	toolTimeBase.connectedCount := toolTimeBase.connectedCount + 1;       end,     GetConnectionButtonList:       func()       begin       	local preflightItems := [];       	local postFlightItems := [];       	local endpointItems := [];       	local connectedItems := [];       	       	local popupList := [];       	       	// Loop through the current tool managers and build up the connected item list       	foreach toolManager in toolTimeBase.toolManagers do       		begin       			// Try and grab any preflight items and add them to the list       			local thePreflightName := toolManager:?GetPreflightName();       			if thePreflightName then       				AddArraySlot( preflightItems, {item: thePreflightName, toolManager: toolManager, type: kPreflightTypeSymbol} );              			// Try and grab any Postflight items and add them to the list       			local thePostflightName := toolManager:?GetPostflightName();       			if thePostflightName then       				AddArraySlot( postflightItems, {item: thePostflightName, toolManager: toolManager, type: kPostflightTypeSymbol} );              			// Then the correct comm tool endpoint name to the list       			local theName := toolManager:?GetEndpointName();       			if theName then       				begin       					local connectString := ParamStr( kConnectItemString, [theName] );       					AddArraySlot( endpointItems, {item: connectString, toolManager: toolManager, type: kEndpointTypeSymbol} );       				end;              			// Finally, add any connected tool instances to the list       			local toolInstances := toolManager:GetToolInstances();       			foreach toolInstance in toolInstances do       				begin       					if toolInstance:IsConnected() then       						begin       							local theInstanceName := toolInstance:GetInstanceName();       							local disconnectString := ParamStr( kDisconnectItemString, [theInstanceName] );       							AddArraySlot( connectedItems, {item: disconnectString, toolInstance: toolInstance, type: kConnectedTypeSymbol} );       						end;       					end;       		end;       	       	// Add the preflight items to the popup list       	if Length( preflightItems ) > 0 then       		begin       			ArrayMunger( popupList, Length(popupList), nil, preflightItems, 0, nil );       		end;              	// Add the postflight items to the popup list       	if Length( postFlightItems ) > 0 then       		begin       			if Length( popupList ) > 0 then       				AddArraySlot( popupList, 'pickSeparator );       				       			ArrayMunger( popupList, Length(popupList), nil, postFlightItems, 0, nil );       		end;              	// Add the endpoints to the popup list       	if Length( endpointItems ) > 0 then       		begin       			if Length( popupList ) > 0 then       				AddArraySlot( popupList, 'pickSeparator );       				       			ArrayMunger( popupList, Length(popupList), nil, endpointItems, 0, nil );       		end;              	// Add the connected items to the popup list       	if Length( connectedItems ) > 0 then       		begin       			if Length( popupList ) > 0 then       				AddArraySlot( popupList, 'pickSeparator );              			ArrayMunger( popupList, Length(popupList), nil, connectedItems, 0, nil );       		end;       		       	// Add the disconnect all item       	if Length( connectedItems ) > 1 then       		begin       			AddArraySlot( popupList, 'pickSeparator );              			AddArraySlot( popupList, {item: kDisconnectAllItemString, type: kDisconnectAllTypeSymbol} );       		end;       		       	// return the popup list       	popupList;       end,     toolTimeBase: nil,     NotifyAlert:       func( string, name )       begin       	// If toolTimeBase does not exist then the user has closed       	// the application       	if NOT toolTimeBase then       		return;       		       	GetRoot():Notify( kNotifyAlert, name, string );       end,     declareSelf: 'base,     viewSetupFormScript:       func()       begin       	// Set this view to be the key view       	SetKeyView( self, nil );       	       	// get a ref to the preferences       	self.preferencesFrame := GetAppPrefs( kAppSymbol, kPrefsSoupTemplate );       	       	self.connectedCount := 0;       	       	// Set up the currentViewMode slot.  THis must be done here so that the input view       	// and the terminal view can set themselves up correctly.       	if preferencesFrame.viewMode then       		self.currentViewMode := preferencesFrame.viewMode;       	else       		self.currentViewMode := kTerminalModeSymbol;       	       	// This is necessary so we set variables in the right place       	self.toolTimeBase := self;       	self.powerOffFlag := nil;       	self.doingEmergencyShutdown := nil;       	       	// Create and setup the tool managers if they exist       	local theToolManagers := GetGlobalVar( kToolTimeRegistrySymbol );       	if theToolManagers then       		self.toolManagers := foreach toolManagerFrame in theToolManagers collect       										begin       											// Grab the preferences for this tool       											local thePrefs := :GetPreferenceItem( [pathExpr: kModulePrefsSlotSymbol, toolManagerFrame.symbol] );       											       											// Create a new instance of the manager and add it to the array       											toolManagerFrame:New( self, thePrefs );       										end;       	else       		self.toolManagers := [];       end,     routeScripts:       [       	{       		title:			kClearScreenText,       		routeScript:	func( target, targetView )       							begin       								GetRoot().(kAppSymbol).terminalView:ClearScreen();       							end,       	},       	{       		GetTitle:		func(target)       							begin       								local theMode := GetRoot().(kAppSymbol):GetViewMode();       								       								if theMode = kAnalyzeModeSymbol then       									kPrettyPrintText;       								else       									kPrintToInspectorText;       							end,       		routeScript:	func( target, targetView )       							begin       								GetRoot().(kAppSymbol).terminalView:PrintScreen();       							end,       	},       ],     EmergencyShutdown:       func()       begin       	doingEmergencyShutdown := true;       	       	// Shut down each tool synchronously       	foreach toolManager in toolTimeBase.toolManagers do       		begin       			try       				if NOT toolManager:ReadyToDispose() then       					toolManager:EmergencyShutdown();       			onexception |evt.ex| do       				nil;       		end;       	       	doingEmergencyShutdown := nil;       end,     DoConnectionButton:       func( itemFrame )       begin       	if kDebugOn then       		:DebugPrint( "In DoConnectionButton", itemFrame );       	       	// Figure out what type of request this is, and execute.       	if itemFrame.type = kEndpointTypeSymbol then       		begin       			local theToolManager := itemFrame.toolManager;       			local theConnectFloater := BuildContext( GetLayout("Connect Floater.lyt") );       			       			try       				// Setup a couple of slots and open the view       				theConnectFloater.toolManager := theToolManager;       				theConnectFloater.context := toolTimeBase;       				theConnectFloater:Open();       			onexception |evt.ex| do       				:NotifyAlert( kConnectFloaterErrorString, kAppName );       		end;       	else if itemFrame.type = kConnectedTypeSymbol then       		begin       			// Tell the state machine to disconnect       			itemFrame.toolInstance:Disconnect();       		end;       	else if itemFrame.type = kPreflightTypeSymbol then       		begin       			// Tell the tool to start the connection       			itemFrame.toolManager:?DoPreflight();       		end;       	else if itemFrame.type = kPostflightTypeSymbol then       		begin       			// Tell the tool to end the connection       			itemFrame.toolManager:?DoPostFlight();       		end;       	else if itemFrame.type = kDisconnectAllTypeSymbol then       		begin       			// Iterate over all the connected tools and disconnect them       			foreach manager in toolTimeBase.toolManagers do       				begin       					local theInstances := manager:GetToolInstances();       					       					foreach instance in theInstances do       						begin       							if instance:IsConnected() then       								instance:Disconnect();       						end;       				end;       		end;       end,     UnrememberOpenView:       func( theView )       begin       	SetRemove( toolTimeBase.rememberedViews, theView );       end,     doingEmergencyShutdown: nil,     viewClass: 74 /* clView */,     currentViewMode: kTerminalModeSymbol,     NotifyError:       func( string, theException, theInstance )       begin       	// If toolTimeBase does not exist then the user has closed       	// the application       	if NOT toolTimeBase then       		return;       		       	// If the user is supressing the alert dialogs, then ignore this error.       	if :GetPreferenceItem( kSupressAlertPathName ) then       		return;       		       	local realError;       	       	// Check and see if error is an exception frame       	if theException AND IsFrame( theException ) then       		begin       			if theException.error then       				realError := theException.error       			else if theException.data then       				realError := theException.data;       			else if theException.exception then       				realError := theException.exception;       		end;       	else       		realError := theException;       		       	// If realError is not nil, then lookup the system error string and display it.       	// Otherwise just display the string that was passed in.       	if realError AND IsInteger(realError) then       		begin       			local toolErrorString := theInstance:?TranslateError( realError );       			       			// Then print it out like this:     "<Tool Error String>; <string argument> (<error code>)"       			:NotifyAlert( ParamStr( "^?0^0; ||^1 (^2)", [toolErrorString, string, NumberStr(realError)] ), theInstance:GetInstanceName() );       		end       	else       		:NotifyAlert( kUnknownErrorString, theInstance:GetInstanceName() );       end,     preferencesFrame: nil,     rememberedViews: nil,     OpenEndpointInfo:       func( theToolInstance, theReason )       begin       	// Open the endpoint information slip if one is defined       	local theTemplate := theToolInstance:GetEndpointInfoTemplate( theReason );       	if theTemplate then       		begin       			local theInfoFloater := BuildContext( GetLayout("Generic Tool Floater.lyt") );              			// Grab the instance name       			local instanceName := theToolInstance:GetInstanceName();              			try       				// Setup a couple of slots and open the view       				theInfoFloater.toolInstance := theToolInstance;       				theInfoFloater.childTemplate := theTemplate;       				theInfoFloater.floaterTitle := ParamStr( kInfoFloaterTitleString, [instanceName] );       				theInfoFloater.context := toolTimeBase;       				theInfoFloater:Open();       			onexception |evt.ex| do       				nil;       		end;       end,     IsProfiling:       func()       begin       	:GetPreferenceItem( kProfilePathName );       end,     KeyScrollDownLine:       func( keyView )       begin       	terminalView:LineDown();       end,     viewSetupChildrenScript:       func()       begin       	// Clear out the analyzer links.       	self.analyzeLinkArray := nil;       	       	if :GetViewMode() = kTerminalModeSymbol then       		begin       			// Make sure that both the inputView and inputSendButton       			// open.       			if band( inputView.viewFlags, vVisible ) = 0 then       				inputView.viewFlags := bor( inputView.viewFlags, vVisible );       				       			if band( inputSendButton.viewFlags, vVisible ) = 0 then       				inputSendButton.viewFlags := bor( inputSendButton.viewFlags, vVisible );				       		end;       	else       		begin       			// Make sure that both the inputView and inputSendButton       			// do not open.       			if band( inputView.viewFlags, vVisible ) = 1 then       				inputView.viewFlags := bxor( inputView.viewFlags, vVisible );       				       			if band( inputSendButton.viewFlags, vVisible ) = 1 then       				inputSendButton.viewFlags := bxor( inputSendButton.viewFlags, vVisible );				       		end;       end,     GetPreferenceItem:       func( path )       begin       	if kDebugOn then       		:DebugPrint( "In GetPreferenceItem", [path] );              	// return the preference item       	toolTimeBase.preferencesFrame.(path);       end,     powerOffFlag: nil    };baseView_v229_0 :=    {title: kAppName,     viewBounds: {left: 0, top: 0, right: 100, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(baseView, baseView_v229_0);inputView :=    {viewBounds: {left: 8, top: -54, right: -60, bottom: -22},     viewJustify: 8388784,     viewSetupFormScript:       func()       begin       	SetKeyView( self, 0 );       	       	textFlags := textFlags + vSingleKeystrokes;       	       	inherited:?viewSetupFormScript();		// this method is defined internally       end,     viewFlags: 14848,     _proto: @185 /* protoInputLine */    };AddStepForm(baseView, inputView);StepDeclare(baseView, inputView, 'inputView);inputSendButton :=    {     buttonClickScript:       func()       begin       	// Notify the user if there are no items to popup.  If there is only one       	// item, then don't popup the list, just send the data.  If there is       	// more than one item, then popup the list.       	if Length( self.popup )	= 0 then       		begin       			:NotifyAlert( kNoConnectedToolsString, kAppName );       			:Hilite(nil);       		end;       	else if Length( self.popup ) = 1 then       		begin       			:SendInputLine( self.popup[0].instance );       			:Hilite(nil);       		end;       	else       		inherited:?ButtonClickScript();       end,     text: kSendButtonString,     viewBounds: {left: -55, top: -46, right: -8, bottom: -30},     viewJustify: 8388774,     viewFlags: 514,     popup: [],     pickActionScript:       func(itemSelected)       begin       	local theInstance := popup[itemSelected].instance;       	       	// Send the data       	:SendInputLine( theInstance );       	       	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button       end,     EndpointConnected:       func( theToolInstance )       begin       	// Recreate the popup list       	self.popup := :CreatePopupList();       	       	self:SyncView();       end,     EndpointDisconnected:       func( theToolInstance )       begin       	// Find this instance in the list and remove it.       	// The tool may have already been removed from the list if there       	// were multiple tools connected and the user selected "Disconnect All".       	if Length( self.popup ) > 0 then       		begin       			local pos := LSearch( self.popup, theToolInstance, 0, '|=|, 'instance );       			RemoveSlot( self.popup, pos );       	       			self:SyncView();       		end;       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	// This must be done because the inherited viewSetupFormScript       	// modifies this value       	RemoveSlot( self, 'text );       	       	// Create the popup list       	self.popup := :CreatePopupList();              	// This is a real hack since I looked in the source to see exactly how       	// this button works!       	if Length( self.popup ) > 1 then       		inherited:?viewSetupFormScript();       		       	// Setup the bounds for the correct width.       	// We have to do this after calling the inherited method       	// because it may change the text slot.       	local width := StdButtonWidth( self.text );       	self.viewBounds := Clone( self.viewBounds );       	self.viewBounds.left := self.viewBounds.right - width;       end,     CreatePopupList:       func()       begin       	local theArray := [];       	       	// Create the popup from the connected tool instances       	foreach manager in toolTimeBase.toolManagers do       		begin       			local instances := manager:GetToolInstances();       			       			foreach instance in instances do       				begin       					if instance:IsConnected() then       						AddArraySlot( theArray, {item: instance:GetInstanceName(), instance: instance} );       				end;       		end;	              	// return the list       	theArray;       end,     viewDrawScript:       func()       begin       	// This is a real hack since I looked in the source to see exactly how       	// this button works!       	if Length( self.popup )	> 1 then       		inherited:?viewDrawScript();       end,     SendInputLine:       func( theInstance )       begin       	local theString := inputView.text;       	local theManager := GetVariable( theInstance, 'toolManagerBase );              	// Let the manager instance preflight the data if it wants to       	// if not, then just append a CR to the data and let the state       	// machine handle sending the data.       	if theManager:PreflightTerminalOutput EXISTS then       		theString := theManager:PreflightTerminalOutput( theString );       	else       		theString := theString & unicodeCR;       			       	// Tell the instance to output the new data       	theInstance:DoOutput( theString, nil, {form: 'string} );              	if :GetPreferenceItem( kClearTerminalPathName ) then       		SetValue( inputView, 'text, "" );       end,     _proto: @386 /* protoPopupButton */    };AddStepForm(baseView, inputSendButton);StepDeclare(baseView, inputSendButton, 'inputSendButton);terminalView :=    {     ChangeFont:       func( newFont )       begin       	// If the font has not changed then just return, otherwise change the font.       	if newFont.family <> viewFont.family OR       	   newFont.face <> viewFont.face OR       	   newFont.size <> viewFont.size then       		begin       			// Short circuit the case where there are no characters       			local characters := :GetCountCharacters();       			if characters = 0 then       				return;       			else       				begin       					// Iterate over the lines of text and only changes those that aren't headers       					local currentPos := 0;						       					while (currentPos < characters) do       						begin       							local lineRange := :GetLineRange(currentPos);       							local rangeData := :GetRangeData( lineRange, 'styles ) ;              							if rangeData[1] <> kHeaderViewFont then       								:ChangeRangeRuns( lineRange, newFont, nil, nil );       								       							// Move on to the next line of data       							currentPos := lineRange.last + 1;       						end;       				       					// Update some important slots       					viewFont := TotalClone( newFont );       					viewLineSpacing := GetFontSize( newFont ) + 2;       					viewPageHeight := :GetNormalizedPageHeight( :LocalBox() );       				end;       		end;       end,     viewSetupDoneScript:       func()       begin       	// if the user has choosen a font then use that font, otherwise default to       	// whats hardcoded in the viewFont slot.       	if preferencesFrame.font then        		begin       			self.viewFont := TotalClone( preferencesFrame.font );       			self.viewLineSpacing := GetFontSize( preferencesFrame.font ) + 2;       		end;              	// Used in our GetTextHeight method. It is cached in a slot for speed reasons       	self.ourGlobalBoxTopCoordinate :=  :GlobalBox().top;              	// Calcluate the page height and the page width.       	local bounds := :LocalBox();       	local pageWidth := bounds.right - bounds.left;              	viewPageHeight := :GetNormalizedPageHeight( bounds );       	       	// Set the geometry of the view.  kPageHeight is a ridiculously large number because       	// resetting the geometry everytime new text comes in is very time consuming.       	// In a real app this should probably be smarter       	:?SetGeometry( nil, pageWidth, kPageHeight, {top: 0, left: 0, right: 0, bottom: 0} );       	       	// index keeps track of where to start placing new text as it comes in.       	index := 0;       	       	// Create an instance of the object printer.  This object is used to convert different       	// NewtonScript objects into text form       	objectPrinterInstance := GetLayout("protoObjectPrinter"):Instantiate( self );       	       	inherited:?viewSetupDoneScript();       end,     PageUp:       func()       begin       	:Scroll( {x: 0, y: -viewPageHeight+(2*viewLineSpacing)} );       end,     viewFormat: 12625,     viewLineSpacing: 12,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	self.viewPageHeight := nil;       	self.viewFont := nil;       	self.viewLineSpacing := nil;              	// get rid of the object printer       	objectPrinterInstance:Dispose();       	objectPrinterInstance := nil;       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     PrintScreen:       func()       begin       	// Short circuit the case where there are no characters       	local characters := :GetCountCharacters();       	if characters = 0 then       		return;       	else if :GetViewMode() = kAnalyzeModeSymbol then       		:DoPrettyPrint();       	else       		begin       			// Iterate over the lines of text and print out each line.       			// Handle each line separately so that we don't run out of heap       			local currentPos := 0;						       			while (currentPos < characters) do       				begin       					local lineRange := :GetLineRange(currentPos);       					local rangeData := :GetRangeData( lineRange, 'text ) ;              					// print out this bit of text       					write( rangeData );       											       					// Move on to the next line of data       					currentPos := lineRange.last + 1;       				end;       		end;       end,     viewFlags: 1,     viewBounds: {left: 8, top: 20, right: -8, bottom: -25}     ,     viewPageHeight: nil,     index: nil,     _proto: @826 /* protoTXView */,     AddObject:       func( object, instanceName )       begin       	// doingEmergencyShutdown is a variable of the base view       	if doingEmergencyShutdown then       		return;              	// Add the header text, then go ahead and send the object to the object printer       	:AddHeader( instanceName );       	       	// Short Circuit string cause its an easy case       	if ClassOf( object ) = 'string then       		begin       			:AddBody( object );              			// This will slow down performance, but we need to try and keep the current text at the bottom       			// protoTXView autoscrolls stuff to the middle of the view       			local currentY := :GetScrollValues().y;       			local target := :GetTextHeight()-viewPageHeight - currentY;       			:Scroll( {y: target, x: 0} );       		end;       	else       		objectPrinterInstance:PrintObject( object, ""&unicodeCR );       end,     viewJustify: 240,     ourGlobalBoxTopCoordinate: nil,     viewSetupFormScript:       func()       begin       	// Setup the default view bounds based on the current view mode       	if :GetViewMode() = kTerminalModeSymbol then       		self.viewBounds := SetBounds( 8, 20, -8, -60 );       	else       		self.viewBounds := SetBounds( 8, 20, -8, -25 );              	// Setup the store so that txview saves to a VBO       	:?SetStore( GetStores()[0] );       	       	inherited:?viewSetupFormScript();       end,     ClearScreen:       func()       begin       	local characters := :GetCountCharacters();       	:Replace( {first: 0, last: characters}, {text: ""}, nil );       	index := 0;       end,     LineDown:       func()       begin       	local currentY := :GetScrollValues().y;       	local scrollDelta := viewLineSpacing;       	local textHeight := :GetTextHeight();              	// If a line scroll would exceed the height of the text, then       	// recalculate the scroll distance       	if currentY + viewPageHeight + scrollDelta >= textHeight then       		scrollDelta := textHeight - viewPageHeight - currentY;       	       	:Scroll( {x: 0, y: scrollDelta} );       end,     DoPrettyPrint:       func()       begin       end,     GetTextHeight:       func()       begin       	local chars := :GetCountCharacters();       	local maxInfo := :CharToPoint(chars);       	       	local globalY := maxInfo.y + maxInfo.lineHeight;       	       	// take the scroll position into consideration...       	globalY := globalY + :GetScrollValues().y;       	       	return globalY - ourGlobalBoxTopCoordinate;       end,     AddBody:       func( text )       begin       	// doingEmergencyShutdown is a variable of the base view       	if doingEmergencyShutdown then       		return;       		       	if StrFilled( text ) then       		begin       			:Replace( {first: index, last: index}, {text: text, styles: [StrLen(text), viewFont]}, nil );       			index := index + StrLen( text );       		end;       end,     AddHeader:       func( instanceName )       begin       	// doingEmergencyShutdown is a variable of the base view       	if doingEmergencyShutdown then       		return;              	if StrFilled( instanceName ) then       		begin       			local theName := instanceName & "\n";       			:Replace( {first: index, last: index}, {text: theName, styles: [StrLen(theName), kHeaderViewFont]}, nil );       			index := index + StrLen( theName );       		end;       end,     viewFont: simpleFont9,     LineUp:       func()       begin       	:Scroll( {x: 0, y: -viewLineSpacing} );       end,     objectPrinterInstance: nil,     PageDown:       func()       begin       	local currentY := :GetScrollValues().y;       	local scrollDelta := viewPageHeight-(2*viewLineSpacing);       	local textHeight := :GetTextHeight();              	// Recalculate the scroll delta if scrolling down would move us past       	// the end of the text.       	if currentY + (2*scrollDelta) >= textHeight then       		scrollDelta := textHeight - viewPageHeight - currentY;       	       	:Scroll( {x: 0, y: scrollDelta} );       end,     GetNormalizedPageHeight:       func( boundsRect )       begin       	// make sure that page height is a multiple of viewLineSpacing and return that value       	local numLines := (boundsRect.bottom - boundsRect.top) DIV viewLineSpacing;       	numLines * viewLineSpacing;       end    };AddStepForm(baseView, terminalView);StepDeclare(baseView, terminalView, 'terminalView);preferencesView := LinkedSubview(_v179_0,    {viewBounds: {left: 8, top: 15, right: 97, bottom: 49}});AddStepForm(baseView, preferencesView);StepDeclare(baseView, preferencesView, 'preferencesView);statusBar :=    {     menuLeftButtons:       [       	{       		_proto: 				protoInfoButton,       		DoInfoPrefs: 		func()       									preferencesView:Open(),       		DoInfoAbout: 		func()       									aboutView:Open(),       		GenInfoAuxItems:	func()       								begin       									local auxItems := [];       									       									foreach toolManager in toolTimeBase.toolManagers do       										begin       											if toolManager:?GetToolPrefsTemplate() then       												begin       													local theName := toolManager:GetCommToolName();       													AddArraySlot( auxItems, {item: ParamStr( kToolPrefItemString, [theName] ), manager: toolManager} );       												end;       										end;              									// return the aux items       									auxItems;       								end,       		DoInfoAux:			func( items, index )       								begin       									local thePrefsFloater := BuildContext( GetLayout("Generic Tool Floater.lyt") );       									local toolManager := items[index].manager;       									       									// Setup the title       									local instanceName := toolManager:GetCommToolName();       						       									try       										// Setup a couple of slots and open the view       										thePrefsFloater.context := toolTimeBase;       										thePrefsFloater.toolManager := toolManager;       										thePrefsFloater.childTemplate := toolManager:GetToolPrefsTemplate();       										thePrefsFloater.floaterTitle := ParamStr( kToolPrefsFloaterTitleString, [instanceName] );       										thePrefsFloater:Open();       									onexception |evt.ex| do       										nil;       									       								end,       	},       	{       		_proto: 						protoPopupButton,       		text:							kConnectButtonString,       		declareKey:					kConnectButtonSymbol,       		popup: 						[],       		viewSetupFormScript:		func()       			begin       				toolTimeBase.(self.declareKey) := self;       			end,       		buttonClickScript:		func()       			begin       				self.popup := :GetConnectionButtonList();       	       				if Length(popup) > 0 then       					Inherited:?buttonClickScript();       				else        					begin       						:NotifyAlert( kNoToolsInstalledString, kAppName );       						:Hilite( nil );       					end;       			end,       		pickActionScript:		func( index )       			begin       				:DoConnectionButton( popup[index] );       				       				inherited:?pickActionScript( index );       			end,       		viewQuitScript: 		func()       			begin       				RemoveSlot( toolTimeBase, self.declareKey );       			end,       	 },       	 {       		_proto:				protoPopupButton,       		text:					kDataOptionsText,       		popup:				[],       		buttonClickScript:	func()       			begin       				self.popup := :GetOptionsButtonList();       				       				// Notify the user if there are no items to popup       				if Length( self.popup ) = 0 then       					:NotifyAlert( kNoModeOptionsString, kAppName );       				       				inherited:?buttonClickScript();       			end,       		pickActionScript:	func( index )       			begin       				:DoOptionsButton( popup[index] );              				inherited:?pickActionScript( index );       			end,       	  }       ],     menuRightButtons:       // this is really hacky, and the app should probably disconnect automatically when       // the user closes it.       [        protoActionButton,        {        	_proto:			protoPopupButton,       	text:				kModeButtonText,       	popup:			kModeOptionsArray,       	viewSetupDoneScript:	func()       	begin       		// deep clone the popup so we can modify its contents       		self.popup := DeepClone( self.popup );       	       		// get the view mode from the parent       		local mode := :GetViewMode();       	       		// make sure the correct item is checked       		local item := nil;       		if mode then       			item := LFetch( self.popup, mode, 0, '|=|, 'symbol );       	       		// if we found and item then check it, otherwise check the first item in the popup array       		if item then       			item.mark := kCheckMarkChar;       		else       			self.popup[0].mark := kCheckMarkChar;       	end,       	pickActionScript: func( index )       	begin       		foreach item in popup do       			item.mark := nil;       			       		popup[index].mark := kCheckMarkChar;       		       		:ChangeViewMode( popup[index].symbol );       		inherited:?pickActionScript( index );       	end,        },              ],     viewSetupChildrenScript:       func()       begin       	// Insert the close box if we are not the background application       	if GetUserConfig( 'blessedApp ) <> kAppSymbol then       		begin       			// First get rid of any previous RAM version of the menuRightButtons array       			RemoveSlot( self, 'menuRightButtons );       			self.menuRightButtons := Clone( self.menuRightButtons );       			       			local theCloseBox :=         						{       						 	_proto: 					protoLargeClosebox,       							buttonClickScript:	func()       														begin       															// If there are any connected tools, display a modal dialog asking if the user       															// really wants to close the application.       															       															// If all tools are disconnected, or the user selected to disconnect from       															// the modal dialog, then do the normal close box behavior.  The       															// tools will be disconnected and disposed of in the application base       															// view's viewQuitScript method.       															local toolsDisconnected := true;       															foreach manager in toolTimeBase.toolManagers do       																begin       																	if NOT manager:ReadyToDispose() then       																		toolsDisconnected := nil;       																end;       															       															if toolsDisconnected OR :GetPreferenceItem( kAutoDisconnectPathName ) OR       																ModalConfirm( kReallyDisconnectString, 'yesNoDefaultYes ) then       																inherited:?buttonClickScript();       														end,       						 };              			ArrayInsert( self.menuRightButtons, theCloseBox, 0 );       		end;       		       	inherited:?viewSetupChildrenScript();       end,     _proto: @73 /* newtStatusBarNoClose */    };AddStepForm(baseView, statusBar);StepDeclare(baseView, statusBar, 'statusBar);sendModeFloater := LinkedSubview(testModeFloaterBase,    {viewBounds: {left: 100, top: 16, right: 172, bottom: 49}});AddStepForm(baseView, sendModeFloater);StepDeclare(baseView, sendModeFloater, 'sendModeFloater);receiveModeFloater := LinkedSubview(testModeFloaterBase,    {viewBounds: {left: 176, top: 16, right: 232, bottom: 48}});AddStepForm(baseView, receiveModeFloater);StepDeclare(baseView, receiveModeFloater, 'receiveModeFloater);aboutView := LinkedSubview(_v180_0,    {viewBounds: {left: 177, top: 0, right: 234, bottom: 15}});AddStepForm(baseView, aboutView);StepDeclare(baseView, aboutView, 'aboutView);linkEndpointsFloater := LinkedSubview(_v180_0,    {viewBounds: {left: 16, top: 0, right: 64, bottom: 16}});AddStepForm(baseView, linkEndpointsFloater);StepDeclare(baseView, linkEndpointsFloater, 'linkEndpointsFloater);// After Script for baseViewthisView := baseView;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Test Tool.lyt| := baseView;// End of file Test Tool.lyt
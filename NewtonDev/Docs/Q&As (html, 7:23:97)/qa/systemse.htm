<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: System Services, Find, and Filing</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: System Services, Find, and Filing</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="systemse.htm">System Services, Find, and Filing</H2></A><UL><A HREF="#Preventing_Selections_in_the_Find_Overview"><B> </B>Preventing Selections in the Find Overview  (2/5/96)<BR></A><A HREF="#Creating_Custom_Finders"><B> </B>Creating Custom Finders  (2/5/96)<BR></A><A HREF="#How_to_Interpret_Return_Value_of_BatteryStatus"><B> </B>How to Interpret Return Value of BatteryStatus  (5/6/96)<BR></A><A HREF="#How_to_Create_Application-specific_Folders"><B> </B>How to Create Application-specific Folders  (5/14/96)<BR></A><A HREF="#Changing_ProtoStatusButton_Text_in_ProtoStatusTemplate"><B> </B>Changing ProtoStatusButton Text in ProtoStatusTemplate  (1/15/97)<BR></A></UL><A NAME="Preventing_Selections_in_the_Find_Overview"><H3><HR><B> </B>Preventing Selections in the Find Overview  (2/5/96)</A></H3><DL><DD>Q:    When I use <CODE>ROM_compatibleFinder </CODE>in Newton 2.0, the overview of found items contains checkboxes for each item, allowing the user to attempt to route the found items.  Since my found items are not soup items, various exceptions are thrown.  How can I prevent the checkboxes?<BR><BR>A:    What you do depends on how you want to handle your data. There are basically two cases. The first case is when you want no Routing to take place (Routing refers to Delete, Duplicate, and the ability to move the data using transports like Beam or Print). The second case is when you want some or all of the Routing to occur.<BR><BR>    The first case is easy.  Just add a <CODE>SelectItem </CODE>slot to the result frame, set to <CODE>nil</CODE>.<BR>    For example:<BR><CODE><PRE>    AddArraySlot(results,           {_proto: ROM_compatibleFinder,            owner: self,            title: mytitle,            SelectItem: nil,   // prevents checkboxes            items: myresults});</PRE><BR></CODE>    The second case is more complex. The problem is that there are many variants. The best strategy is to override the appropriate methods in your finder to gain control at appropriate points. This may be as simple of overriding <CODE>Delete </CODE>to behave correctly, or as complex as replacing <CODE>GetTarget </CODE>and adding appropriate layouts. See the Newton DTS Q&amp;A "Creating Custom Finders" for more information.</DL><A NAME="Creating_Custom_Finders"><H3><HR><B> </B>Creating Custom Finders  (2/5/96)</A></H3><DL><DD>Q:    My application uses more than one soup, so <CODE>ROM_soupFinder </CODE>is not appropriate, but <CODE>ROM_compatibleFinder </CODE>seems to throw many exceptions. Which should I use?<BR><BR>A:    The answer depends on how much modification you will make. What you need is documentation on how they work and what you can override:<BR><BR>    Each of the finder base protos (soupFinder and compatibleFinder) are magic pointers, so can create your own customizations at compile time.<BR><BR>    So to do a <CODE>soupFinder</CODE> based item you could do something like:<BR><BR><CODE><PRE>DefConst('kMySoupFinder, {    _proto: ROM_soupFinder,    Delete: func()    begin        print("About to delete " & Length(selected) && "items") ;        inherited:Delete() ;    end,}) ;</PRE><BR></CODE><BR>    Most of these routines are only callable by your code. They should not be overwritten. Those routines that can be safely overriden are specified.<BR><BR>    Some of methods and slots are common to both types of finders:<BR><BR><CODE><PRE>finder.selected</PRE><BR></CODE>    An array of selected items stored in an internal format. All you can do with this array is figure out the number of selected items by taking the Length of this array.<BR><BR><CODE><PRE>finder:Count()</PRE><BR></CODE>    Returns an integer with the total number of found items.<BR><BR><CODE><PRE>finder:ReSync()</PRE><BR></CODE>    Resets the finder to the first item.<BR><BR><CODE><PRE>finder:ShowFoundItem(item)</PRE><BR></CODE>    Displays the item passed. item is an overview item that resides in the<BR>    overview's items array.<BR><BR><CODE><PRE>finder:ShowOrdinalItem(ordinal)</PRE><BR></CODE>    Display an item based on the symbol or integer passed in ordinal:<BR>    <CODE>'first </CODE>- the first found item<BR>    <CODE>'prev </CODE>- the previous item<BR>    <CODE>'next </CODE>- the next item<BR>    <CODE>&lt;an-integer&gt;</CODE> - display the nth item based on the integer.<BR><BR>    Under no circumstances should you call or override:<BR>        <CODE><PRE>        finder:MakeFoundItem</PRE><BR></CODE>        <CODE><PRE>        finder:AddFoundItems</PRE><BR></CODE><BR><BR><B>    ROM_SoupFinder<BR></B><BR>    SoupFinder has the following methods and slots:<BR><BR>    All the documented items from the simple use of soupFinder as documented in the Newton Programmer's Guide 2.0.<BR>    <BR><CODE><PRE>soupFinder:Reset()</PRE><BR></CODE>    Resets the soupFinder cursor to the first found entry. In general, you<BR>    should use the ReSync method to reset a finder.<BR>    <BR><CODE><PRE>soupFinder:ZeroOneOrMore()</PRE><BR></CODE>    Returns 0 if no found entries, 1 if one found entry or another number<BR>    for more than one entry.<BR><BR><CODE><PRE>soupFinder:ShowEntry(entry)</PRE><BR></CODE>    causes the finding application to display entry. This may involve<BR>    opening the application and moving it to that item.<BR>    This does not close the findOverview.<BR>        <BR><CODE><PRE>soupFinder:SelectItem(item)</PRE><BR></CODE>    mark the item as selected.<BR>    If this method is set to <CODE>nil </CODE>in the soupFinder proto, items will not have a checkbox in front of them (not selectable).<BR>    <BR><CODE><PRE>soupFinder:IsSelected(item)</PRE><BR></CODE>    Returns true if the item is selected.<BR>    <BR><CODE><PRE>soupFinder:ForEachSelected(callback)</PRE><BR></CODE>    Calls callback function with each selected item. The callback function has one argument, the entry from the soup cursor.<BR>    <BR><CODE><PRE>soupFinder:FileAndMove(labelsChanged, newLabel,storeChanged, newStore)</PRE><BR></CODE>    File and/or move the selected items.<BR>    <CODE>newLabel </CODE>is the new label if and only if <CODE>labelsChanged </CODE>is <CODE>true.<BR></CODE>    <CODE>newStore </CODE>is the new store if and only if <CODE>storeChanged </CODE>is <CODE>true.<BR></CODE>    <BR>    Developers can override this, though they may want to call the inherited routine to do that actual work. Note that <CODE>FileAndMove </CODE>can be called even if no items are selected. If you override this method you MUST check if there are selected items by doing:<BR>    <BR><CODE><PRE>    if selected then        // do the work</PRE><BR></CODE>    <BR><CODE><PRE>soupFinder:FileAs(labels)</PRE><BR></CODE>    Deprecated. Do not use.<BR>    <BR><CODE><PRE>soupFinder:MoveTo(newStore)</PRE><BR></CODE>    Deprecated. Do not use.<BR>    <BR><CODE><PRE>soupFinder:Delete()</PRE><BR></CODE>    Deletes all selected items from read/write stores.<BR>    <BR>    Developer can override. Note: if you override this, the crumple effect will<BR>    still happen. There is no way to prevent the ability to delete the items or<BR>    prevent the crumple effect at this time.<BR>    <BR><CODE><PRE>soupFinder:GetTarget()</PRE><BR></CODE>    Returns a cursor used by routing.<BR>    <BR>    The following methods should not be called or modified:<BR>    <CODE><PRE>    soupFinder.MakeFoundItemsoupFinder.AddFoundItems</PRE><BR></CODE><BR><BR><B>    ROM_CompatibleFinder<BR></B><BR><CODE><PRE>compatibleFinder:ShowFakeEntry(index)</PRE><BR></CODE>    Show the <CODE>index</CODE>'th item from the found items. Note that items will likely be an array of the found items.<BR>    <BR><CODE>    ShowFakeEntry </CODE>should behave just like <CODE>ShowFoundItem</CODE>. In other words, it should open the application then send a <CODE>ShowFoundItem </CODE>to the application.<BR>    <BR><CODE><PRE>compatibleFinder:ConvertToSoupEntry(item)</PRE><BR></CODE>    Return a soup entry that corresponds to the item. item is an item from the found items array.<BR><BR>    The following methods are defined to be the same as the soupFinder:<BR>        <CODE><PRE>        FileAs, MoveTo, Delete, IsSelected, SelectItem,    ForEachSelected, GetTarget, FileAndMove</PRE><BR></CODE>    <BR>    Note that this causes problems in some cases: most notably, the <CODE>ForEachSelected </CODE>call is expected to return an array of soup entries. The chances are you will need to override most of those methods. See <CODE>soupFinder </CODE>for a description of what the methods are supposed to do.</DL><A NAME="How_to_Interpret_Return_Value_of_BatteryStatus"><H3><HR><B> </B>How to Interpret Return Value of BatteryStatus  (5/6/96)</A></H3><DL><DD>Q:    I am trying to determine whether the Newton device is plugged in and to obtain other battery status information. Many slots have a <CODE>nil </CODE>value in the frame returned by the <CODE>BatteryStatus </CODE>global function. How do I interpret these values?<BR><BR>A:    A value of <CODE>nil </CODE>is returned if the underlying hardware cannot determine the correct information. Some hardware is limited in the amount of information that it can return. Future hardware may fill in more slots with authoritative non-nil values.<BR></DL><A NAME="How_to_Create_Application-specific_Folders"><H3><HR><B> </B>How to Create Application-specific Folders  (5/14/96)</A></H3><DL><DD>Q:    I would like to programmatically create folders so that they are available as soon as the application is open. What is the best approach to add application-specific folders?<BR><BR>A:    You can use the global functions <CODE>AddFolder</CODE> and <CODE>RemoveFolder</CODE> to modify the folder set for a given application.<BR><BR><CODE><PRE>AddFolder(newFolderStr, appSymbol)</PRE><BR>    newFolderStr </CODE>- string, the name of the new folder<BR><CODE>    appSymbol </CODE>- symbol, application for local folder<BR><CODE>    result </CODE>- symbol, the folder symbol of the newly added folder.<BR><BR><CODE>    AddFolder</CODE> takes a folder name and creates a new folder for the application.<BR><BR><CODE>    AddFolder</CODE> returns the symbol representing the tag value for the new folder.  Please note that the symbol may be different from the value returned by using <CODE>Intern()</CODE> on the string.  In particular, folder names with non-ASCII folders are supported.  If a folder with the name already exists, the symbol for the pre-existing folder is returned and a new folder is not created.<BR><BR>    There is a limit on the number of unique folders an application can support.  If the limit is exceeded, <CODE>AddFolder</CODE> returns <CODE>NIL</CODE> and a new folder is not added.  With the Newton 2.0 OS, the current limit is twelve global folders and twelve local folders.<BR><BR><CODE><PRE>RemoveFolder(folderSym, appSymbol)</PRE><BR>    folderSym </CODE>- symbol, the folder symbol of the folder to remove<BR>    <CODE>appSymbol </CODE>- symbol, the application for which to remove the folder<BR><CODE>    result </CODE>- undefined; do not rely on the return value of this function.<BR><BR><CODE>    RemoveFolder</CODE> can be used to remove a folder from the available list for an application. If items exist in a folder that is removed, the only way users can see the items is by selecting "All Items" from the folder list.<BR></DL><A NAME="Changing_ProtoStatusButton_Text_in_ProtoStatusTemplate"><H3><HR><B> </B>Changing ProtoStatusButton Text in ProtoStatusTemplate  (1/15/97)</A></H3><DL><DD>Q:    I am using a <CODE>protoStatusTemplate</CODE>-based view and am trying to rename the primary button through the <CODE>protoStatusTemplate</CODE>'s setup frame.  After doing this, I get an exception when I tap on the renamed button.  What am I doing wrong?<BR><BR>A:    You are not doing anything wrong.  There is a bug in <CODE>protoStatusTemplate</CODE> which will cause the primary button to function incorrectly if you do not include a <CODE>buttonClickScript</CODE> in the setup frame.<BR><BR>    When you specify a frame in the <CODE>primary</CODE> slot of the values frame of the setup, the primary button uses the <CODE>text</CODE> slot and the <CODE>buttonClickScript</CODE> slot of that frame to initalize itself.  Unfortunately, it does not check to see if either of those slots exist before trying to use them.   The result is that an exception is thrown when you tap the button.<BR><BR>    To work around this bug you must add a <CODE>buttonClickScript</CODE> to the primary frame.  From that method you will typically call your base view's <CODE>CancelRequest</CODE> method.<BR><BR>    Here is a code example:<BR><BR><CODE><PRE>// Add a buttonClickScript method which just calls the application's CancelRequest method.local viewSetValues :=  {    primary:         {        text: "Stop",         buttonClickScript: func() GetRoot().(kAppSymbol):CancelRequest('userCancel)        }    };                    local viewSet := {        appSymbol: kAppSymbol,         name: "The Name",         values: viewSetValues        };            // Setup the status templatestatusView:ViewSet( viewSet );</CODE></PRE></DL>
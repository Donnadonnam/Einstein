<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Validation and Editing in ProtoListPicker</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Validation and Editing in ProtoListPicker</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Validation and Editing in ProtoListPicker  (4/1/96)</H3><DL><DD>Q:    I am trying to use the <CODE>ValidationFrame </CODE>to validate and edit entries in a <CODE>protoListPicker</CODE>. When I edit certains slots I get an error that a path failed. All the failures occur on items that are nested frames in my soup entry. What is going on?<BR><BR>A:    The built-in validation mechanism is not designed to deal with nested soup information. In general, you gain better flexibility by not using a <CODE>validationFrame </CODE>in your pickerDef, even if you have no nested entries. Instead, you can provide your own validation mechanism and editors:<BR><BR>     Define a <CODE>Validate </CODE>method in your picker definition<BR>     Define an <CODE>OpenEditor </CODE>method in your picker definition<BR>     Draw a layout for each editor you require<BR><BR><CODE><PRE>pickerDef.Validate(nameRef, pathArray)</PRE><BR></CODE>    <CODE>nameRef </CODE>- nameRef to validate<BR>    <CODE>pathArray </CODE>- array of paths to validate in the nameRef<BR>    returns an array of paths that failed, or an empty array<BR>    <BR>    Validate each path in <CODE>pathArray </CODE>in the given nameRef. Accumulate a list of paths that are not valid and return them.<BR><BR>    The following example assumes that <CODE>pickerDef.ValidateName </CODE>and <CODE>pickerDef.ValidatePager </CODE>have been implemented:<BR><BR><CODE><PRE>pickerDef.Validate := func(nameRef, pathArray)begin    // keep track of any paths that fail    local failedPaths := [];                                                            foreach index, path in pathArray do    begin        if path = 'name then        begin            // check if name validation fails            if NOT :ValidateName(nameRef) then                // if so, add it to array of failures                AddArraySlot(failedPaths, path);        end;        else begin            if NOT :ValidatePager(nameRef) then                AddArraySlot(failedPaths, path);        end;    end;    // return failed paths or empty array    failedPaths;end;pickerDef.OpenEditor(tapInfo, context, why)</PRE><BR></CODE>    The arguments and return value are as per <CODE>OpenDefaultEditor</CODE>. However, you need to use this instead of <CODE>DefaultOpenEditor</CODE>.<BR><BR><CODE><PRE>pickerDef.OpenEditor := func(tapInfo, context, why)begin   local valid = :Validate(tapInfo.nameRef, tapInfo.editPaths) ;    if (Length(valid) &gt; 0) then        // if not valid, open the editor        // NOTE: returns the edit slip that is opened        GetLayout("editor.t"):new(tapInfo.nameRef,            tapInfo.editPaths, why, self, 'EditDone, context);    else    begin        // the item is valid, so just toggle the selection        context:Tapped('toggle);        nil;                                        // Return &lt;nil&gt;.    end;..end;</PRE><BR>    </CODE>The example above assumes that the layout "editor.t" has a <CODE>New </CODE>method that will open the editor and return the associated View.<BR><BR>    The editor can be designed to fit your data. However, we suggest that you use a <CODE>protoFloatNGo </CODE>that is a child of the root view created with the <CODE>BuildContext </CODE>function. You are also likely to need a callback to the pickderDef so it can appropriately update the edited or new item. Finally, your editor will need to update your data soup uing an "Xmit" soup method so that the listPicker will update.<BR><BR>    In the <CODE>OpenEditor </CODE>example above, the last three arguments are used by the editor to send a callback to the pickerDef from the <CODE>viewQuitScript</CODE>. The design of the callback function is up to you, here is an example:<BR><CODE><PRE>pickerDef.EditDone := func(nameRef, context)begin   local valid = :Validate(tapInfo.nameRef, tapInfo.editPaths) ;    if (Length(valid) &gt; 0) then    begin    // Something failed. Try and revert back to original        if NOT :ValidatePager(nameRef) AND            self.('[pathExpr: savedPagerValue, nameRef]) = nameRef             then            nameRef.pager := savedPagerValue.pager;                context:Tapped(nil);        // Remove the checkmark    end;    else        // The nameRef is valid, so select it.        context:Tapped('select);        // Clear the saved value for next time.    savedPagerValue := nil;        end;</CODE></PRE></DL>
#line 1 ":TNativeCalls.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h" #line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:ConfigGlobal.h" #line 17 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:CLibrary:stdlib.h"___toplevel        typedef unsigned int size_t;    typedef struct div_t { int quot, rem; } div_t;    typedef struct ldiv_t { long int quot, rem; } ldiv_t;                    extern double atof(const char *  );    extern int atoi(const char *  );    extern long int atol(const char *  );    extern double strtod(const char *  , char **  );    extern long int strtol(const char *  , char ** , int  );    extern unsigned long int strtoul(const char *  ,                                       char **  , int  );    extern int rand(void);    extern void srand(unsigned int  );    extern int _ANSI_rand(void);    extern void _ANSI_srand(unsigned int  );    extern void *calloc(size_t  , size_t  );    extern void free(void *  );    extern void *malloc(size_t  );    extern void *realloc(void *  , size_t  );    extern void abort(void);    extern int atexit(void (*  )(void));    extern void exit(int  );    extern char *getenv(const char *  );    extern int  system(const char *  );    extern void *bsearch(const void *key, const void *  ,              size_t  , size_t  ,              int (*  )(const void *, const void *));    extern void qsort(void *  , size_t  , size_t  ,           int (*  )(const void *, const void *));    extern int abs(int  );    extern div_t div(int  , int  );    extern long int labs(long int  );    extern ldiv_t ldiv(long int  , long int  );     #line 27 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:CLibrary:string.h"___toplevel     extern void *memcpy(void *  , const void *  , size_t  );    extern void *memmove(void *  , const void *  , size_t  );    extern char *strcpy(char *  , const char *  );    extern char *strncpy(char *  , const char *  , size_t  );    extern char *strcat(char *  , const char *  );    extern char *strncat(char *  , const char *  , size_t  );     extern int memcmp(const void *  , const void *  , size_t  );    extern int strcmp(const char *  , const char *  );    extern int strncmp(const char *  , const char *  , size_t  );    extern int strcoll(const char *  , const char *  );    extern size_t strxfrm(char *  , const char *  , size_t  );    extern void *memchr(const void *  , int  , size_t  );    extern char *strchr(const char *  , int  );    extern size_t strcspn(const char *  , const char *  );    extern char *strpbrk(const char *  , const char *  );    extern char *strrchr(const char *  , int  );    extern size_t strspn(const char *  , const char *  );    extern char *strstr(const char *  , const char *  );    extern char *strtok(char *  , const char *  );    extern void *memset(void *  , int  , size_t  );    extern char *strerror(int  );    extern size_t strlen(const char *  );     #line 32 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:CLibrary:stddef.h"___toplevel     typedef int ptrdiff_t;	      #line 37 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonTypes.h" 	  	typedef unsigned char	Boolean;typedef char			Char;			 typedef signed char		SChar;typedef unsigned char 	UChar;	typedef signed char		Byte;typedef signed char		SByte;typedef unsigned char	UByte;typedef short			Short;			 typedef signed short	SShort;typedef unsigned short	UShort;typedef long			Long;			 typedef signed long		SLong;typedef unsigned long	ULong;typedef signed long		FastInt;    									 	typedef unsigned short	UniChar;typedef UniChar			Character; 	typedef char*			Ptr;	typedef Ptr*			Handle;	typedef long			(*ProcPtr)();typedef long NewtonErr;		  typedef struct Int64{	SLong	hi;	ULong	lo;} Int64;	typedef long Fixed;	typedef long Fract; 	struct Point	{		short 	v;		short 	h;	};	typedef struct Point Point;	struct Rect	{		short	top;		short	left;		short	bottom;		short	right;	};	typedef struct Rect Rect;struct FPoint{	Fixed 	x;	Fixed	y;};typedef struct FPoint FPoint;struct FRect{	Fixed	left;	Fixed	top;	Fixed	right;	Fixed	bottom;};typedef struct FRect FRect; 	  	 		 				enum {  false_ ,  true_  };  typedef ULong	VAddr;typedef ULong	PAddr;typedef ULong	LAddr; typedef ULong	TObjectId;typedef ULong	HammerIORef;#line 45 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonWidgets.h" 	typedef Long ArrayIndex;	enum IndexValues { kEmptyIndex = -1 };			void ByteSwap (void* p, long count, long swapSize);			#line 49 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonTime.h" #line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Toolbox:CompMath.h" #line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Toolbox:ConfigToolbox.h" #line 17 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Toolbox:CompMath.h"void	CompAdd(const Int64* src, Int64* dst);void	CompSub(const Int64* src, Int64* dst);void	CompNeg(Int64* srcdst);void	CompShift(Int64* srcdst, long shift);void	CompMul(long src1, long src2, Int64* dst);long	CompDiv(const Int64* numerator, long denominator, long* remainder);void	CompFixMul(const Int64* compSrc, Fixed fixSrc, Int64* compDst);long	CompCompare(const Int64* a,const Int64* minusb);unsigned long CompSquareRoot(const Int64* src);#line 21 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonTime.h"enum{	kNoTimeout = 0,	kTimeOutImmediate = -1};typedef ULong	TTimeout;typedef ULong   THardwareTimeUnits;ULong		RealClockSeconds(void);			ULong		RealClock(void);							 			enum TimeUnits {			kSystemTimeUnits = (1),										kMicroseconds	= (5),										kMilliseconds	= (1000*kMicroseconds),			kMacTicks		= (16667*kMicroseconds),					kSeconds		= (1000*kMilliseconds),			kMinutes		= (60*kSeconds)		};		ULong		Ticks(void);							void		SetRealClock(ULong minutes);			void		SetRealClockSeconds(ULong seconds);		void		SleepTillTicks(ULong);					void 		Wait(ULong);																		#line 53 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonMemory.h" typedef long Size;typedef unsigned char HeapBlockType; typedef void *	Heap;	 NewtonErr		MemError(void);						  Ptr				NewPtr(Size size);Ptr				NewNamedPtr(Size size, ULong name);Ptr				NewPtrClear(Size byteCount);void			DisposPtr(Ptr p);Size			GetPtrSize(Ptr p);Ptr				ReallocPtr(Ptr, Size);			 Heap			PtrToHeap(Ptr); NewtonErr		LockPtr(Ptr);					 NewtonErr		UnlockPtr(Ptr); Ptr				NewWiredPtr(Size size);void			DisposeWiredPtr(Ptr); Handle			NewHandle(Size size);Handle			NewNamedHandle(Size size, ULong name);Handle			NewHandleClear(Size byteCount);void			DisposHandle(Handle h);Size			GetHandleSize(Handle h);NewtonErr		SetHandleSize(Handle h, Size size);void *			HLock(Handle h);void			HUnlock(Handle h);void			HSetState(Handle h, char savedCount);			 char			HGetState(Handle h);							 NewtonErr		HandToHand(Handle *hPtr);Handle			CopyHandle(Handle);void			MoveHHi(Handle);								 Heap			HandleToHeap(Handle); Handle			NewFakeHandle(void * address, Size size);Boolean			IsFakeHandle(Handle); TObjectId		GetPtrOwner(Ptr);void			SetPtrOwner(Ptr, TObjectId);TObjectId		GetHandleOwner(Handle);void			SetHandleOwner(Handle, TObjectId); ULong			GetPtrName(Ptr);void			SetPtrName(Ptr, ULong);ULong			GetHandleName(Handle);void			SetHandleName(Handle, ULong); HeapBlockType	GetPtrType(Ptr);void			SetPtrType(Ptr, HeapBlockType);HeapBlockType	GetHandleType(Handle);void			SetHandleType(Handle, HeapBlockType); Heap			GetHeap(void);				 void			SetHeap(Heap);				 NewtonErr		NewSegregatedVMHeap(	TObjectId	defaultDomain,		 										Size		ptrSize,			 										Size		handleSize,			 										Heap *		pResult,			 										ULong		options );			 NewtonErr		NewVMHeap(				TObjectId	defaultDomain,		 										Size		maxSize,			 										Heap *		pResult,			 										ULong		options);			 NewtonErr 		NewPersistentVMHeap(	TObjectId	domainId,													Size		maxSize,													Heap *		pResult,													ULong		options,													ULong		name);				NewtonErr 		DeletePersistentVMHeap(	ULong		name);				 enum{	 kHeapNotCacheable					= 0x00000001			,kPersistentHeap					= 0x40000000		};NewtonErr		NewHeapAt(				VAddr,							 										Size,							 										Heap * pResult);				 NewtonErr		ResurrectVMHeap(Heap oldHeap);							 NewtonErr		DestroyVMHeap(Heap   );						 NewtonErr		ShrinkHeapLeaving(Heap, Size amountLeftFree);			 NewtonErr		AddSemaphoreToHeap(Heap   );					 NewtonErr		ClobberHeapSemaphore(Heap   );					 NewtonErr		ZapHeap(Heap, ULong verification, Boolean isPersistent); Size			TotalFreeInHeap(Heap   );Size			LargestFreeInHeap(Heap   );unsigned long	CountFreeBlocks(Heap   );Size			TotalUsedInHeap(Heap   );Size			MaxHeapSize(Heap   );Size			GetHeapReleaseable(Heap   ); Size			TotalSystemFree(void);Size			SystemRAMSize(void); NewtonErr CheckHeap	(		Heap		opaque_heap,		 		void **		whereSmashed		 	); void BlockMove(const void * srcPtr, void * destPtr, Size byteCount);int  EqualBytes(const void *, const void *, Size);void FillBytes(void *, Size length, UChar pattern);void FillLongs(void *, Size length, ULong pattern);void ZeroBytes(void *, Size length);void XORBytes(const void * src1, const void * src2, void * dest, Size size); long		HeapSeed(Heap);int			NextHeapBlock				(	Heap			opaque_heap,		 					long			seed,				 					void *			fromBlock,			 					void **			pFoundBlock,		 					void ***		pFoundBlockHandle,	 					int *			pFoundBlockType,	 					char *			pFoundBlockTag,		 					Size *			pFoundBlockSize,	 					TObjectId *		pFoundBlockOwner	 				); enum{	 kMM_HeapSeedFailure		 	,kMM_InternalBlock			 	,kMM_HeapHeaderBlock		 	,kMM_HeapPtrBlock			 	,kMM_HeapHandleBlock		 	,kMM_HeapEndBlock			 	,kMM_HeapMPBlock			 	,kMM_HeapFreeBlock			 }; void SetMemMgrBreak ( long what, ... ); void CountHeapBlocks	(		Size *		pTotalSize,			 		ULong *		pFoundCount,		 		Heap		heap,				 		int			blockType,			 		ULong		name,				 		ULong		nameMask			 	); void *	GetHeapRefcon(Heap   );			 void	SetHeapRefcon(void *, Heap   );	 Heap	VoidStarToHeap(void *);						 void *	HeaptoVoidStar(Heap);						  #line 57 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonExceptions.h"      #line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:CLibrary:setjmp.h" ___toplevel    typedef int jmp_buf[ 22 ];                                  extern int  (setjmp( jmp_buf )) ;    extern void longjmp(jmp_buf  , int  );     #line 452 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonExceptions.h" 	  		  			 				 										 typedef char* ExceptionName;typedef ExceptionName ExceptionNamePtr;typedef void (*ExceptionDestructor)(void*);	void	Throw(ExceptionName name, void* data, ExceptionDestructor destructor);	void	ThrowMsg(char* msg);	int		Subexception(ExceptionName sub, ExceptionName super);	 						 			typedef struct Exception Exception; struct Exception{	ExceptionNamePtr		name;	void*					data;	ExceptionDestructor		destructor;};typedef struct CatchHeader CatchHeader; struct CatchHeader{	int				catchType;				 	CatchHeader*	next;};typedef struct ExceptionHandler ExceptionHandler; struct ExceptionHandler{	CatchHeader	header;	jmp_buf		state;	Exception	exception;};typedef struct ExceptionCleanup ExceptionCleanup;struct ExceptionCleanup{	CatchHeader		header;	void*			object;	void			(*function)(void*);};typedef struct ExceptionGlobals ExceptionGlobals;struct ExceptionGlobals{	CatchHeader*	firstCatch;};void	AddExceptionHandler(CatchHeader *i);void	ExitHandler(ExceptionHandler *i);void	NextHandler(ExceptionHandler *i);   extern const ExceptionName  evRootEvent   ; extern const ExceptionName  exRootException  ; extern const ExceptionName  exSkia  ; extern const ExceptionName  exMsgException  ; extern const ExceptionName  exDivideByZero  ;  extern const ExceptionName  exAbort  ; extern const ExceptionName  exBusError  ; extern const ExceptionName  exAlignment  ; extern const ExceptionName  exIllegalInstr  ; extern const ExceptionName  exPermissionViolation  ; extern const ExceptionName  exWriteProtected  ; extern const ExceptionName  exOutOfStack  ; enum{	 kExceptionHandler				= 0,	 	 kExceptionCleanup				= 1,	 	 kExceptionCleanupDone			= 2,	 	 kExceptionMonitorBoundary		= 3,	 	 kExceptionNonUserBoundary		= 4		 };			extern void* GetGlobals(void);		extern void SetGlobals(void* structure);		void	RemoveExceptionHandler(CatchHeader *i);void	InitializeExceptionGlobals(ExceptionGlobals* globals);#line 61 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonDebug.h" #line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:CLibrary:stdio.h" ___toplevel      typedef char *__va_list[1];        typedef struct __fpos_t_struct{ unsigned long __lo;} fpos_t;    typedef struct __FILE_struct FILE;             	             extern FILE __stdin, __stdout, __stderr;            extern int remove(const char *  );    extern int rename(const char *  , const char *  );    extern FILE *tmpfile(void);    extern char *tmpnam(char *  );    extern int fclose(FILE *  );    extern int fflush(FILE *  );    extern FILE *fopen(const char *  , const char *  );    extern FILE *freopen(const char *  , const char *  ,                     FILE *  );    extern void setbuf(FILE *  , char *  );    extern int setvbuf(FILE *  , char *  ,                   int  , size_t  );    extern int fprintf(FILE *  , const char *  , ...);    extern int printf(const char *  , ...);    extern int sprintf(char *  , const char *  , ...);    extern int fscanf(FILE *  , const char *  , ...);    extern int scanf(const char *  , ...);    extern int sscanf(const char *  , const char *  , ...);    extern int vprintf(const char *  , __va_list  );    extern int vfprintf(FILE *  ,                   const char *  , __va_list  );    extern int vsprintf(char *  , const char *  , __va_list  );    extern int fgetc(FILE *  );    extern char *fgets(char *  , int  , FILE *  );    extern int fputc(int  , FILE *  );    extern int fputs(const char *  , FILE *  );    extern int getc(FILE *  );    extern int (getchar)(void);    extern char *gets(char *  );    extern int putc(int  , FILE *  );    extern int (putchar)(int  );    extern int puts(const char *  );    extern int ungetc(int  , FILE *  );    extern size_t fread(void *  ,                    size_t  , size_t  , FILE *  );    extern size_t fwrite(const void *  ,                    size_t  , size_t  , FILE *  );    extern int fgetpos(FILE *  , fpos_t *  );    extern int fseek(FILE *  , long int  , int  );    extern int fsetpos(FILE *  , const fpos_t *  );    extern long int ftell(FILE *  );    extern void rewind(FILE *  );    extern void clearerr(FILE *  );    extern int feof(FILE *  );    extern int ferror(FILE *  );    extern void perror(const char *  );     #line 29 "::NewtonDev:C++:NCT_Projects:DDKIncludes:NewtonDebug.h"					long TapFileCntl(long cmd, void *);	void SendTestResult(long size, void *);	void SendDebugLine(int, const char*, ...); 																											 #line 65 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Newton.h"#line 28 ":TNativeCalls.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Frames:Objects.h" #line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Frames:ConfigFrames.h" #line 17 "::NewtonDev:C++:NCT_Projects:DDKIncludes:Frames:Objects.h"const long kRefTagBits = 2;const long kRefValueBits = 30;const long kRefValueMask = -1 << kRefTagBits;const long kRefTagMask = ~kRefValueMask;const long kRefImmedBits = 2;const long kRefImmedMask = -1 << kRefImmedBits;enum {	kTagInteger,	kTagPointer,	kTagImmed,	kTagMagicPtr,	kImmedSpecial = 0,	kImmedChar,	kImmedBoolean,	kImmedReserved};typedef long Ref;const Ref	NILREF =  ((((((long) ( 0 )) << kRefImmedBits) | ((long) ( kImmedSpecial ))) << kRefTagBits) | kTagImmed) ;const Ref	TRUEREF =  ((((((long) ( 1 )) << kRefImmedBits) | ((long) ( kImmedBoolean ))) << kRefTagBits) | kTagImmed) ;const Ref	FALSEREF = NILREF;	const Ref	kSymbolClass =  ((((((long) ( 0x5555 )) << kRefImmedBits) | ((long) ( kImmedSpecial ))) << kRefTagBits) | kTagImmed) ;const Ref	kFuncClass =  ((((((long) ( 3 )) << kRefImmedBits) | ((long) ( kImmedSpecial ))) << kRefTagBits) | kTagImmed) ;			extern int _RINTError(Ref r), _RCHARError(Ref r);inline long	RINT(Ref r)		{ return  ( (((Ref) ( r )) & ~kRefValueMask)  == kTagInteger)  ?  (((Ref) ( r )) >> kRefTagBits)  : _RINTError(r); }inline UniChar XRCHAR(Ref r)	{ return  ( ( (((Ref) ( r )) & ~kRefValueMask)  == kTagImmed)  && ( ( (((Ref) ( r )) >> kRefTagBits)  & ~kRefImmedMask)  == kImmedChar))  ? (UniChar) ( (((Ref) ( r )) >> kRefTagBits)  >> kRefImmedBits)  : _RCHARError(r); }class TObjectIterator;struct RefHandle;class RefVar;typedef const RefVar& RefArg;typedef Ref (*MapSlotsFunction)(RefArg tag, RefArg value, ULong anything);struct RefHandle {	Ref		ref;	Ref		stackPos;};class RefVar {  public:	RefHandle* h;	inline	RefVar();	inline	~RefVar();	inline	RefVar(const Ref r);	inline	RefVar(const RefVar& o);	RefVar&	operator=(const RefVar& o)	{ h->ref = o.h->ref; return *this; }	RefVar&	operator=(const Ref r)		{ h->ref = r; return *this; }	operator long() const				{ return h->ref; }	inline	long	Length()											const;	inline	void	SetLength(long length)								const;	inline	ULong	ObjectFlags()										const;	inline	Ref		GetArraySlot(long slot)								const;	inline	void	SetArraySlot(long slot, RefArg value)				const;	inline	void	AddArraySlot(RefArg value)							const;	inline	Ref		GetFrameSlot(RefArg slot)							const;	inline	void	SetFrameSlot(RefArg slot, RefArg value)				const;	inline	int		FrameHasSlot(RefArg slot)							const;	inline	Ref		GetFramePath(RefArg thePath)						const;	inline	void	SetFramePath(RefArg thePath, RefArg value)			const;	inline	int		FrameHasPath(RefArg thePath)						const;	inline	Ref		Clone()												const;	inline	void	MapSlots(MapSlotsFunction func, ULong anything)		const;	inline	TObjectIterator*	NewIterator()							const;	inline	Ptr		BinaryData()										const;	inline	void	Lock()												const;	inline	void	Unlock()											const;	inline	Ref		Class()												const;	inline	void	SetClass(RefArg theClass)							const;};int		EQRef(Ref a, Ref b);inline int EQRefArg(RefArg a, RefArg b) { return EQRef(a, b); }struct ObjHeader {	char	_[8];};const int kObjSlotted = 1;				const int kObjFrame = 2;				const int kObjLocked = 16;				const int kObjReadOnly = 64;			const int kObjDirty = 128;				void	SetObjectHeapSize(long size, long allocateInTempMemory = 1);void	InitObjects(void);Ref		AllocateBinary(RefArg theClass, long length);Ref		AllocateArray(RefArg theClass, long length);Ref		AllocateFrame(void);Ref		AllocateFrameWithMap(RefArg map);Ref		CollectFrameTags(RefArg frame);typedef void (*CObjectBinaryProc)(void*);Ref AllocateCObjectBinary(void* cObj, CObjectBinaryProc destructor							, CObjectBinaryProc marker =   0  , CObjectBinaryProc updater =   0  );	Ref AllocateFramesCObject(long cObjSize, CObjectBinaryProc destructor							, CObjectBinaryProc marker =   0  , CObjectBinaryProc updater =   0  );long	Length(Ref obj);	void	SetLength(RefArg obj, long length);ULong	ObjectFlags(Ref obj);	Ref		GetArraySlotRef(Ref obj, long slot);inline	Ref		GetArraySlotRefArg(RefArg obj, long slot)	{ return GetArraySlotRef(obj, slot); }void	SetArraySlotRef(Ref obj, long slot, Ref value);inline	void	SetArraySlotRefArg(RefArg obj, long slot, RefArg value)	{ SetArraySlotRef(obj, slot, value); }void	AddArraySlot(RefArg obj, RefArg value);	Ref		GetFrameSlotRef(Ref obj, Ref slot);inline	Ref		GetFrameSlotRefArg(RefArg obj, RefArg slot)	{ return GetFrameSlotRef(obj, slot); }void	SetFrameSlot(RefArg obj, RefArg slot, RefArg value);int		FrameHasSlotRef(Ref obj, Ref slot);inline	int		FrameHasSlotRefArg(RefArg obj, RefArg slot)	{ return FrameHasSlotRef(obj, slot); }void	RemoveSlot(RefArg frame, RefArg tag);			Ref		GetFramePath(RefArg obj, RefArg thePath);void	SetFramePath(RefArg obj, RefArg thePath, RefArg value);int		FrameHasPath(RefArg obj, RefArg thePath);	Ref		Clone(RefArg obj);	Ref		DeepClone(RefArg obj);	Ref		TotalClone(RefArg obj);	Ref		EnsureInternal(RefArg obj);			void	MapSlots(RefArg obj, MapSlotsFunction func, ULong anything);	TObjectIterator*	NewIterator(RefArg obj);void ArrayRemoveCount(RefArg array, FastInt start, FastInt removeCount);Boolean ArrayRemove(RefArg array, RefArg element);inline void ArrayAppend(RefArg array, RefArg element)	{ AddArraySlot(array, element); }extern "C"	Ref FSetContains(RefArg, RefArg array, RefArg target);extern "C"	Ref FSetAdd(RefArg, RefArg members, RefArg member, RefArg unique);extern "C"	Ref FSetRemove(RefArg, RefArg members, RefArg member);extern "C"	Ref FSetOverlaps(RefArg, RefArg array, RefArg targetArray);extern "C"	Ref FSetUnion(RefArg, RefArg array1, RefArg array2, RefArg unique);extern "C"	Ref FSetDifference(RefArg, RefArg array1, RefArg array2);	void	ReplaceObjectRef(Ref target, Ref replacement);inline	void	ReplaceObjectRefArg(RefArg target, RefArg replacement)	{ ReplaceObjectRef(target, replacement); }	void	GC();void	Statistics(ULong* freeSpace, ULong* largestFreeBlock);Ptr		BlockStatistics(Ptr previousBlock, ULong* nextSize, Boolean* free);void	HeapBounds(Ptr* start, Ptr* limit);void	Uriah();void	UriahBinaryObjects(int printStrings =  false_ );	Ptr		BinaryData(Ref obj);Ref*	Slots(Ref obj);void	LockRef(Ref obj);void	UnlockRef(Ref obj);Ref		ClassOf(RefArg obj);void	SetClass(RefArg obj, RefArg theClass);int		IsSubclassRef(Ref sub, Ref super);inline	int		IsSubclassRefArg(RefArg sub, RefArg super)	{ return IsSubclassRef(sub, super); }int		IsInstance(RefArg obj, RefArg super);Ref		Intern(char* name);			char*	SymbolName(Ref sym);		ULong	SymbolHash(Ref sym);		int		symcmp(char* s1, char* s2);	Ref		CollectAllSymbols(void);	int		IsSymbol(Ref obj);int		SymbolCompareLexRef(Ref sym1, Ref sym2);inline	int		SymbolCompareLexRefArg(RefArg sym1, RefArg sym2)	{ return SymbolCompareLexRef(sym1, sym2); }Ref		MakeString(const char* str);Ref		MakeString(const UniChar* str);		UniChar*	GetCString(RefArg str);		Ref		ASCIIString(RefArg str);Boolean	IsString(RefArg ref);Boolean IsBinary(RefArg ref);Boolean IsArray(RefArg ref);Boolean IsFrame(RefArg ref);Boolean IsNumber(Ref ref);Boolean IsPathExpr(RefArg ref);void	StrMunger(RefArg s1, long s1start, long s1count,				  RefArg s2, long s2start, long s2count);void	ArrayMunger(RefArg a1, long a1start, long a1count,					RefArg a2, long a2start, long a2count);void	BinaryMunger(RefArg a1, long a1start, long a1count,					 RefArg a2, long a2start, long a2count);int		StrBeginsWith(RefArg str, RefArg prefix);int		StrEndsWith(RefArg str, RefArg suffix);void	StrUpcase(RefArg str);void	StrDowncase(RefArg str);void	StrCapitalize(RefArg str);void	StrCapitalizeWords(RefArg str);void	TrimString(RefArg str);long	StrPosition(RefArg str, RefArg substr, long startPos);long	ArrayPosition(RefArg array, RefArg item, long start, RefArg test);Ref		Substring(RefArg str, long start, long count);long	StrReplace(RefArg str, RefArg substr, RefArg replacement, long count);void	SortArray(RefArg array, RefArg test, RefArg key);			Ref		MakeReal(double d);double	CDouble(RefArg d);long	CoerceToInt(RefArg r);double	CoerceToDouble(RefArg r);int		ISREAL(Ref r);Ptr		ObjectPtr(Ref obj);	RefHandle*	AllocateRefHandle(Ref targetObj);void		DisposeRefHandle(RefHandle* Handle);void		ClearRefHandles();void		IncrementCurrentStackPos();void		DecrementCurrentStackPos();void	ClearGCRoots();void	AddGCRoot(Ref& root);void	RemoveGCRoot(Ref& root);typedef void (*DIYGCFuncPtr)(void*);void	DIYGCRegister(void* refCon, DIYGCFuncPtr markFunction, DIYGCFuncPtr updateFunction);void	DIYGCUnregister(void* refCon);void	DIYGCMark(Ref r);Ref		DIYGCUpdate(Ref r);typedef void (*GCProcPtr)(void*);void	GCRegister(void* refCon, GCProcPtr proc);void	GCUnregister(void* refCon);void	ClearGCHooks(); inline	int		EQ( RefArg  a,  RefArg  b)					{ return EQRef(a, b); }inline	Ref		GetArraySlot( RefArg  a, long b)			{ return GetArraySlotRef(a, b); }inline	void	SetArraySlot( RefArg  a, long b,  RefArg  c)	{ SetArraySlotRef(a, b, c); }inline	Ref		GetFrameSlot( RefArg  a,  RefArg  b)			{ return GetFrameSlotRef(a, b); }inline	int		FrameHasSlot( RefArg  a,  RefArg  b)			{ return FrameHasSlotRef(a, b); }inline	int		IsSubclass( RefArg  a,  RefArg  b)			{ return IsSubclassRef(a, b); }inline	void	ReplaceObject( RefArg  a,  RefArg  b)			{ ReplaceObjectRef(a, b); }inline	int		SymbolCompareLex( RefArg  a,  RefArg  b)		{ return SymbolCompareLexRef(a, b); }inline	RefVar::RefVar(){	h = AllocateRefHandle(NILREF);}inline	RefVar::~RefVar(){	DisposeRefHandle(h);}inline	RefVar::RefVar(const RefVar& o){	h = AllocateRefHandle(o.h->ref);}inline	RefVar::RefVar(const Ref r){	h = AllocateRefHandle(r);}inline	long	RefVar::Length()		const	{ return ::Length(h->ref); }inline	void	RefVar::SetLength(long length)		const	{ ::SetLength(*this, length); }inline	ULong	RefVar::ObjectFlags()	const	{ return ::ObjectFlags(h->ref); }inline	Ref		RefVar::GetArraySlot(long slot)		const	{ return ::GetArraySlotRef(h->ref, slot); }inline	void	RefVar::SetArraySlot(long slot, RefArg value)	const	{ ::SetArraySlotRef(h->ref, slot, value); }inline	void	RefVar::AddArraySlot(RefArg value)	const	{ ::AddArraySlot(*this, value); }inline	Ref		RefVar::GetFrameSlot(RefArg slot)	const	{ return ::GetFrameSlotRef(h->ref, slot); }inline	void	RefVar::SetFrameSlot(RefArg slot, RefArg value)	const	{ ::SetFrameSlot(*this, slot, value); }inline	int		RefVar::FrameHasSlot(RefArg slot)	const	{ return ::FrameHasSlotRef(h->ref, slot); }inline	Ref		RefVar::GetFramePath(RefArg thePath)	const	{ return ::GetFramePath(*this, thePath); }inline	void	RefVar::SetFramePath(RefArg thePath, RefArg value)	const	{ ::SetFramePath(*this, thePath, value); }inline	int		RefVar::FrameHasPath(RefArg thePath)	const	{ return ::FrameHasPath(*this, thePath); }inline	Ref		RefVar::Clone()		const	{ return ::Clone(*this); }inline	void	RefVar::MapSlots(MapSlotsFunction func, ULong anything)	const	{ ::MapSlots(*this, func, anything); }inline	TObjectIterator*	RefVar::NewIterator()	const	{ return ::NewIterator(*this); }inline	Ptr		RefVar::BinaryData()		const	{ return ::BinaryData(h->ref); }inline	void	RefVar::Lock()	const	{ ::LockRef(h->ref); }inline	void	RefVar::Unlock()		const	{ ::UnlockRef(h->ref); }inline	Ref		RefVar::Class()	const	{ return ::ClassOf(*this); }inline	void	RefVar::SetClass(RefArg theClass)	const	{ ::SetClass(*this, theClass); }class RefStruct : public RefVar {  public:	inline	RefStruct();			~RefStruct()							{ }	inline	RefStruct(const RefVar& o);	inline	RefStruct(const RefStruct& o);	inline	RefStruct(const Ref r);			RefStruct&	operator=(const Ref r)		{ h->ref = r; return *this; }			RefStruct&	operator=(const RefVar& o)	{ h->ref = o.h->ref; return *this; }			RefStruct&	operator=(const RefStruct& o)	{ return operator=((const RefVar&) o); }			operator long() const					{ return h->ref; }};inline	RefStruct::RefStruct(){	h->stackPos = 0;}inline	RefStruct::RefStruct(const RefStruct& o) : RefVar(o){	h->stackPos = 0;}inline	RefStruct::RefStruct(const RefVar& o) : RefVar(o){	h->stackPos = 0;}inline	RefStruct::RefStruct(const Ref r) : RefVar(r){	h->stackPos = 0;}class TObjectIterator : public SingleObject {  public:	RefStruct	fTag;	RefStruct	fValue;	RefStruct	fObj;	TObjectIterator(RefArg obj, int includeSiblings =  false_ );	virtual	~TObjectIterator();	void		Reset(void);	void		Reset(RefArg newObj);	int			Next(void);	int			Done(void);	Ref			Tag(void);	Ref			Value(void);  private:	int			fIncludeSiblings;	long		fIndex;	long		fLength;	RefStruct	fMapRef;	};class TFramesObjectPtr : public SingleObject {  protected:	RefStruct	fRef;  public:	TFramesObjectPtr();	TFramesObjectPtr(Ref r);	TFramesObjectPtr(const RefStruct& r);	TFramesObjectPtr(const RefVar& r);	~TFramesObjectPtr();	TFramesObjectPtr(const TFramesObjectPtr& p);	const TFramesObjectPtr& operator=(const TFramesObjectPtr& p);	const TFramesObjectPtr& operator=(Ref r);	operator char*() const;};class TBinaryDataPtr : private TFramesObjectPtr {  public:	TBinaryDataPtr() { }	TBinaryDataPtr(Ref r) : TFramesObjectPtr(r)	{ }	TBinaryDataPtr(const RefStruct& r) : TFramesObjectPtr(r)	{ }	TBinaryDataPtr(const RefVar& r) : TFramesObjectPtr(r)	{ }	~TBinaryDataPtr()	{ }	TBinaryDataPtr(const TBinaryDataPtr& p) : TFramesObjectPtr(p)	{ }	const TBinaryDataPtr& operator =(const TBinaryDataPtr& p);	const TBinaryDataPtr& operator =(Ref r);	operator char*() const;}; extern const ExceptionName  exOutOfMemory  ;	  extern const ExceptionName  exRefException   ;				void	ThrowRefException(ExceptionName name, RefArg data);void	ThrowBadTypeWithFrameData(NewtonErr errorCode, RefArg value);inline void OutOfMemory(char* msg = "out of memory")	{  Throw( exOutOfMemory , (void*) ( msg ), (ExceptionDestructor) 0) ; }extern Ref gClassMap;Ref		AllocateMapWithTags(RefArg superMap, RefArg tags);#line 29 ":TNativeCalls.h"#line 1 "::NewtonDev:C++:NCT_Projects:DDKIncludes:OS600:Protocols.h"   class TProtocol;class TClassInfo;MONITOR TClassInfoRegistry; typedef void* (*CodeProcPtr)(int selector, ...); class TProtocol{public:	void			Become(const TProtocol*);				void			Become(TObjectId);						const TClassInfo*	ClassInfo() const;					TObjectId		GetMonitorId() const;					operator		TObjectId();							void			SetType(const TClassInfo*);				long			StartMonitor												(							unsigned long	stackSize,							TObjectId		environment = 0,							ULong			name = 0x6D6E7472,									Boolean			rebootProtected =  false_ 						);	long			DestroyMonitor();					private:	 	void*			fRuntime;					const TProtocol*	fRealThis;				const void**	fBTable;					TObjectId		fMonitorId;					friend class ClassInfo;						friend void PrivateClassInfoMakeAt(const TClassInfo*, const void* proto);	};inline TProtocol :: operator TObjectId(){	return fMonitorId;}   class TClassInfo{public:	const char *	ImplementationName()	const;		const char *	InterfaceName()			const;		const char *	Signature()				const;		size_t			Size()					const;		void			MakeAt(const void*)		const;		const void *	EntryProc()				const;		const void *	AllocProc()				const;		const void *	FreeProc()				const;		unsigned long	Version()				const;		unsigned long	Flags()					const;		long			Register()				const;		long			DeRegister()			const;		TProtocol *		New()					const;		void			Destroy(TProtocol *)	const;		CodeProcPtr		Selector()				const;		const char *	GetCapability(const char*)	const;		const char *	GetCapability(long)	const;			Boolean			HasInstances(long *count) const; 	private:	friend class TProtocol;	friend size_t PrivateClassInfoSize(const TClassInfo*);		friend void PrivateClassInfoMakeAt(const TClassInfo*, const void* proto);	friend const char * PrivateClassInfoInterfaceName(const TClassInfo*);	friend const char * PrivateClassInfoImplementationName(const TClassInfo*);	 	long			fReserved1;					long			fNameDelta;					long			fInterfaceDelta;			long			fSignatureDelta;			long			fBTableDelta;				long			fEntryProcDelta;			unsigned long	fSizeofBranch;				unsigned long	fAllocBranch;				unsigned long	fFreeBranch;				unsigned long	fDefaultNewBranch;			unsigned long	fDefaultDeleteBranch;		unsigned long	fVersion;					unsigned long	fFlags;						long			fSelectorBranch;			long			fReserved2;				};enum{	 kci_IsMonitor		= 0x00000001		}; MONITOR TClassInfoRegistry : public TProtocol{public:	static TClassInfoRegistry* New(const char*);	void			Delete();	NewtonErr		Register(const TClassInfo*, ULong refCon=0);	NewtonErr		DeRegister(const TClassInfo*, Boolean specific= false_ );	Boolean			IsRegistered(const TClassInfo*, Boolean specific= false_ ) const;	const TClassInfo* Satisfy(const char* intf, const char* impl, ULong version) const;	long			Seed() const;	const TClassInfo*	First(long seed, ULong* pRefCon=0) const;	const TClassInfo*	Next(long seed, const TClassInfo* from, ULong* pRefCon=0) const;	const TClassInfo*	Find(const char* intf, const char* impl, int skipCount, ULong* pRefCon=0) const;		const TClassInfo*	Satisfy(const char* intf, const char* impl, const char* capability) const;	const TClassInfo*	Satisfy(const char* intf, const char* impl, const char* capability, const char* capabilityValue) const;	const TClassInfo*	Satisfy(const char* intf, const char* impl, const long capability, const long capabilityValue = 0) const;	void				UpdateInstanceCount(const TClassInfo* classinfo, long adjustment);	long 				GetInstanceCount(const TClassInfo* classinfo);};extern TClassInfoRegistry*		gProtocolRegistry;extern TProtocol*				NewByName(const char * abstract, const char * implementation);extern TProtocol*				NewByName(const char * abstract, const char * implementation, ULong version);	extern TProtocol*				NewByName(const char * abstract, const char * implementation, const char * capability);extern const TClassInfo*		ClassInfoByName(const char * abstract, const char * implementation, ULong version = 0);extern TProtocol*				AllocInstanceByName(const char * abstract, const char * implementation);extern void						FreeInstance(TProtocol*);extern void						StartupProtocolRegistry(void);extern TClassInfoRegistry*		GetProtocolRegistry(void); enum {	 kCodeInit			= 0				,kCodeVersion		= 1				,kCodeInfo			= 2				,kCodeClassCount	= 3				,kCodeClassAt		= 4				,kCodeReserved5		= 5				,kCodeReserved6		= 6				,kCodeReserved7		= 7				}; extern const TClassInfo*	ClassInfoFromHunkByName(void * hunk, const char * abstract, const char * implementation);extern TProtocol*		NewFromHunkByName(void * hunk, const char * abstract, const char * implementation); #line 30 ":TNativeCalls.h"PROTOCOL TNativeCalls : public TProtocol{public:	static	TNativeCalls*	New(char* inImplementationName);			void			Delete(void);	ULong			OpenLib(const char* inPath);	void			CloseLib(ULong inLib);	ULong			PrepareFFIStructure(ULong inLib, const char* inSymbol, ULong nbArgs);	void			SetArgValue_uint8(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetArgValue_sint8(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetArgValue_uint16(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetArgValue_sint16(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetArgValue_uint32(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetArgValue_sint32(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetArgValue_float(ULong inFFIIx, ULong inArgIndex, double inValue);	void			SetArgValue_double(ULong inFFIIx, ULong inArgIndex, double inValue);	void			SetArgValue_longdouble(ULong inFFIIx, ULong inArgIndex, double inValue);	void			SetArgValue_string(ULong inFFIIx, ULong inArgIndex, const char* inValue, ULong inSize);	void			SetArgValue_binary(ULong inFFIIx, ULong inArgIndex, const void* inBinary, ULong inSize);	void			SetArgValue_pointer(ULong inFFIIx, ULong inArgIndex, ULong inValue);	void			SetResultType(ULong inFFIIx, ULong inType);	void			Call_void(ULong inFFIIx);	ULong			Call_int(ULong inFFIIx);	double			Call_real(ULong inFFIIx);	void			Call_string(ULong inFFIIx, char* outResult, ULong inSize);	ULong			Call_pointer(ULong inFFIIx);	void			GetOutArgValue_string(ULong inFFIIx, ULong inArgIndex, const char* inValue, ULong inSize);	void			GetOutArgValue_binary(ULong inFFIIx, ULong inArgIndex, const void* inBinary, ULong inSize);	void			DisposeFFIStructure(ULong inFFIIx);	void			GetErrorMessage(char* outBuffer, ULong inSize);	ULong			GetErrno();};		
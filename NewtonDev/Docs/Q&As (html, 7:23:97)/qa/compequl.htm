<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Dangers of StrCompare, StrEqual at Compile Time</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Dangers of StrCompare, StrEqual at Compile Time</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Dangers of StrCompare, StrEqual at Compile Time  (6/9/94)</H3><DL><DD>Q:    I've noticed that <CODE>StrCompare </CODE>can return different results at compile time than it does at run time.  What gives?<BR><BR>A:    While most functions documented in the NewtonScript Reference are available at run time and at compile time (within the NTK environment), some functions have different behaviors.<BR><BR>    In this case, the sort order for strings within the NTK NewtonScript environment is different from the ordering used on the Newton (and different from other commonly used desktop machine sort orders.)  The differences are only apparent if you use characters outside the ASCII range, for instance, accented characters.<BR><BR>    If it is necessary to pre-sort accented strings at compile time, you can write your own function that will return the same results as <CODE>StrCompare </CODE>on an given Newton unit.  Here is one such function for English releases of the Newton OS (which assumes strings using only page 0 of the unicode table):<BR><BR><CODE><PRE>constant kNSortTable := '[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24, 25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46, 47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68, 69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90, 91,92,93,94,95,96,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80, 81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106, 107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122, 123,124,125,126,127,128,129,130,131,132,133,161,157,135,136,165, 149,138,137,143,141,152,159,158,144,140,170,134,146,147,148,142, 150,138,168,171,151,153,160,153,154,155,156,174,174,174,174,65, 65,145,67,175,69,175,175,176,176,176,176,162,78,177,177,177,79, 79,164,79,178,178,178,85,166,167,139,65,65,65,65,65,65,145,67,69, 69,69,69,73,73,73,73,169,78,79,79,79,79,79,163,79,85,85,85,85,172, 173,89];// function to compare strings (only page 0 characters)// with the same order as the Newton ROM does.DefConst('kNewtonStrCompare, func(s1, s2)    begin        local l1 := StrLen(s1);        local l2 := StrLen(s2);        local l := Min(l1, l2);        local i := 0;        while i &lt; l and            (r := kNSortTable[ord(s1[i])] - kNSortTable[ord(s2[i])]) = 0  do                i := i + 1;        if i = l then            l1-l2        else            r;    end); </PRE><BR></CODE>    Note that just because you might find a particular function to be defined at compile time, do not assume that it behaves in exactly the same way as the like-named run-time function, unless the documentation explicitly says it does.  (And, of course, it might not always be defined in the compile-time environment of future NTK products if it isn't documented that way.)</DL>
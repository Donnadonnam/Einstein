<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Endpoints & Comm Tools</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Endpoints & Comm Tools</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="endpoint.htm">Endpoints & Comm Tools</H2></A><UL><A HREF="#What_is_Error_Code_-18003"><B> </B>What is Error Code -18003  (3/8/94)<BR></A><A HREF="#Newton_Remote_Control_IR_(Infra-red)_API"><B> </B>Newton Remote Control IR (Infra-red) API  (6/9/94)<BR></A><A HREF="#Communications_With_No_Terminating_Conditions"><B> </B>Communications With No Terminating Conditions  (6/9/94)<BR></A><A HREF="#What_Really_Happens_During_Instantiate_&_Connect"><B> </B>What Really Happens During Instantiate & Connect  (6/14/94)<BR></A><A HREF="#Unicode-ASCII_Translation_Issues"><B> </B>Unicode-ASCII Translation Issues  (6/16/94)<BR></A><A HREF="#How_To_Specify_No_Connect/Listen_Options"><B> </B>How To Specify No Connect/Listen Options  (2/1/96)<BR></A><A HREF="#Why_Synchronous_Comms_Are_Evil"><B> </B>Why Synchronous Comms Are Evil  (2/1/96)<BR></A><A HREF="#Maximum_Speeds_with_the_Serial_Port"><B> </B>Maximum Speeds with the Serial Port  (9/19/96)<BR></A><A HREF="#Why_Are_User_Modem_Settings_Ignored"><B> </B>Why Are User Modem Settings Ignored  (1/15/97)<BR></A><A HREF="#Handling_a_-36006_Error_When_Disconnecting"><B> </B>Handling a -36006 Error When Disconnecting  (1/17/97)<BR></A><A HREF="#InputSpec_Input_Form_'Frame_or_'Binary_Buffer_Bug"><B> </B>InputSpec Input Form 'Frame or 'Binary Buffer Bug  (1/22/97)<BR></A><A HREF="#How_to_Debug_Communication_Endpoint_Code"><B> </B>How to Debug Communication Endpoint Code  (3/21/97)<BR></A><A HREF="#XOn/XOff_Software_Flow_Control_Options"><B> </B>XOn/XOff Software Flow Control Options  (4/3/97)<BR></A><A HREF="#Sharp_IR_Protocol"><B> </B>Sharp IR Protocol  (4/9/97)<BR></A><A HREF="#Using_Procrastinated_Actions_from_an_InputScript"><B>NEW: </B>Using Procrastinated Actions from an InputScript  (7/2/97)<BR></A><A HREF="#Using_the_EventHandler_Event_Time_Slot"><B>NEW: </B>Using the EventHandler Event Time Slot  (7/2/97)<BR></A></UL><A NAME="What_is_Error_Code_-18003"><H3><HR><B> </B>What is Error Code -18003  (3/8/94)</A></H3><DL><DD>Q:    What is error code -18003?<BR><BR>A:    This signal is also called SCC buffer overrun; it indicates that the internal serial chip buffer filled, and the NewtonScript part didn't have time to read the incoming information. You need to either introduce software (XON/XOFF) or hardware flow control, or make sure that you empty the buffer periodically.<BR><BR>    You will also get -18003 errors if the underlying comms tool encounters parity or frame errors. Note that there's no difference between parity errors, frame errors, or buffer overruns; all these errors are mapped to -18003.<BR><BR>    See the diagram for an explanation of what is going on concerning the serial chip, the buffers and the scripting world.<BR><BR>    The SCC chip gets incoming data, and stores it in a 3-byte buffer. An underlying interrupt handler purges the SCC buffer and moves it into a special tools buffer. The comms system uses this buffer to scan input for valid end conditions (the conditions which cause your inputSpec to trigger). Note that you don't lose data while you switch inputSpecs; it's always stored in the buffer during the switch.<BR><BR>    Now, if there's no flow control (XON/XOFF, HW handshaking, MNP5), the network side will slowly fill the tool buffer, and depending on the speed the buffer is handled from the scripting world sooner or later the comms side will signal a buffer overrun.   Even if flow control is enabled, you may still receive errors if the sending side does not react fast enough to the NewtonÍs plea to stop sending data.   In the case of XON/XOFF, if you suspect that one side or the other is not reacting or sending  flow control characters correctly, you may want to connect a line analyzer between the Newton and the remote entity  to see what is really happening.<BR><BR>    If  you have  inputScripts that take a long time to execute, you might end up with overrun problems.  If possible, store the received data away somewhere, quickly terminate the inputSpec, then come back and process the data later.  For instance, you could have an idleScript which updates a text view based on data stored in a soup or in a slot by your inputSpec.<BR></DL><CENTER><IMG BORDER="0" SRC="pictures/buffers.gif" ALT="Q&amp;A Diagram"></CENTER><A NAME="Newton_Remote_Control_IR_(Infra-red)_API"><H3><HR><B> </B>Newton Remote Control IR (Infra-red) API  (6/9/94)</A></H3><DL><DD>    NTK 1.0.1 and future NTK development kits contain the needed resources to build applications that control infrared receive systems, consumer electronics systems and similar constructs.<BR><BR>    This development kit is fairly robust, and will produce send-only applications.<BR><BR>    Note:  The NTK 1.1 platforms file is required to produce code that will execute correctly on the MessagePad 100 upgrade units.<BR><B><BR></B><CODE><PRE>cookie := OpenRemoteControl();</PRE><BR></CODE>    Call this function once to initialize the remote control functions.  It returns a magic cookie that must be passed to subsequent remote control calls, or nil if the initialization failed.<BR><BR><CODE><PRE>CloseRemoteControl(cookie);</PRE><BR></CODE>    Call this function once when all remote control operations are completed, passing cookie returned from <CODE>OpenRemoteControl</CODE>.  Always returns <CODE>nil</CODE>.  cookie is invalid after this call returns.<BR><BR><CODE><PRE>SendRemoteControlCode(cookie, command, count);</PRE><BR></CODE>    Given the cookie returned from <CODE>OpenRemoteControl</CODE>, this function sends the remote control command (see below for format of data).  The command is sent count times.  count must be at least 1.  Returns after the command has been sent (or after the last loop for <CODE>count </CODE>&gt; 1). (see diagram)<BR><BR>    Each command code has the following structure:<BR><CODE><PRE>struct IRCodeWord {    unsigned long name;    unsigned long timeBase;    unsigned long leadIn;    unsigned long repeat;    unsigned long leadOut;    unsigned long count;    unsigned long transitions[];};</PRE><BR></CODE>    <CODE>name</CODE>                identifies the command code; set to anything you like<BR>    <CODE>timeBase</CODE>            in microseconds; sets the bit time base<BR>    <CODE>leadIn</CODE>            duration in timeBase units of the lead bit cell<BR>    <CODE>repeat</CODE>            duration in timeBase units of the last bit cell for loop commands<BR>    <CODE>leadOut</CODE>            duration timeBase units of the last bit cell for non-loop commands<BR>    <CODE>count</CODE>                one-based count of transitions following<BR>    <CODE>transitions</CODE>[ ]    array of transition durations in timeBase units<BR><CODE><PRE></PRE><BR></CODE>    Note that the repeat time is used only when the code is sent multiple times.<BR><BR>    See Remote.¹, Sony.r, RC5.r, and RemoteTypes.r files for examples. The .rsrc files have templates for ResEdit editing of the Philips and Sony resources. See Remote IR Sample code for more details.<BR><BR><B>    Things To Know Before You Burn The Midnight Oil:<BR><BR></B>    If the Newton goes to sleep, the IR circuits are powered down, and any subsequent sends will fail. If you want to override this, you need to have a powerOffhandler close the remote connection, and when Newton wakes up the application could re-open the connection.<BR><BR>    If two applications are concurrently trying to use the IR port (beaming and remote control use for instance), this will cause a conflict.<BR><BR><B>    Sample Code<BR><BR></B>    The Remote IR Sample is part of the DTS Sample code distribution, you should find it on AppleLink and on the Internet ftp server (ftp.apple.com).<BR><BR>    By way of a quick summary: the sample has an array of picker elements with the resource definitions bound to the index (ircode inside the application base view). <BR><BR>    You specify the constant that is an index to the array, get the resource using the NTK function <CODE>GetNamedResource </CODE>and when you send data, use the constant as the resource used.<BR><BR><CODE>    OpenRemoteControl </CODE>is called in <CODE>viewSetupFormscript</CODE>, and <CODE>closeRemoteControl </CODE>is called in <CODE>viewQuitScript</CODE>. Note that these are methods, not global functions; same is true of <CODE>SendRemoteControlCode</CODE>.<BR><BR><B>    More Information<BR></B><BR>    Consult the IR samples available on ftp.apple.com (Internet) and on the Newton Developer CD-ROMs.<BR></DL><CENTER><IMG BORDER="0" SRC="pictures/remtcntl.gif" ALT="Q&amp;A Diagram"></CENTER><A NAME="Communications_With_No_Terminating_Conditions"><H3><HR><B> </B>Communications With No Terminating Conditions  (6/9/94)</A></H3><DL><DD>Q:    How do I handle input that has no terminating characters and/or variable sized packets?<BR><BR>A:    Remember that input specs are specifically tied to the receive completion mechanism. To deal with the situations of no terminating characters or no set packet sizes, you need only realize that one receive completion is itself a complete packet. Set the <CODE>byteCount</CODE> slot of your input spec to the minimum packet size. In your input script, call <CODE>Partial</CODE> to read in the entire packet, and then call <CODE>FlushInput</CODE> to empty everything out for your next receive completion.<BR><BR>    If this is time-delay-based input, you may be able to take advantage of <CODE>partialScripts</CODE> with <CODE>partialFrequencies</CODE>.  Call the <CODE>Ticks</CODE> global function if necessary to determine the exact execution time of a <CODE>partialScript</CODE>.<BR></DL><A NAME="What_Really_Happens_During_Instantiate_&_Connect"><H3><HR><B> </B>What Really Happens During Instantiate & Connect  (6/14/94)</A></H3><DL><DD>Q:    Does <CODE>Instantiate</CODE>, <CODE>Bind</CODE> or <CODE>Connect</CODE> touch the hardware?<BR><BR>A:    Exactly what happens depends on the type of endpoint being used.  In general:<BR><BR>    The endpoint requests one or more communications services using endpoint options like this:<BR><BR><CODE><PRE>{  type:      'service,  label:     kCMSAsyncSerial,  opCode:    opSetRequired}</PRE><BR>    &lt;see diagram section A&gt;</CODE> <BR><BR>    The CommManager task creates the appropriate CommTool task(s) and replies to the communications service request.  Each CommTool task initializes itself .  In response to the <CODE>Bind </CODE>request the CommTool acquires access to any physical hardware it controls, such as powering up the device.  The endpoint is ready-to-go.<BR><BR>    <CODE>&lt;see diagram section B&gt;</CODE><BR><BR>    An endpoint may use multiple CommTool tasks, but there will be a single NewtonScript endpoint reference for them.<BR><BR>    When the endpoint requests a connection, the CommTool interacts wih the physical hardware (or a lower level CommTool) as necessary to complete the connection, depending on the type of communications service.  For example, ADSP will use the endpoint address frame to perform an NBP lookup and connection request.  MNP  will negotiate protocol specifications such as compression and error correction.<BR><BR>    <CODE>&lt;see diagram section C&gt;</CODE><BR><BR>    The CommTool completes the connection and replies to the connection request.  Note that if this is done asynchronously, the Newt task continues execution, giving the user an option to abort the connection request.<BR><BR>    <CODE>&lt;see diagram section D&gt;</CODE><BR><BR>    <CODE>Disconnect</CODE> functions similarly to <CODE>Connect</CODE>, moving the endpoint into a disconnected state.  <CODE>Unbind</CODE> releases any hardware controlled by the CommTool. <CODE>Dispose</CODE> deallocates the CommTool task.<BR></DL><CENTER><IMG BORDER="0" SRC="pictures/instanti.gif" ALT="Q&amp;A Diagram"></CENTER><A NAME="Unicode-ASCII_Translation_Issues"><H3><HR><B> </B>Unicode-ASCII Translation Issues  (6/16/94)</A></H3><DL><DD>Q:    How are out-of-range translations handled by the endpoints?  For example, what happens if I try to output "\u033800AE\u Apple Computer, Inc."?<BR><BR>A:    The first Unicode character (0338) is mapped to ASCII character 255 because is it out of the range of valid translations, and the second Unicode character (00AE) is mapped to ASCII character A8 because the Mac character set has a corresponding character equivalent in the upper-bit range.<BR><BR>    All out-of-range translations, such as the 0338 diacritical mark above, are converted to ASCII character 255.  However, the reverse is not true!  ASCII character 255 is converted to Unicode character 02C7.  This means you will need to escape or strip all 02C7 characters in your strings before sending them if you want to use ASCII character 255 to detect out-of-range translations.  Character 255 was picked over character 0 because 0 is often used as the C-string terminator character.<BR><BR>    The built-in Newton Unicode-ASCII translation table is set up to handle the full 8-bit character set used by the MacOS operating system.  Although <CODE>kMacRomanEncoding </CODE>is the default encoding system for strings on most Newtons, you can specify it explicitly by adding one of the following encoding slots to your endpoint:<BR><BR><CODE><PRE>encoding:  kMacRomanEncoding;    // Unicode&lt;-&gt;Mac translation</PRE><BR>    encoding:  </CODE>kWizardEncoding <CODE>;        // Unicode&lt;-&gt;Sharp Wizard translation<BR>    encoding:  </CODE>kShiftJISEncoding <CODE>;        // Unicode&lt;-&gt;Japanese ShiftJIS translation<BR></CODE><BR>    For <CODE>kMacRomanEncoding</CODE>, the upper 128 characters of the MacOS character encoding are sparse-mapped to/from their corresponding unicode equivalents.  The map table can be found in Appendix B of the NewtonScript Programming Language reference.  The upper-bit translation matrix is as follows:<BR><BR><CODE><PRE>short gASCIIToUnicode[128] = {        0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1,        0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8,        0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3,        0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC,        0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF,        0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8,        0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211,        0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x2126, 0x00E6, 0x00F8,        0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB,        0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153,        0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA,        0x00FF, 0x0178, 0x2044, 0x00A4, 0x2039, 0x203A, 0xFB01, 0xFB02,        0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1,        0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4,        0xF7FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC,        0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7};</CODE></PRE></DL><A NAME="How_To_Specify_No_Connect/Listen_Options"><H3><HR><B> </B>How To Specify No Connect/Listen Options  (2/1/96)</A></H3><DL><DD>Q:    How do I specify that there are no options for the<CODE> Connect </CODE>and <CODE>Listen </CODE>methods of <CODE>protoBasicEndpoint</CODE>?<BR><BR>A:    Different endpoint services use the options parameter differently.  Some check for <CODE>nil </CODE>before attempting to access the array, while others assume they will always be passed an array of options.  Some also assume that the array will always contain at least one element.<BR><BR>    The correct work-around for this unspecified behaviour is to pass an array containing a single nil element.  This works for all endpoint service types.  For example:<BR><CODE><PRE>    ep:Connect([nil], nil);</CODE></PRE></DL><A NAME="Why_Synchronous_Comms_Are_Evil"><H3><HR><B> </B>Why Synchronous Comms Are Evil  (2/1/96)</A></H3><DL><DD>Q:    Why does the following loop run slower and slower with each successive output? If the data variable contains a sufficiently large number of items, the endpoint times out or the Newton reboots before all the data is transmitted. For instance:<BR><CODE><PRE>    data := [....];    for item := 0 to Length(data) - 1 do        ep:Output(data[ item ], nil, nil);</PRE><BR></CODE>A:    When <CODE>protoBasicEndpoint </CODE>performs a function synchronously, it creates a special kind of "sub-task" to perform the interprocess call to the comm tool task.  The sub-task causes the main NewtonScript task to suspend execution until the sub-task receives the "operation completed" response from the comm tool task, at which time the sub-task returns control to the main NewtonScript task, and execution continues.<BR><BR>    The sub-task, however, is not disposed of until control returns to the main NewtonScript event loop.  In effect, each and every synchronous call is allocating memory and task execution time until control is returned to the main NewtonScript event loop!  For a small number of sucessive synchronous operations, this is fine.<BR><BR>    A fully asynchronous implementation, on the other hand, is faster, uses less machine resources, allows the user to interact at any point in the loop, and is generally very easy to implement.  The above loop can be rewritten as follows:<BR><BR><CODE><PRE>ep.fData := [....];ep.fIndex := 0;ep.fOutSpec := {    async:        true,    completionScript:        func(ep, options, error)        if ep.fIndex &gt;= Length(ep.fData) - 1 then            // indicate we're done        else            ep:Output(ep.fData[ ep.fIndex := ep.fIndex + 1 ],                      nil, ep.fOutSpec )    };ep:Output(ep.fData[ ep.fIndex ], nil, ep.fOutSpec );</PRE><BR></CODE><BR>    Of course, you should always catch and handle any errors that may occur within the loop (<CODE>completionScript</CODE>) and exit gracefully.  Such code is left as an excercise for the reader.<BR></DL><A NAME="Maximum_Speeds_with_the_Serial_Port"><H3><HR><B> </B>Maximum Speeds with the Serial Port  (9/19/96)</A></H3><DL><DD>    Here are some rough estimates of the speeds attainable with the Newton serial port in combination with various kinds of flow control. These numbers are rough estimates, and depending on the protocol and amount of data (burst mode or not) you might get higher or lower transmission speeds. Experiment until you have found the optimal transmission speed.<BR><BR>    &#149;    0 to 38.4 Kbps<BR>    No handshaking necessary for short bursts, but long transmissions require flow control (either hardware or XON/XOFF).<BR><BR>    &#149;    38.4 Kbps to 115 Kbps<BR>    Require flow control, preferably hardware, but XON/XOFF should also work reasonably reliably.<BR><BR>    &#149;    115 Kbps +<BR>    You will encounter problems with latency and buffer sizes.  Speeds in this range require an error correcting protocol.<BR><BR>    Both hardware and <CODE>XON/XOFF</CODE> flow control can be set with the <CODE>kCMOInputFlowControlParms </CODE>and <CODE>kCMOOutputFlowControlParms </CODE>options.  In the case of hardware handshaking <CODE>(RTS/CTS)</CODE> you should use the following options:<BR><BR><CODE><PRE>{    label:    kCMOInputFlowControlParms,    type:        'option,    opCode:    opSetRequired,    data:        {    arglist: [                        kDefaultXonChar,                        kDefaultXoffChar,                        NIL,                        TRUE,                        0,                        0,    ],                    typelist: ['struct,                        'byte,                        'byte,                        'boolean,                        'boolean,                        'boolean,                        'boolean,    ],                },},{    label:    kCMOOutputFlowControlParms,    type:        'option,    opCode:    opSetRequired,    data:        {    arglist: [                        kDefaultXonChar,                        kDefaultXoffChar,                        NIL,                        TRUE,                        0,                        0,    ],                    typelist: ['struct,                        'byte,                        'byte,                        'boolean,                        'boolean,                        'boolean,                        'boolean,    ],                },}</CODE></PRE></DL><A NAME="Why_Are_User_Modem_Settings_Ignored"><H3><HR><B> </B>Why Are User Modem Settings Ignored  (1/15/97)</A></H3><DL><DD>Q:    Our customers are complaining that modem preferences such as Ignore Dial Tone are getting ignored in our product. We are not doing anything special to set up the modem so why are the system settings ignored?<BR><BR>A:    The user modem settings do not come for free. You must configure your endpoint based on the user settings. You can get these using the <CODE>MakeModemOption</CODE> call.<BR><BR>    In general, we recommend that you always use <CODE>MakeModemOption</CODE> when setting up options to intiailize an endpoint. So you would call <CODE>MakeModemOption</CODE> to get your initial option array, then add your own custom options after that.  <CODE>MakeModemOption</CODE> will return correct options based on the user settings for ignore DialTone, use PC Card Modem, etc.</DL><A NAME="Handling_a_-36006_Error_When_Disconnecting"><H3><HR><B> </B>Handling a -36006 Error When Disconnecting  (1/17/97)</A></H3><DL><DD>Q:    Sometimes -36006 is thrown when I call my endpoint's disconnect method.  What is happening?<BR><BR>A:    This error will occur when Disconnect is called on a dropped connection.  In fact, any time the endpoint state does not match the expected state of the calling method, a -36006 exception will be thrown.<BR><BR>    To work around this problem, include an EventHandler method in your endpoint.  When the connection drops, the EventHandler will be called and passed an event with an eventCode of 2.  Simply add a delayed call to unbind and dispose of your endpoint.    Do not use a deferred call to unbind and dispose of your endpoint: a bug in the deferred call mechanism can cause unpredictable results with communications code.</DL><A NAME="InputSpec_Input_Form_'Frame_or_'Binary_Buffer_Bug"><H3><HR><B> </B>InputSpec Input Form 'Frame or 'Binary Buffer Bug  (1/22/97)</A></H3><DL><DD>Q:    I have an <CODE>inputSpec</CODE> of form <CODE>'string</CODE>.  When its <CODE>inputScript</CODE> triggers, I switch to an input form of <CODE>'binary</CODE>.  When the binary <CODE>inputScript</CODE> triggers, the first few bytes of the data are garbage, and sometimes the <CODE>inputScript</CODE> doesn't trigger at all.  The same behavior occurs when switching to the <CODE>'frame</CODE> input form.  Why?<BR><BR>A:    Binary and frame (B/F) input forms do not buffer incoming data the same way other input forms do.  For maximum performance, the data is written directly into the destination object, rather than into an intermediate NewtonScript buffer for <CODE>endSequence</CODE> and <CODE>filter</CODE> processing.<BR><BR>    Unfortunately, all data that has been buffered using a non-B/F input form is lost when switching to a B/F input form, resulting in corrupted data at the start of input, incorrect <CODE>byteCount</CODE>, or end-of-packet (<CODE>EOP</CODE>) detection failure.<BR><BR>    The only workaround for this problem is to have the sender wait until the receiver has switched input forms and has flushed the input buffers before sending the binary data.  In other words:<BR>    <CODE>    </CODE>1.  receive data using a non-B/F input form<BR>        2.  flush the input buffer<BR>        3.  switch to a B/F input form<BR>        4.  tell the sender you're ready to receive more data<BR>        5.  receive data<BR></DL><A NAME="How_to_Debug_Communication_Endpoint_Code"><H3><HR><B> </B>How to Debug Communication Endpoint Code  (3/21/97)</A></H3><DL><DD>Q:    Is there any way I can use the NTK Inspector while running communications code? How do I debug my endpoint code? <BR><BR>A:    If you are using a serial or MNP serial endpoint, you can use a serial PC Card to do your comms, freeing the standard serial port for the NTK Inspector. If you are using a serial or MNP serial endpoint, you must  also modify your endpoint's instantiate options to use a PCMCIA slot instead of the built-in serial port.  Here is the option you should add directly after the endpoint service option:<CODE><PRE>{    type:          'option,    label:          kCMOSerialHWChipLoc,    opCode:         opSetRequired,    form:           'template,    result:         nil,    data:           {        argList:  [kHWLocPCMCIASlot1, 0],       // or kHWLocPCMCIASlot2        typeList: ['struct, ['array, 'char, 4], 'uLong]      }</PRE><BR>    }</CODE><BR><BR>    If you are using Newton Internet Enabler (NIE) endpoints, you can use a PC Card Modem instead of a serial PC Card, but you do not have to add any special endpoint options. NIE will handle this automatically, provided you correctly set up your modem in the Modem preferences in the Prefs application.<BR><BR>    This should allow your endpoint code to use the PC Card (serial card or modem card) instead of the built-in serial port. Connect the NTK Inspector to the built-in serial port as you normally would.  If you are using an AppleTalk endpoint, you can simultaneously use the NTK inspector connected via AppleTalk.</DL><A NAME="XOn/XOff_Software_Flow_Control_Options"><H3><HR><B> </B>XOn/XOff Software Flow Control Options  (4/3/97)</A></H3><DL><DD>Q:    XOn/XOff software flow control isn't working.  What could I be doing wrong?<BR><BR>A:    A quirk in the way Unicode characters are packed into <CODE>'char</CODE> fields in the endpoint option is preventing the correct flow control characters from being set in the serial driver.  The solution is to use the <CODE>'byte</CODE> symbol rather than the <CODE>'char</CODE> symbol for these fields, thus avoiding the Unicode-to-ASCII conversion that would normally take place.  The Newton Programmer's Guide is incorrect; the correct option frames are as follows:<BR><BR><CODE><PRE>{ label:    kCMOInputFlowControlParms,  type:     'option,  opCode:   opSetRequired,  result:   nil,  form:     'template,  data: {    arglist:  [      unicodeDC1,           // xonChar        unicodeDC3,           // xoffChar       true,                 // useSoftFlowControl       nil,                  // useHardFlowControl       0,                    // not needed; returned       0,  ],                // not needed; returned     typelist: ['struct,      'byte,                // XON character      'byte,                // XOFF character      'boolean,             // software flow control      'boolean,             // hardware flow control      'boolean,             // hardware flow blocked      'boolean, ],  },  },  // software flow blocked{ label:    kCMOOutputFlowControlParms,  type:     'option,  opCode:   opSetRequired,  result:   nil,  form:     'template,  data: {    arglist:  [      unicodeDC1,           // xonChar        unicodeDC3,           // xoffChar       true,                 // useSoftFlowControl       nil,                  // useHardFlowControl       0,                    // not needed; returned       0,  ],                // not needed; returned     typelist: ['struct,      'byte,                // XON character      'byte,                // XOFF character      'boolean,             // software flow control      'boolean,             // hardware flow control      'boolean,             // hardware flow blocked      'boolean, ],  },  },  // software flow blocked</CODE></PRE></DL><A NAME="Sharp_IR_Protocol"><H3><HR><B> </B>Sharp IR Protocol  (4/9/97)</A></H3><DL><DD>    <BR><B>    1    Serial Chip Settings<BR></B><CODE><PRE>    Baud rate    9600    Data bits    8    Stop bits    1    Parity       Odd</PRE><BR></CODE><BR><B>    2    Hardware Restrictions<BR></B>    The IR hardware used in the Sharp Wizard series (as well as Newtons and other devices) requires a brief stablizing period when switching from transmitting mode to receiving mode.  Specifically, it is not possible to receive data for two milliseconds after transmitting. Therefore, all devices should wait three milliseconds after completion of a receive before transmitting.<BR><BR><B>    3    Packet Structure<BR></B>    There are two kinds of Packets: "Packet I" and "Packet II". Because the IR unit is unstable at the start of a data transmission, <CODE>DUMMY (5 bytes of null code (0x00))</CODE> and <CODE>START ID (0x96)</CODE> begin both packet types. At least two null bytes must be processed by the receiver as <CODE>DUMMY</CODE> before the <CODE>START ID</CODE> of a packet is considered.  After this <CODE>(DUMMY, START ID)</CODE> sequence the <CODE>PACKET ID</CODE> is transmitted.  Code <CODE>0x82</CODE> is the packet ID for a PACKET I transmission, and code <CODE>0x81</CODE> is the packet ID for a PACKET II transmission.<BR><BR><B>    3.1    Packet I<BR></B>    This packet type is used to transmit the following control messages:<BR><BR>    3.1.1    Request to send                        <CODE>ENQ (0x05)</CODE><BR>    3.1.2    Clear to send                        <CODE>SYN (0x16)</CODE><BR>    3.1.3    Completion of receiving data        <CODE>ACK (0x06)</CODE><BR>    3.1.4    Failed to receive data                <CODE>NAK (0x15)</CODE><BR>    3.1.5    Interruption of receiving data        <CODE>CAN (0x18)</CODE><BR><BR>    The format of this packet type is as follows:<BR><BR><CODE><PRE>             Byte length    Set value in transmission    Detection method in reception    DUMMY        5              0x00 * 5                     Only 2 bytes are detected when received.    START ID     1              0x96PACKET ID    1              0x82DATA         1              above mentioned data</PRE><BR></CODE><BR>    Packet I example:<BR><BR><CODE><PRE>DUMMY                     START ID    PACKET ID    DATA    0x00, 0x00, 0x00, 0x00    0x96        0x82         0x05    </PRE><BR></CODE><BR><BR><B>    3.2    Packet II<BR></B>    This packet type is used to transmit data.  The maximum amount of data that may be transmitted in one packet is 512 bytes. If more than 512 bytes are to be transmitted, they are sent as several consecutive 512-byte packets.  The last packet need not be padded if it is less than 512 bytes and is distinguished by a <CODE>BLOCK NO</CODE> value of <CODE>0xFFFF</CODE>.<BR><BR>    The format of this packet type is as follows:<BR><BR><CODE><PRE>             Byte length    Set value in transmission    Detection method in receptionDUMMY        5              0x00 * 5                     Only 2 bytes are detected.START ID     1              0x96PACKET ID    1              0x81VERSION      1              0x10                         Judge only bits 7-4BLOCK NO     2 (L/H)        0x0001 ~ 0xFFFFCTRL CODE    1              0x01                         Don't judgeDEV CODE     1              0x40                         Don't judgeID CODE      1              0xFE                         Don't judgeDLENGTH      2 (L/H)        0x0001 ~ 0x0200DATA         1 ~ 512CHKSUM       2 (L/H)</PRE><BR></CODE> <BR>    <CODE>BLOCK NO</CODE> in last block must be set to <CODE>0xFFFF</CODE>.<BR><BR>    <CODE>CHKSUM</CODE> is the two-byte sum of all of the data bytes of <CODE>DATA</CODE> where any overflow or carry is discarded immediately.<BR><BR>    Send all two-byte integers lower byte first and upper byte second.<BR><BR>    Packet II example:<BR><BR><CODE><PRE>DUMMY                      START ID    PACKET ID    VERSION    BLOCK    NO      CTRL CODE0x00, 0x00, 0x00, 0x00     0x96        0x81         0x10       Low      High    0x01</PRE><BR></CODE><BR><CODE><PRE>DEV CODE    ID CODE    DLENGTH            data    CHECKSUM0x40        0xFE       Low        High    ????    Low         High</PRE><BR></CODE><BR><BR><B><CODE>    </CODE>4    Protocol<BR></B>    Data will be divided into several blocks of up to 512 bytes each.  These blocks are transmitted using type I and II packets as follows:<BR><BR><B>    4.1    Transmission Protocol<BR></B><BR>    4.1.1    The initiating device (A) begins a session by sending an <CODE>ENQ</CODE> (type I) packet.  The receiving device (B) will acknowledge the <CODE>ENQ</CODE> by transmitting a <CODE>SYN</CODE> packet.<BR><BR>    4.1.2    When (A) receives a <CODE>SYN</CODE> packet, it goes to step 4.1.4 below.<BR><BR>    4.1.3    When (A) receives a <CODE>CAN</CODE> packet, or when 6 minutes have elapsed without a <CODE>SYN</CODE> packet reply to an <CODE>ENQ</CODE> packet, (A) terminates the session.  If (A) receives any other packet, no packet, or an incomplete packet, it begins sending <CODE>ENQ</CODE> packets every 0.5 seconds.<BR><BR>    4.1.4    When (A) receives a <CODE>SYN</CODE> packet, it transmits a single type II data packet, then awaits an <CODE>ACK</CODE> packet from (B).<BR><BR>    4.1.5    When (A) receives an <CODE>ACK</CODE> packet, the transmission is considered successful.<BR><BR>    4.1.6    If no <CODE>ACK</CODE> packet is received within 1 second from completion of step 4.1.4, or if any other packet is received, (A) goes to step 4.1.1 and transmits the data again. Retransmission is attempted once. The session is terminated if the second transmission is unsuccessful.<BR><B><BR>    4.2    Reception Protocol<BR></B><BR>    4.2.1    The receiving device (B) begins a session by waiting for an <CODE>ENQ</CODE> (type I) packet. If no <CODE>ENQ</CODE> packet is received after 6 minutes (B) terminates the session.<BR><BR>    4.2.2    When (B) receives an <CODE>ENQ</CODE> packet, (B) transmits either a <CODE>SYN</CODE> packet to continue the session or a <CODE>CAN</CODE> packet to terminate the session.<BR><BR>    4.2.3    When (B) receives a valid type II packet (for example, the checksum and all header fields appear to be correct), (B) transmits an <CODE>ACK</CODE> packet.<BR><BR>    4.2.4    If one or more header fields of the data packet are not correct, or if the time between data bytes is more than 1 second, (B) goes to step 4.2.1 and does not transmit the <CODE>ACK</CODE> packet (this will cause (A) to retransmit the packet after a one second delay).<BR><BR>    4.2.5    If the header fields of the data packet appear to be correct but the checksum is incorrect, (B) transmits a <CODE>NAK</CODE> packet (this will cause (A) to retransmit the packet immediately).<BR><BR>    Because of the restriction in hardware mentioned in item 2 above, it is not possible to receive data for two  milliseconds after a data transmission.  Please wait three milliseconds before transmitting a response to the other device.<BR><BR>    (see diagram)</DL><CENTER><IMG BORDER="0" SRC="pictures/sharpir.gif" ALT="Q&amp;A Diagram"></CENTER><A NAME="Using_Procrastinated_Actions_from_an_InputScript"><H3><HR><B>NEW: </B>Using Procrastinated Actions from an InputScript  (7/2/97)</A></H3><DL><DD>Q:    Calling <CODE>AddProcrastinatedCall</CODE> or <CODE>AddProcrastinatedSend</CODE> repeatedly with the same symbol from my input specification's <CODE>InputScript</CODE> method sometimes causes an out of memory exception on pre-Newton 2.1 devices.  What's going wrong?<BR><BR>A:    If you post a procrastinated action from an <CODE>InputScript</CODE>, it may not be executed until a much later time. Due to a bug in the way procrastinated actions with the same symbol are queued, it's possible to queue so many events that you run out of NewtonScript heap memory.  This bug is fixed in the Newton 2.1 OS.<BR><BR>    Here are two possible workarounds:<BR><BR>    1) Use <CODE>AddDelayedCall</CODE> or <CODE>AddDelayedSend</CODE> in place of a procrastinated action.<BR><BR>    2) Buffer the incoming data (perhaps into a temporary soup).  Once the download has completed, perform the necessary operations on this data.  This method also provides transactional integrity in the event the communications connection is unexpectedly torn down while downloading.<BR></DL><A NAME="Using_the_EventHandler_Event_Time_Slot"><H3><HR><B>NEW: </B>Using the EventHandler Event Time Slot  (7/2/97)</A></H3><DL><DD>Q:    The Newton Programmer's Guide states that the <CODE>'time</CODE> slot of the event frame passed to an endpoint's <CODE>EventHandler</CODE> is in ticks.  After some experimentation, I've discovered that it is not in ticks.  What is this time value?<BR><BR>A:    The time value is actually the number of milliseconds since the Newton device was last reset.  The Newton Programmer's Guide incorrectly states that it is the number of ticks since the unit was last reset.  Note that because the unit of time is milliseconds, you can exceed NewtonScript's integer representation fairly quickly.  <BR><BR>    When you do run out of bits of precision for the millisecond value, the number will wrap to the smallest representable integer in NewtonScript.  According to two's complement binary representation, that number is <CODE>0x3FFFFFFF</CODE>, or <CODE>-536870912</CODE> decimal. Therefore, the time  value will start counting at zero, count up to <CODE>536870911</CODE>, wrap to <CODE>-536870912</CODE> then start to count back up to <CODE>536870911</CODE>.</DL>
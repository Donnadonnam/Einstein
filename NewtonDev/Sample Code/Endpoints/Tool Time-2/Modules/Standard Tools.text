// Text of project Standard Tools written on 9/25/97 at 12:56 PMDefConst('|streamFile_Tool Time Stream File.stream|, ReadStreamFile("Tool Time Stream File.stream"));|streamFile_Tool Time Stream File.stream|:?install();// Beginning of text file Project Constants/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*//*	Changes for d8:*//********************************************************************//*								Package Constants									  *//********************************************************************/ constant kVersionString 					:= "1.1d7 ©1997";constant kAboutString 						:= kVersionString && "\nBy Ryan Robertson, DTS Comms Geek";constant kTestMinAppSize					:= nil;constant kTestMaxAppSize					:= nil;constant kMinWidth 							:= 180;constant kMinHeight 							:= 90;constant kMaxWidth 							:= 220;constant kMaxHeight 							:= 110;constant kDefaultInstanceName				:= "^0 Endpoint ^1";constant kCancelButtonString				:= "Cancel";/********************************************************************//*						Profiling Constants										  *//********************************************************************/ constant kProfileFrame 				:= '{startTime: 0, stopTime: 0, timeElapsed: 0, paused: nil, size: 0};/********************************************************************//*								Status Strings										  *//********************************************************************/ constant kConnectingString				:= "Connecting...";constant kListeningString	 			:= "Listening...";constant kDisconnectingString 		:= "Disconnecting...";constant kCancellingString				:= "Cancelling...";constant kSendingString 				:= "Sending...";constant kProcessingCommandString 	:= "Processing...";constant kErrorInOutputString			:= "Sorry, there was an error outputting.";constant kWrongChunkSizeString 		:= "Your chunk size was not a multiple of the objects size.  This is just an informational notify, all the data was sent.";constant kEventHandlerString			:= "Event Handler Data\n^?0\nEvent Code: ^0||^?1\nEvent Data: ^1||^?2\nEvent ServiceID: ^2||^?3\nEvent Time: ^3||";constant kDisconnectingEndpoints		:= "Disconnecting ^0 endpoints...";/********************************************************************//*								AppleTalk Constants								  *//********************************************************************/ constant kAppleTalkToolSymbol				:= '|AppleTalk:DTS|;constant kAppleTalkToolString				:= "AppleTalk";constant kNoAppletalkFilterString 		:= "You must first enter a filter.";constant kChooserButtonString 			:= "a machine";constant kChooserHeaderString 			:= "machine";constant kChooserLookForString 			:= "machines";/********************************************************************//*								Serial Constants									  *//********************************************************************/ constant kSerialToolSymbol					:= '|Serial:DTS|;constant kSerialToolString					:= "Serial";constant kOnSymbol 							:= 'on;constant kOffSymbol 							:= 'off;constant kNeedNumberString 				:= "You must enter a number.";/********************************************************************//*								IrDA Constants										  *//********************************************************************/ constant kIrDAToolSymbol					:= '|IrDA:DTS|;constant kIrDAToolString					:= "IrDA";/********************************************************************//*								IrDA MUX Constants								  *//********************************************************************/ constant kIrDAMUXToolSymbol				:= '|IrDA_MUX:DTS|;constant kIrDAMUXToolString				:= "IrDA MUX";constant kServiceNameString				:= "Service Name";/********************************************************************//*								Modem Constants									  *//********************************************************************/ constant kModemToolSymbol					:= '|Modem:DTS|;constant kModemToolString					:= "Modem";/********************************************************************//*								NIE Constants										  *//********************************************************************/ constant kNIEToolSymbol						:= '|NIE:DTS|;constant kNIEToolString						:= "NIE";constant kTCP 									:= 1;constant kUDP 									:= 2;constant kTCPIPString						:= "TCP/UDP";constant kOpenLinkString					:= "Open NIE Link";constant kCloseLinkString					:= "Close NIE Link";constant kPortRequiredString 				:= "(Required)";constant kPortRequiredForListenString	:= "(Required for listen)";constant kPortDefaultString 				:= "(Default)";constant kDisconnectingLinkString		:= "Disconnecting Link";DefineGlobalConstant( 'kNIEMulticastOptionTemplate,	{		label:			"iumc",		type:				'option,		opCode:			opSetRequired,		result:			nil,		form:				'template,		data:			{				argList: 	[nil, nil, nil, nil],				typeList: 	['struct, 'long, 'long, 'uLong, ['array, 'byte, 4]],			},	} );	DefineGlobalConstant( 'kNIEBroadcastOptionTemplate,	{		label:			"iubc",		type:				'option,		opCode:			opSetRequired,		result:			nil,		form:				'template,		data:			{				argList: 	[nil, nil, nil],				typeList: 	['struct, 'boolean, 'boolean, 'boolean],			},	} );	constant kJoinMulticastGroup				:= 1;constant kLeaveMulticastGroup				:= 2;/********************************************************************//*								Generic Comms Constants							  *//********************************************************************/ constant kBindTimeout 						:= nil;constant kConnectTimeout 					:= nil;constant kAcceptTimeout 					:= nil;DefineGlobalConstant( 'kStringSpecTemplate,					{					form:					'string,					termination: 								{							endCharacter: unicodeCR, 							byteCount: 80,						},					partialFrequency:	200,					filter: 						{							sevenBit: true, 							byteProxy: [{byte: unicodeLF, proxy: nil}, {byte: 0x00, proxy: 0x20}],						},				} );DefineGlobalConstant( 'kEchoSpecTemplate,				{					form:					'bytes,					termination: 								{							byteCount: 80,						},					partialFrequency:	200,				} );				DefineGlobalConstant( 'kAnalyzeSpecTemplate,				{					form:					'bytes,					termination:						{							byteCount: 1024,						},					partialFrequency: 500,				} );// End of text file Project Constants// Beginning of file protoConfigLabelPicker_v190_0 :=    {labelCommands: [],     text: "",     viewBounds: {left: -2, top: 19, right: 96, bottom: 33},     labelActionScript:       func(cmd)       begin       	target.(targetPath) := labelCommands[cmd].(labelCommandsPath);       end,     textSetup:       func()       begin       	// Find the last selected item in the labelCommands array       	local previousItem := :FindPreviousItem();              	// If there was not a previous item, then set previous item       	// to be the first item in the labelCommands array and       	// set the appropriate slot in the target frame.       	if NOT previousItem then       		begin       			previousItem := labelCommands[0];       			target.(targetPath) := previousItem.(labelCommandsPath);       		end;       		       	// Return the text of the item       	previousItem.item;       end,     equalityTest:       // The value of this slot is used in the FindPreviousItem method.       '|=|,     labelCommandsPath:       // The path in a label command's item frame that stores the value       // we want to jam into target.(targetPath) slot.       // The default value is 'value.       'value,     targetPath:       // The path in the target frame to where the value is stored       // Target must be somewhere in the heirarchy       nil,     FindPreviousItem:       // This method can be overriden if necessary.       // It returns the item frame if found in labelCommands       func()       begin       	if target.(targetPath) then       		LFetch( labelCommands, target.(targetPath), 0, equalityTest, labelCommandsPath );       	else       		nil;       end,     _proto: @190 /* protoLabelPicker */    };// After Script for _v190_0thisView := _v190_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoConfigLabelPicker| := _v190_0;// End of file protoConfigLabelPicker// Beginning of file protoConfigLabelInputLine_v189_0 :=    {viewBounds: {left: 0, top: 8, right: 160, bottom: 32},     label: "",     textSetup:       func()       begin       	// return the initial value of the input line       	if target.(targetPath) then       		:FilterTarget( target.(targetPath) );       	else       		:FilterTarget( defaultValue );       end,     textChanged:       func()       begin       	// save off the new value of the input line       	target.(targetPath) := :FilterEntryline( entryLine.text );       end,     viewLineSpacing: 25,     viewSetupFormScript:       func()       begin       	// If this input line is read only, then remove the dotted       	// lines from the entryline child and remove the vClickable       	// flag from the entryLine       	if readOnly then       		begin       			entryLine.viewFormat := bxor( entryLine.viewFormat, vfLinesGray );       			self.viewFlags := bxor( self.viewFlags, vClickable );       		end;              	inherited:?viewSetupFormScript();		// this method is defined internally       end,     readOnly: nil,     Retarget:       func()       begin       	:RedoChildren();       end,     targetPath: nil,     FilterEntryline:       // You can override this method to convert the initial data       func( theText )       begin       	// If we are using an integer filter, then       	// create an integer from the text.  Otherwise       	// just return the text.       	if filter = 'integer then       		begin       			if StrFilled( theText ) then        				begin       					local number := StringToNumber(theText);       					if number then       						Floor( number );       					else       						defaultValue;       				end;       			else       				defaultValue;       		end;       	else       		theText;       end,     FilterTarget:       // You can override this method to convert the changed value       func( value )       begin       	// If we are using an integer filter, then       	// create a string from the integer value.  Otherwise       	// just return the text.       	if filter = 'integer then       		begin       			if value then       				NumberStr( value );       			else       				"";       		end;       	else       		value;       end,     filter: 'string,     defaultValue: "",     _proto: @189 /* protoLabelInputLine */    };// After Script for _v189_0thisView := _v189_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoConfigLabelInputLine| := _v189_0;// End of file protoConfigLabelInputLine// Beginning of file protoConfigCheckbox_v164_0 :=    {text: "",     viewBounds: {left: 14, top: 115, right: 204, bottom: 131},     viewSetupFormScript:       func()       begin       	viewValue := target.(targetPath);       	       	inherited:?viewSetupFormScript();       end,     valueChanged:       func()       begin       	target.(targetPath) := viewValue;       end,     targetPath: nil,     _proto: @164 /* protoCheckBox */    };// After Script for _v164_0thisView := _v164_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoConfigCheckbox| := _v164_0;// End of file protoConfigCheckbox// Beginning of file protoChipPicker_v0_0 :=    {labelCommands: [],     text: "Connect using",     viewBounds: {left: 17, top: 33, right: 215, bottom: 63},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	// Setup the labelCommands from the available serial ports       	self.labelCommands := call kGetCommPortInfoFunc with ();       	       	inherited:?ViewSetupFormScript();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	// reclaim used space       	self.labelCommands := nil;       	       	inherited:?ViewQuitScript();       end,     labelCommandsPath: 'hardwareLoc,     equalityTest: '|str=|,     _proto: _v190_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoChipPicker| := _v0_0;// End of file protoChipPicker// Beginning of file protoSerialEventCheckbox_v164_0 :=    {text: "Untitled Check",     viewBounds: {left: 0, top: 0, right: 144, bottom: 16},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	// Setup the initial value       	self.viewValue := band( target.(path), mask ) <> 0;       	       	inherited:?ViewSetupFormScript();       end,     valueChanged:       func()       begin       	// Set the new value       	if viewValue then       		target.(path) := target.(path) + mask;       	else       		target.(path) := target.(path) - mask;       end,     mask: nil,     path: 'serialEventMask,     _proto: @164 /* protoCheckBox */    };// After Script for _v164_0thisView := _v164_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoSerialEventCheckbox| := _v164_0;// End of file protoSerialEventCheckbox// Beginning of file protoIPInputLineElement_v0_0 :=    {readOnly: nil,     targetPath: nil,     entryFlags: 10753,     viewSetupFormScript:       func()       begin       	// We need to grab these slots from the parent       	self.readOnly := IPInputLineBase.readOnly;       	self.targetPath := :GetElementTargetPath( self.IPInputLineIndex );              	inherited:?viewSetupFormScript();		// this method is defined internally       end,     viewLineSpacing: 28,     IPInputLineIndex:       // This slot holds the index into the four element IP address       // array for this particular input line element.       // It is used in the viewSetupFormScript       nil,     filter: 'integer,     viewJustify: 8388610,     defaultValue: nil,     _proto: _v189_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoIPInputLineElement| := _v0_0;// End of file protoIPInputLineElement// Beginning of file protoIPInputLine_v74_0 :=    {viewBounds: {left: 8, top: 16, right: 229, bottom: 52},     viewFlags: 1,     viewFormat: 0,     filter: nil,     readOnly: nil,     Retarget:       func()       begin       	:SetupTarget();       	:RedoChildren();       end,     viewSetupFormScript:       func()       begin       	:SetupTarget();       end,     setupTarget:       func()       begin       	// Setup the array if it doesn't already exist       	if NOT target.(targetPath) OR NOT IsArray( target.(targetPath) ) then       		begin       			// Create an array of four elements       			target.(targetPath) := Array( 4, nil );              			// If we are using strings, then create four       			// empty strings.  We can't just use the same empty       			// string because a change to one would show up in       			// the other three strings.       			if filter = 'string then       				foreach slot, value in target.(targetPath) do       					target.(targetPath)[slot] := Clone("");       		end;       end;,     targetPath: nil,     declareSelf: 'IPInputLineBase,     GetElementTargetPath:       func( theIndex )       begin       	local newTargetPath;              	// Create the correct path expression       	// from the index and existing targetPath       	if IsArray( IPInputLineBase.targetPath ) then       		begin       			newTargetPath := Clone( IPInputLineBase.targetPath );       			AddArraySlot( newTargetPath, theIndex );       		end;       	else       		newTargetPath := [pathExpr: IPInputLineBase.targetPath, theIndex ];              	// return the new target path       	newTargetPath;       end,     viewClass: 74 /* clView */    };_v74_0_v0_0 :=    {viewBounds: {left: 0, top: 0, right: 25, bottom: 36},     viewJustify: 209715202,     label: "",     IPInputLineIndex: 0,     _proto: _v0_0    };AddStepForm(_v74_0, _v74_0_v0_0);_v74_0_v0_1 :=    {viewBounds: {left: 25, top: 0, right: 50, bottom: 36},     viewJustify: 209715202,     label: ".",     IPInputLineIndex: 1,     _proto: _v0_0    };AddStepForm(_v74_0, _v74_0_v0_1);_v74_0_v0_2 :=    {viewBounds: {left: 50, top: 0, right: 75, bottom: 36},     viewJustify: 209715202,     label: ".",     IPInputLineIndex: 2,     _proto: _v0_0    };AddStepForm(_v74_0, _v74_0_v0_2);_v74_0_v0_3 :=    {viewBounds: {left: 75, top: 0, right: 100, bottom: 36},     viewJustify: 209715202,     label: ".",     IPInputLineIndex: 3,     _proto: _v0_0    };AddStepForm(_v74_0, _v74_0_v0_3);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_protoIPInputLine| := _v74_0;// End of file protoIPInputLine// Beginning of file protoToolManager_v74_0 :=    {     GetInstanceName:       func()       begin       	// return the instance name       	name;       end,     CreateNewInstance:       func( theInstanceName, theConnectAction )       begin       	if kDebugOn then       		:DebugPrint( "In CreateNewInstance", [theInstanceName, theConnectAction] );       		       	// Create a new instance and add it to the instances array       	local theInstance := instanceTemplate:New( self, theInstanceName, toolPrefs );       	AddArraySlot( instances, theInstance );       	       	// Connect the Instance       	theInstance:Connect( theConnectAction );       	       	// return the instance       	theInstance;       end,     emergencyShutdownTemplate: nil,     endpointInfoTemplate: nil,     toolPrefsTemplate: nil,     ConnectionComplete:       func( theToolInstance )       begin       	// Pass this message on down       	:EndpointConnected( theToolInstance );       	       	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kInstanceConnectedSymbol, theToolInstance );       end,     GetEndpointExtrasTemplate:       func()       begin       	// return the extras template       	endpointExtrasTemplate;       end,     DebugPrint:       func( where, what )       begin       	write(where); write( "-->" ); print(what);       end,     GetToolInstances:       func()       begin       	// return the instances array       	instances;       end,     toolInfoTemplate: nil,     instanceTemplate: nil,     instances: nil,     endpointCount: nil,     GetToolPrefs:       func()       begin       	// return the endpoint prefs       	toolPrefs;       end,     endpointOptionsTemplate: nil,     GetToolExtrasTemplate:       func()       begin       	// return the tools extra template       	toolExtrasTemplate;       end,     GetEndpointName:       func()       begin       	// return the name.  For some tools this may be different than the comm tool name       	name;       end,     symbol: nil,     GetEndpointInfoTemplate:       // When can either be 'user or 'connect.  If user, then the user has selected to open       // the info template.  If 'connect, then a connection has been successfully established,       // so you may want to show the info view.       func( when )       begin       	// Return the endpoint info template       	endpointInfoTemplate;       end,     GetDefaultInstanceName:       func()       begin       	// Increment the endpoint count.  This count is used in the GetDefaultInstanceName method       	self.endpointCount := self.endpointCount + 1;       	       	// returns a default name for the instance       	ParamStr( kDefaultInstanceName, [self.name, NumberStr(self.endpointCount)] );       end,     GetToolPrefsTemplate:       func()       begin       	toolPrefsTemplate;       end,     name: "",     New:       func( theContext, thePrefs )       begin       	if kDebugOn then       		:DebugPrint( "In Manager New", [theContext] );              	if NOT thePrefs then       		thePrefs := TotalClone( defaultPrefs );              	local managerInstance :=        		{       			_proto:				self,       			_parent:				theContext,       			instances:			[],       			toolPrefs:			thePrefs,       			endpointCount:		0,       		};       	       	// Setup the toolManagerBase slot to be a self reference       	managerInstance.toolManagerBase := managerInstance;              	// Broadcast this message to all of the monitors       	managerInstance:BroadcastMonitorMessage( kManagerCreatedSymbol, managerInstance );       	       	// return the manager instance       	managerInstance;       end,     Dispose:       func()       begin       	if kDebugOn then       		:DebugPrint( "In Manager Dispose", [instances] );              	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kManagerDisposedSymbol, self );       		       	nil;       end,     GetToolInfoTemplate:       func()       begin       	// return the tools info template       	toolInfoTemplate;       end,     SetToolPrefs:       func( thePrefs )       begin       	self.toolPrefs := thePrefs;       end,     endpointExtrasTemplate: nil,     EmergencyShutdown:       func()       begin       	if kDebugOn then       		:DebugPrint( "In EmergencyShutdown", [instances] );       		       	// Need to synchronously disconnect each of the instances from here       	// and only return once all instances have been disconnected.              	if Length( instances ) > 0 then       		emergencyShutdownTemplate:New( self, kDisconnectingString, ParamStr( kDisconnectingEndpoints, [name] ) );       end,     DeleteInstance:       func( instance, theEmergencyContext )       begin       	if kDebugOn then       		:DebugPrint( "In DeleteInstance", [instance, theEmergencyContext] );       	       	// Find this instance in the instance list       	local pos := SetContains( instances, instance );       	       	// If it exists, then dispose of it and remove it from the list       	if pos then       		begin       			instances[pos]:Dispose();       			RemoveSlot( instances, pos );       		end;       		       	if theEmergencyContext then       		theEmergencyContext:InstanceDisconnected();       end,     viewClass: 74 /* clView */,     defaultPrefs: nil,     toolPrefs: nil,     ReadyToDispose:       func()       begin       	// Return true if there are no instances, otherwise nil       	Length(instances) = 0;       end,     toolExtrasTemplate: nil,     ConnectionFinished:       func( theToolInstance )       begin       	// Pass the information on to the tool time app       	:EndpointDisconnected( theToolInstance );              	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kInstanceDisconnectingSymbol, theToolInstance );       end,     BroadcastMonitorMessage:       func( theEvent, theEventData )       begin       	// Grab a reference to the monitors registry       	local theRegistry := GetGlobalVar( kToolTimeMonitorRegistrySymbol );       	       	// If the registry exists, then send the Monitor event to each monitor in the registry.       	if theRegistry then       		begin       			try       				foreach monitor in theRegistry do       					monitor:?MonitorEvent( toolManagerBase.symbol, theEvent, theEventData );       			onexception |evt.ex| do       				nil;       		end;       	       	// return nil just for the heck of it.       	nil;       end              /*       // Events include              'managerDisposed				managerReference       'managerCreated				managerReference       'instanceConnecting			instanceReference       'instanceConnected			instanceReference       'instanceDisconnecting		instanceReference       'intanceCreated				instanceReference       'instanceDisposed				instanceReference       'instanceOutput				{instance: <instance ref>, sendData: theData, sendOptions: theOptions, sendSpec: theSpec}       'instanceSetInputSpec		{instance: <instance ref>, specification: <input specification>}       'instanceGotInput				{instance: <instance ref>, data: theData, options: theOptions}       */,     GetCommToolName:       func()       begin       	// return the name       	name;       end    };// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/RemoveSlot( thisView, 'viewClass )constant |layout_protoToolManager| := _v74_0;// End of file protoToolManager// Beginning of file protoToolInstance_v74_0 :=    {     DoOutput:       func( data, sendOptions, sendSpec )       begin       	// If the machine is connected, then send the data on to it.       	if instanceMachine:IsConnected() then       		begin       			instanceMachine:DoEvent( 'DoOutput, [data, sendOptions, sendSpec] );       	       			// Broadcast this message to all of the monitors       			:BroadcastMonitorMessage( kInstanceOutputSymbol, {instance: toolInstanceBase, sendData: data, sendOptions: sendOptions, sendSpec: sendSpec} );       		end;       end,     GetInstanceName:       func()       begin       	// return the instance name       	instanceName;       end,     Disconnect:       func()       begin       	// Tell the instance machine to disconnect       	if instanceMachine then       		begin       			if instanceMachine:IsConnected() then       				instanceMachine:DoEvent( 'Disconnect, nil );       			else       				instanceMachine:DoEvent( 'Cancel, nil );       		end;       end,     GetAcceptOptions:       func()       begin       	// return the accept options       	[];       end,     IsDisconnected:       func()       begin       	// If there is a machine, then see what its state is       	// otherwise just return true       	if instanceMachine then       		instanceMachine:IsDisconnected();       	else       		true;       end,     GetBindOptions:       func( theConnectDirection )       begin       	// return the bind options       	[];       end,     GetListenOptions:       func()       begin       	// return the listen options       	[];       end,     instancePrefs: nil,     DoStartAnalyzer:       func()       begin       	// Cancel any currently outstanding input specifications       	instanceMachine:GetToolEndpoint():Cancel( nil );       	       	// Setup the proper input specification for this mode       	:DoSetInputSpec( Clone(kAnalyzeSpecTemplate) );       end,     DoChangeViewMode:       func( newMode )       begin       	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kInstanceChangeModeSymbol, toolInstanceBase );       	       	// Cancel any currently outstanding input specifications       	instanceMachine:GetToolEndpoint():Cancel( nil );       	       	// If the user is in terminal mode, then setup the terminal spec       	if newMode = kTerminalModeSymbol then       		:DoSetInputSpec( Clone(kStringSpecTemplate) );       	else if newMode = kEchoModeSymbol then       		:DoSetInputSpec( Clone(kEchoSpecTemplate) );       end,     instanceName: nil,     instanceMachine: nil,     DoEmergencyDisconnect:       func( theModalView )       begin       	// Setup the callback information and tell the instance to disconnect       	instanceMachine:SetupEmergencyCallback( theModalView );       	:Disconnect();       end,     connect:       func( theConnectAction )       begin       	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kInstanceConnectingSymbol, toolInstanceBase );       	       	// Create the state machine for this tool       	self.instanceMachine := machineTemplate:Instantiate( toolInstanceBase );       		       	// Send it on its way       	self.instanceMachine:DoEvent( 'Create, [theConnectAction] );       end,     New:       func( theContext, theInstanceName, theEndpointPrefs )       begin       	if kDebugOn then       		theContext:DebugPrint( "In Instance New", [theContext, theInstanceName, theEndpointPrefs] );              	local toolInstance :=        		{       			_proto:				self,       			_parent:				theContext,       			instancePrefs:		TotalClone(theEndpointPrefs),       			instanceName:		theInstanceName,       		};              	// Setup the toolInstanceBase slot to be a self reference       	toolInstance.toolInstanceBase := toolInstance;              	// Broadcast this message to all of the monitors       	toolInstance:BroadcastMonitorMessage( kInstanceCreatedSymbol, toolInstance );       	       	// return the tool instance       	toolInstance;       end,     Dispose:       func()       begin       	if kDebugOn then       		:DebugPrint( "In Instance Dispose", nil );              	// Get rid of the state machine       	self.instanceMachine:Dispose();       	self.instanceMachine := nil;       	       	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kInstanceDisposedSymbol, self );       end,     GetConnectOptions:       func()       begin       	// return the connect options       	[];       end,     IsConnected:       func()       begin       	// return true if the machine is connected, else and implicit nil       	if instanceMachine then       		instanceMachine:IsConnected();       end,     DoSetInputSpec:       func( theInputSpecification )       begin       	if instanceMachine then       		begin       			instanceMachine:DoEvent( 'DoInput, [theInputSpecification] );       	       			// Broadcast this message to all of the monitors       			:BroadcastMonitorMessage( kInstanceSetInputSpecSymbol, {instance: toolInstanceBase, specification: theInputSpecification} );       		end;       end,     DoHelper:       func( type )       begin       	if instanceMachine:IsConnected() then       		instanceMachine:DoEvent( 'DoHelper, [type] );       end,     GetInstancePrefs:       func()       begin       	// return the preferences       	instancePrefs;       end,     GetInstantiateOptions:       func( theConnectDirection )       begin       	// return the instantiate options       	[];       end,     viewClass: 74 /* clView */,     GotInput:       func( theData, theOptions )       begin       	// Just pass this on to the tool time base view       	:PrintToTerminal( theData, toolInstanceBase:GetInstanceName(), toolInstanceBase );              	// Broadcast this message to all of the monitors       	:BroadcastMonitorMessage( kInstanceGotIntputSymbol, {instance: toolInstanceBase, data: theData, options: theOptions} );       end,     DoEndpointOptions:       func( optionsFrame, optionsSpec )       begin       	// Grab the endpoint and send the option message       	local theEndpoint := instanceMachine:GetToolEndpoint();       	theEndpoint:Option( optionsFrame, optionsSpec );       end,     machineTemplate: nil    };// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/RemoveSlot( thisView, 'viewClass )constant |layout_protoToolInstance| := _v74_0;// End of file protoToolInstance// Beginning of file protoEvent// Before Script for _v218_0//	Newton Developer Technical Support Sample Code//	protoEvent - An NTK Finite State Machine User Proto//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes._v218_0 :=    {viewBounds: {left: 8, top: 16, right: -8, bottom: 32},     viewJustify: 8405040,     _proto: @218 /* protoStaticText */    };constant |layout_protoEvent| := _v218_0;// End of file protoEvent// Beginning of file protoState// Before Script for _v473_0//	Newton Developer Technical Support Sample Code//	protoState - An NTK Finite State Machine User Proto//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes._v473_0 :=    {viewBounds: {left: 8, top: 16, right: -8, bottom: 88},     viewJustify: 8396848,     _proto: @473 /* protoStatusText */    };constant |layout_protoState| := _v473_0;// End of file protoState// Beginning of file protoFSM// Before Script for _v218_0//	Newton Developer Technical Support Sample Code//	protoFSM - An NTK Finite State Machine User Proto//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes.//	kFSMBuildTemplateFunc - compile time only//	//	Function to call at compile time to create a FSM from a text file definition or other non-layout source.//	Performs basic sanity checking, constructs a protoFSM user template, and returns it.//	//	<compile time - in a project data file or beforeScript, after the protoFSM file has been compiled>//	DefConst	(	'kMyFSMTemplate,//						call kFSMBuildTemplateFunc with (	'myFSM,							// symbol = required name of this FSM//																				nil,									// frame or nil = optional context frame//																				Home & "myFSM.f",			// string or frame = required name of frame definition file to load, or frame definition//																				GetLayout("protoFSM")		// frame = required reference to protoFSM engine, or other engine//																			)//					);//	//	<run time>//	fsm := kMyFSMTemplate:Instantiate();//	kFSMBuildTemplateFunc := func(name, context, definition, engine)begin	local fsmSymbol := name;	if not fsmSymbol then		begin			fsmSymbol := 'unknown;			print("A protoFSM implementation is unnamed (kFSMBuildTemplateFunc requires the name parameter).");		end;		if not engine then		begin			print("The '|" & fsmSymbol & "| protoFSM engine is invalid.");			return;		end;		definitionFrame := if IsInstance(definition, 'string) then Load(definition) else definition;	if not IsInstance(definitionFrame, 'frame) then		begin			print("The '|" & fsmSymbol & "| protoFSM definition is invalid.");			return;		end;		if not definitionFrame.Genesis then		print("The '|" & fsmSymbol & "| protoFSM implementation is missing the required '|Genesis| state.");		local templateFrame := if IsInstance(context, 'frame) then context else {};		templateFrame._proto := engine;	templateFrame.declareSelf := fsmSymbol;	templateFrame.fsm_private_states := definitionFrame;		if not kDebugOn then		// GoToState is a debug-only function!		begin			RemoveSlot(templateFrame._proto, 'GoToState);			RemoveSlot(templateFrame, 'GoToState);		end;		RemoveSlot(templateFrame._proto, '_proto);	RemoveSlot(templateFrame._proto, 'viewBounds);		templateFrame;end;//	kFSMCleanUpFunc - compile time only//	//	Function to call in the afterScript of your FSM layout.//	Converts NTK layout data structures into "pure" FSM data structures used by protoFSM.//	//	Example://	//	<compile time - afterScript of a FSM layout>//	call kFSMCleanUpFunc with (thisView);				// let's assume the filename of this layout is "myFSM.t"//	//	<run time>//	fsm := GetLayout("myFSM.t"):Instantiate();//	kFSMCleanUpFunc := func(fsmFrame)begin	local fsmSymbol, stateSymbol, eventSymbol, hasGenesisState;		RemoveSlot(fsmFrame._proto, '_proto);	RemoveSlot(fsmFrame._proto, 'viewBounds);	RemoveSlot(fsmFrame, 'viewBounds);	RemoveSlot(fsmFrame, 'viewJustify);		fsmFrame.fsm_private_states := {	};		if not fsmSymbol := GetSlot(fsmFrame, 'declareSelf) then		begin			fsmSymbol := 'unknown;			print("A protoFSM implementation is unnamed (you forgot the declareSelf slot).");		end;		if fsmFrame.stepChildren then		foreach stateFrame in fsmFrame.stepChildren do			begin				RemoveSlot(stateFrame, '_proto);				RemoveSlot(stateFrame, 'viewBounds);				RemoveSlot(stateFrame, 'viewJustify);								if not stateSymbol := GetSlot(stateFrame, 'declareSelf) then					begin						stateSymbol := 'unknown;						print("A protoState in the '|" & fsmSymbol & "| protoFSM implementation is unnamed (you forgot the declareSelf slot).");					end;				if fsmFrame.fsm_private_states.(stateSymbol) then					print("The '|" & stateSymbol & "| protoState in the '|" & fsmSymbol & "| protoFSM implementation already exists (duplicate declareSelf slot value).");				else					fsmFrame.fsm_private_states.(stateSymbol) := stateFrame;								if stateFrame.stepChildren then					foreach eventFrame in stateFrame.stepChildren do						begin							RemoveSlot(eventFrame, '_proto);							RemoveSlot(eventFrame, 'viewBounds);							RemoveSlot(eventFrame, 'viewJustify);														if not eventSymbol := GetSlot(eventFrame, 'declareSelf) then								begin									eventSymbol := 'unknown;									print("A protoEvent in the '|" & stateSymbol & "| state of the '|" & fsmSymbol & "| protoFSM implementation is unnamed (you forgot the declareSelf slot).");								end;							if stateFrame.(eventSymbol) then								print("The '|" & eventSymbol & "| protoEvent in the '|" & stateSymbol & "| protoState in the '|" & fsmSymbol & "| protoFSM implementation already exists (duplicate declareSelf slot value).");							else								stateFrame.(eventSymbol) := eventFrame;														RemoveSlot(eventFrame, 'declareSelf);						end;								RemoveSlot(stateFrame, 'declareSelf);				RemoveSlot(stateFrame, 'stepChildren);								hasGenesisState := hasGenesisState or stateSymbol = 'Genesis;			end;		if not hasGenesisState then		print("The '|" & fsmSymbol & "| protoFSM implementation is missing the required '|Genesis| state.");		if not kDebugOn then		// GoToState is a debug-only function!		begin			RemoveSlot(fsmFrame._proto, 'GoToState);			RemoveSlot(fsmFrame, 'GoToState);		end;	RemoveSlot(fsmFrame, 'stepChildren);		nil;end_v218_0 :=    {viewBounds: {left: 8, top: 8, right: 232, bottom: 280},     DoEvent:       func(eventSymbol, paramArray)	// SELF can be anything that inherits to the finite state machine instance frame       begin       	local x := :?DoEvent_Check('|protoFSM:DoEvent|);       	if not x then       		return;       	       	if kDebugOn then       		if paramArray and PrimClassOf(paramArray) <> 'Array then       			Throw('|evt.ex.msg|, "protoFSM:DoEvent 2nd argument must be Nil or Array");       	       	x.pendingEventQueue:EnQueue(eventSymbol);       	x.pendingParamsQueue:EnQueue(paramArray);       	       	if not x.busy then       		begin       			x.busy := true;       			AddDelayedSend(x.fsm, 'DoEvent_Loop, nil, x.turtle);       		end;       	       	nil;       end,     Instantiate:       //	SELF is the finite state machine template frame, e.g.:       //       //	local fsm := GetLayout("myFSM"):Instantiate();       //       //	"myFSM" is assumed to be a layout based on protoFSM,              func()       begin       	local obj := {	_proto:							self,       						fsm:								nil,       						currentStateFrame:		nil,       						currentEventFrame:		nil,       						fsm_private_context:	{	fsm:								nil,       																turtle:							1,       																level:							0,       																busy:							nil,       																waitView:						nil,       																waitAborted:				nil,       																isNewPendingState:		true,       																pendingState:				'Genesis,       																pendingEventQueue:		QueueTemplate:Instantiate(),       																pendingParamsQueue:	QueueTemplate:Instantiate(),       																currentState:				nil,       																currentEvent:				nil,       																currentParams:			nil,	},	};       	obj.currentStateFrame := {	_proto:		obj.fsm_private_states.Genesis,       												_parent:	obj,	};       	obj.fsm := obj.fsm_private_context.fsm := obj;       end,     Dispose:       func()	// SELF should be the finite state machine instance frame       begin       	if not fsm_private_context then       		return;       	       	fsm_private_context.pendingEventQueue:Reset();       	fsm_private_context.pendingParamsQueue:Reset();       	foreach slot, value in fsm_private_context do fsm_private_context.(slot) := nil;       	fsm := currentStateFrame := currentEventFrame := fsm_private_context := nil;       	       	nil;	// guaranteed to return nil so that the caller can conveniently nil out the FSM container variable       end,     DoEvent_Loop:       func()	// SELF is the finite state machine instance frame       begin       	repeat       		local x := :?DoEvent_Check('|protoFSM:DoEvent_Loop|);       		if not x then       			return;       		       		local ok := nil;       		local pendingStateFrame := nil;       		       		if x.pendingState then       			if fsm_private_states.(x.pendingState) then       				if fsm_private_states.(x.pendingState).(x.pendingEventQueue:Peek()) then       					ok := true;       				else       					begin       						if kDebugOn then :?DebugFSM('UnknownEvent, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());			// ignore if event not programmed       					end;       			else       				begin       					if kDebugOn then :?DebugFSM('UnknownState, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());			// error --> remain in current state       				end;       		else       			begin       				if kDebugOn then :?DebugFSM('NilState, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());					// machine halted       			end;       		       		if not ok then       			begin       				currentStateFrame := nil;       				currentEventFrame := nil;       				       				x.isNewPendingState := true;       				       				x.pendingEventQueue:DeQueue();		// there is a problem with this state or event       				x.pendingParamsQueue:DeQueue();		// so remove the offending pending queue elements       			end;       		else       			begin       				x.currentState := x.pendingState;       				x.currentEvent := x.pendingEventQueue:DeQueue();       				x.currentParams := x.pendingParamsQueue:DeQueue();       				       				if x.isNewPendingState then       					begin       						x.isNewPendingState := nil;       						currentStateFrame :=	{	_proto:		fsm_private_states.(x.currentState),       																_parent:	self,	};       					end;       				       				currentEventFrame :=	{	_proto:		fsm_private_states.(x.currentState).(x.currentEvent),       														_parent:	currentStateFrame,	};       				       				if currentEventFrame.Action then       					begin       						if kDebugOn then :?TraceFSM('PreAction, x.currentState, x.currentEvent, x.currentParams);       						       						x.level := x.level + 1;       						try       							Perform(currentEventFrame, 'Action, x.currentParams);       						onexception |evt.ex| do       							begin       								try       									:?ExceptionHandler(CurrentException());       								onexception |evt.ex| do       									nil;       							end;       						x.level := x.level - 1;       						       						if kDebugOn then :?TraceFSM('PostAction, x.currentState, x.currentEvent, x.currentParams);       					end;       				       				if currentEventFrame.nextState then       					begin       						x.pendingState := currentEventFrame.nextState;       						x.isNewPendingState := (x.currentState <> x.pendingState);       					end;       				       				if kDebugOn then :?TraceFSM('NextState, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());       			end;       		       		if x.waitView												// check for terminal state & exit waitView if necessary       		and x.pendingState       		and pendingStateFrame := fsm_private_states.(x.pendingState) then       			if pendingStateFrame.terminal then       				begin       					x.pendingEventQueue:Reset();       					x.pendingParamsQueue:Reset();       					AddDelayedCall(	func()       												if x.waitView then       													x.waitView:Close(), nil, 1	);       				end;       		       		x.busy := not x.pendingEventQueue:IsEmpty();       		       	until not(x.busy and currentEventFrame and currentEventFrame.nextNoIdle);       	       	if x.busy then       		AddDelayedSend(self, 'DoEvent_Loop, nil, x.turtle);       	       	nil;       end,     SetSpeed:       func(newSpeed)		// SELF is the finite state machine instance frame       begin       	fsm_private_context.turtle := newSpeed;       end,     IsBusy:       func()	// SELF is the finite state machine instance frame       begin       	fsm_private_context.busy;       end,     GetSpeed:       func()	// SELF is the finite state machine instance frame       begin       	fsm_private_context.turtle;       end,     GoToState:       // SELF is the finite state machine instance frame       // This function is for DEBUGGING USE ONLY ! ! !       // It is STRIPPED from the resulting package when kDebugOn = nil              func(newState)       begin       	local x := fsm_private_context;       	       	x.pendingState := newState;       	x.pendingEventQueue:Reset();       	x.pendingParamsQueue:Reset();       	       	nil;       end,     QueueTemplate:       {       	Instantiate:			func()									// This is a very simple First-In-First-Out queue       								{	_proto:		self,       									queue:		[],	},       	       	Reset:					func() SetLength(queue, 0),       	       	Peek:					func() if Length(queue) > 0 then queue[0],		// else nil       	       	DeQueue:				func()       								if Length(queue) > 0 then		// else nil       									begin       										local data := queue[0];       										RemoveSlot(queue, 0);       										data;       									end,       	       	EnQueue:				func(data)       								begin       									AddArraySlot(queue, data);       									nil;       								end,       	       	GetQueueSize:		func() Length(queue),       	       	IsEmpty:				func() Length(queue) = 0,       },     ProtoClone:       func(object)       begin       	local f :=        		func native(obj)       		begin       			if not IsFrame(obj) or IsFunction(obj) then       				Throw('|evt.ex.msg|, "ProtoClone only works with frames.");       			       			local new := {_proto: obj};       			foreach slot, value in obj do       				if IsFrame(value) and not IsFunction(value) then       					new.(slot) := call f with (value);       			new;       		end;       	       	call f with (object);       end,     WaitForTerminal:       func(options)       begin       	local x := fsm_private_context;       	       	if x.waitView       	or x.level <> 0       	or x.pendingEventQueue:IsEmpty() then       		return;       	       	x.waitView := BuildContext(waitViewTemplate);       	x.waitView:SetOwnerContext(x, options);       	x.waitView:ModalDialog();       	x.waitAborted;		// return the value of waitAborted (true = user aborted via the status slip, nil = FSM terminal state was reached normally)       end,     waitViewTemplate:       {	viewClass:					clView,       	viewFlags:					vVisible,       	viewFormat:					vfNone,       	viewBounds:					{	left:			0,       											top:			0,       											right:		0,       											bottom:		0,	},       	       	statusView:					nil,       	statusViewOptions:		nil,        	fsmContext:					nil,        	aborted:						nil,        	       	SetOwnerContext:			func(owner, options)       										begin       											self.statusView := nil;       											self.statusViewOptions := options;		// frame of options the caller of WaitForTerminal is passing us (e.g.  progress messages, etc.)       											self.fsmContext := owner;				// the fsm_private_context slot of the FSM       											self.aborted := nil;       										end,       	       	viewIdleScript:				func()       										begin       											statusView := BuildContext(statusViewTemplate);       											statusView:SetOwnerContext(self, statusViewOptions);       											statusView:ModalDialog();       											nil;       										end,       	       	viewSetupDoneScript:	func()       										begin       											inherited:?ViewSetupDoneScript();       											if not statusViewOptions then       												:SetUpIdle(2000);       											else if statusViewOptions.delayUntilStatusVisible then       												:SetUpIdle(if statusViewOptions.delayUntilStatusVisible <= 0 then 1 else statusViewOptions.delayUntilStatusVisible);       										end,       	       	viewQuitScript:			func()       										begin       											if statusView then       												statusView:Close();       											fsmContext.waitAborted := aborted;       											fsmContext.waitView := nil;       										end,       	       	statusViewTemplate:		{	_proto:								protoStatusTemplate,       											initialSetup:						nil,       											waitView:							nil,       											delayUntilAbortTimer:		nil,       											delayUntilAbortVisible:		nil,       											abortButtonText:				nil,       											       											viewIdleScript:					func()       																					begin       																						inherited:?viewIdleScript();       																						local contents :=	{	name:		'vBarber,       																														values:		{	barber:		true,	},	};       																						       																						if delayUntilAbortVisible then       																							begin       																								delayUntilAbortTimer := delayUntilAbortTimer + 300;       																								if delayUntilAbortTimer > delayUntilAbortVisible then       																									begin       																										delayUntilAbortVisible := nil;       																										contents.values.primary := {	text:			abortButtonText,       																																					script:		func()       																																									begin       																																										waitView.aborted := true;       																																										waitView:Close();       																																									end,	};       																										base:ViewSet(contents);       																										return 300;       																									end;       																							end;       																						       																						base:UpdateIndicator(contents);       																						300;       																					end,       											       											viewSetupDoneScript:		func()       																					begin       																						inherited:?ViewSetupDoneScript();       																						:SetUpIdle(100);       																						self.delayUntilAbortTimer := 0;       																					end,       											       											SetOwnerContext:				func(owner, options)       																					begin       																						self.waitView := owner;       																						self.delayUntilAbortVisible := if options then options.delayUntilAbortVisible else 8000;       																						self.abortButtonText := if options and options.abortButtonText then options.abortButtonText else "Abort";       												     									self.initialSetup := {	name:		'vBarber,        																														values:		{	icon:					ROM_routeUpdateBitmap,       																																			statusText:		if options then options.statusText else "Please wait...",       																																			titleText:			if options then options.titleText else nil,       																																			barber:				true,       																																			primary:			nil,       																																			closeBox:			nil,	},	};       												     								end,       										},       },     ExceptionHandler:       func(exception)       begin       	local x := fsm_private_context;       	local message :=	if x then       									"The following exception occured in event ("       									& x.currentEvent       									& ") of state ("       									& x.currentState       									& ") of finite state machine ("       									& x.fsm.declareSelf       									& "):  "       								else       									"The following exception occured:  ";       	       	local exceptionStr := "<unable to create string representation of exception frame>";       	try       		exceptionStr := :ObjectToString(exception);       	onexception |evt.ex| do       		nil;       	       	:ExceptionHandler_Notify(message & exceptionStr);       	nil;       end,     ObjectToString:       // Converts (any?) NewtonScript data type into a string representation.       // Follows _proto pointers if the global var printProto is true.       // Follows _parent pointers if the global var printParent is true.       // Respects the global var printDepth (printDepth < 0 is effectively "infinite depth").       // Respects the global var printLength (printLength < 0 or nil is effectively "infinite length").       // Traps recursive references avoiding endless loops.       // Gives each frame and array a "reference number" so backpointer references make sense.       // Prints real numbers according to the global var printReal (a string defining the print format, e.g. "%.2f").       // Punts on any exception, like evt.ex.outofmem.       // NOTE:  This routine is primarily intended for use only during debugging.              func(obj)       begin       	constant separator := ", ";       	constant separatorLen := StrLen(separator);       	       	local backIndex := nil;       	local backList := [nil];       	       	local runProto := GetGlobalVar('printProto) <> nil;       	local runParent := GetGlobalVar('printParent) <> nil;       	       	local floatFormat := GetGlobalVar('printReal);       	if not IsString(floatFormat) then       		floatFormat := "%.16e";       	       	local maxDepth := GetGlobalVar('printDepth);       	if not IsNumber(maxDepth)       	or maxDepth < 0 then       		maxDepth := 65535;			// arbitrarily large value       	       	local maxLength := GetGlobalVar('printLength);       	if not IsNumber(maxLength)       	or maxLength < 0 then       		maxLength := 65535;		// arbitrarily large value       	       	local p :=       		func native(s)       		begin       			if EndsWith(s, separator) then       				StrMunger(s, StrLen(s) - separatorLen, nil, nil, 0, nil)       			else       				s;       		end;       	       	local f :=       		func native(obj, depth)       		begin       			local x := 0;       			       			(	if IsMagicPtr(obj) then       					"@+" & RefOf(obj)       				       				else if IsFunction(obj) then       					begin       						x := GetFunctionArgCount(obj);       						ParamStr("func(^0 arg^?1|s|)", [x, x = 1]);       					end       				       				else if IsFrame(obj) then       					if backIndex := LSearch(backList, obj, 1, '|=|, nil) then       						"<" & backIndex & ">"       					else       						begin       							local s := "{<" & Length(backList) & "> ";       							AddArraySlot(backList, obj);       							if depth > maxDepth then       								s := s & "+" & RefOf(obj);       							else       								foreach slot, item in obj do       									if (x := x + 1) > maxLength then       										begin       											s := s & "...";       											break;       										end       									else       										s := s & slot & ": " &       											if (slot = '_parent and not runParent)       											or (slot = '_proto and not runProto) then       												"<ignored>" & separator       											else       												call f with (item, depth + 1);       							call p with (s) & "}";       						end       				       				else if IsArray(obj) then       					if backIndex := LSearch(backList, obj, 1, '|=|, nil) then       						"<" & backIndex & ">"       					else       						begin       							local s := "[<" & Length(backList) & "> " & (if ClassOf(obj) <> 'Array then ClassOf(obj) & ": ");       							AddArraySlot(backList, obj);       							if depth > maxDepth then       								s := s & "+" & RefOf(obj);       							else       								foreach item in obj do       									if (x := x + 1) > maxLength then       										begin       											s := s & "...";       											break;       										end       									else       										s := s & call f with (item, depth + 1)	;       							call p with (s) & "]";       						end       				       				else if IsString(obj) then       					$" & obj & $"       				       				else if IsSymbol(obj) then       					$' & obj       				       				else if IsInteger(obj) then       					(if obj > 0 then "+" else "") & NumberStr(obj)       				       				else if IsNumber(obj) then       					(if obj > 0 then "+" else "") & FormattedNumberStr(obj, floatFormat)       				       				else if IsImmediate(obj) then       					if not obj then       						"nil"       					else if obj = true then       						"true"       					else       						SPrintObject(obj)       				       				else if IsBinary(obj) then       					"<" & ClassOf(obj) & ", length " & Length(obj) & ">"       				       				else       					SPrintObject(obj)       			       			) & separator;       		end;       	       	try       		call p with (call f with (obj, 0));       	onexception |evt.ex.outofmem| do       		begin       			backList := nil;       			"<insufficient memory>";       		end;       	onexception |evt.ex| do       		begin       			backList := nil;       			"<exception occured>";       		end;       end,     DoEvent_Check:       func(where)		// This routine checks to see if the FSM has been unexpectedly disposed.  That's especially bad if there's a delayed action/call/send about to trigger!       begin       	local x := fsm_private_context;       	if x then       		return x;       	       	if kDebugOn then       		:?ExceptionHandler_Notify("An active protoFSM object has mysteriously vanished!  Discovered in " & SPrintObject(where) & ".  You should consider resetting your Newton device now.");       	       	nil;       end,     ExceptionHandler_Notify:       func(message)       begin       	GetRoot():Notify(kNotifyAlert, kAppName, message);       	       	if kDebugOn then       		begin       			print(message);       			if GetGlobalVar('BreakOnThrows) then       				BreakLoop();       		end;       	       	nil;       end,     _proto: @218 /* protoStaticText */    };constant |layout_protoFSM| := _v218_0;// End of file protoFSM// Beginning of file StatusView.lyt_v467_0 :=    {viewBounds: {left: 0, top: 75, right: 185, bottom: 150},     viewIdleScript:       // The idlescript is used to update the barber pole if it is being used.       func()       begin        	:UpdateIndicator( {values: {barber: true} } );        	400;       end,     _proto: @467 /* protoStatusTemplate */    };// After Script for _v467_0thisView := _v467_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_StatusView.lyt| := _v467_0;// End of file StatusView.lyt// Beginning of file Endpoint.lyt_v74_0 :=    {     StopOutputProfileRun:       func()       begin       	// We better have an outputProfile frame otherwise profiling is not on       	if outputProfileFrame then       		begin       			// the timeElapsed slot will already have been calculated if we are paused, so       			// don't calculate it again.       			if NOT outputProfileFrame.paused then       				begin       					local time := Ticks();       					outputProfileFrame.timeElapsed := outputProfileFrame.timeElapsed + (time - outputProfileFrame.startTime);       				end;              			local timeInSeconds := outputProfileFrame.timeElapsed/60;       			local outputString := "";       			       			local throughputString;       			if outputProfileFrame.timeElapsed = 0 then       				throughputString := "0";       			else       				throughputString := NumberStr(Floor(outputProfileFrame.size/timeInSeconds)*8);              			outputString := outputString & "----------------------\n";       			outputString := outputString & "Output time in seconds:" && NumberStr(timeInSeconds) & "\n";       			outputString := outputString & "Output throughput (bits/second):" && throughputString & "\n";       			outputString := outputString & "----------------------\n";       			:PrintToTerminal( outputString, nil, toolInstanceBase );       			       			// nil out the appropriate stuff       			outputProfileFrame := nil;       			prefsCache := nil;       		end;       end,     StopInputProfileRun:       func( object )       begin       	// We better have an outputProfile frame otherwise profiling is not on       	if inputProfileFrame then       		begin       			local time := Ticks();       			       			if ClassOf(object) = 'string then       				inputProfileFrame.size := StrLen( object );       			else if ClassOf(object) = 'frame then       				begin       					try       						inputProfileFrame.size := Length( Translate(object, 'flattener, GetStores()[0], nil) );       					onexception |evt.ex| do       						inputProfileFrame.size := 0;       				end;       			else       				inputProfileFrame.size := Length( object );              			inputProfileFrame.timeElapsed := inputProfileFrame.timeElapsed + (time - inputProfileFrame.startTime);              			local timeInSeconds := inputProfileFrame.timeElapsed/60;       			local inputString := "";              			local throughputString;       			if inputProfileFrame.timeElapsed = 0 then       				throughputString := "0";       			else       				throughputString := NumberStr(Floor(inputProfileFrame.size/timeInSeconds)*8);              			// Let the user know how long it took to input the data.			       			inputString := inputString & "\n----------------------\n";       			inputString := inputString & "Input time in seconds:" && NumberStr(timeInSeconds) & "\n";       			inputString := inputString & "Input throughput (bits/second):" && throughputString & "\n";       			inputString := inputString & "----------------------\n";       			:PrintToTerminal( inputString, nil, toolInstanceBase );       						       			// nil out the appropriate stuff       			inputProfileFrame := nil;       			prefsCache := nil;       		end;       end,     outputProfileFrame: nil,     StartOutputProfileRun:       func()       begin       	// We better have a profile frame otherwise profiling is not on       	if outputProfileFrame then       		begin       			// If it is paused then restart the profile run.  Otherwise       			// setup the variables for a new profile run       			if outputProfileFrame.paused then       				begin       					outputProfileFrame.paused := nil;       					outputProfileFrame.startTime := Ticks();       				end;       			else       				outputProfileFrame.startTime := Ticks();       		end;       end,     inputProfileFrame: nil,     InitializeOutputProfileRun:       func( object )       begin       	// Only mess with profile information if the user has selected to run a profile       	// IsProfiling is a method of the tool time base view       	if :IsProfiling() then       		begin       			outputProfileFrame := Clone( kProfileFrame );       			       			if ClassOf(object) = 'string then       				outputProfileFrame.size := StrLen( object );       			else if ClassOf(object) = 'frame then       				begin       					try       						outputProfileFrame.size := Length( Translate(object, 'flattener, GetStores()[0], nil) );       					onexception |evt.ex| do       						outputProfileFrame.size := 0;       				end;       			else       				outputProfileFrame.size := Length( object );       		end;       end,     fOutputting: nil,     StartInputProfileRun:       func()       begin       	// We better have a profile frame otherwise profiling is not on       	if inputProfileFrame then       		begin       			// If it is paused then restart the profile run.  Otherwise       			// setup the variables for a new profile run       			if inputProfileFrame.paused then       				begin       					inputProfileFrame.paused := nil;       					inputProfileFrame.startTime := Ticks();       				end;       			else       				begin       					inputProfileFrame.startTime := Ticks();       				end;       		end;              end,     InitializeInputProfileRun:       func()       begin       	// Only mess with profile information if the user has selected to run a profile.       	// IsProfiling is a method of the tool time base view.       	if :IsProfiling() then       		inputProfileFrame := Clone( kProfileFrame );       end,     PauseOutputProfileRun:       func()       begin       	// We better have an outputProfile frame otherwise profiling is not on       	if outputProfileFrame then       		begin       			local time := Ticks();       			       			outputProfileFrame.paused := true;       			outputProfileFrame.timeElapsed := outputProfileFrame.timeElapsed + (time - outputProfileFrame.startTime);       			outputProfileFrame.startTime := 0;       		end;       end,     PauseInputProfileRun:       func()       begin       	// We better have an outputProfile frame otherwise profiling is not on       	if inputProfileFrame then       		begin       			local time := Ticks();       			       			inputProfileFrame.paused := true;       			inputProfileFrame.timeElapsed := inputProfileFrame.timeElapsed + (time - inputProfileFrame.startTime);       			inputProfileFrame.startTime := 0;       		end;       end,     EventHandler:       func( event )       begin       	local eventString := ParamStr( kEventHandlerString, [event.eventCode, event.data, event.serviceID, event.time] );       	:NotifyAlert( eventString, :GetInstanceName() );              	// The NIE tool has a flag with determines whether the normal event handling should       	// take place or not.       	local toolPrefs := :GetToolPrefs();       	       	// Make sure the slot exists and it is true before handling the disconnect event.       	// Handle the case when the other end has disconnected and we are in the       	// connected state       	if NOT toolPrefs.ignoreDisconnectEvent AND event.eventCode = 2 AND :IsConnected() then       			begin       				// if the endpoint is idle then chances are the endpoint       				// was disconnected from the other side (and the event handler       				// has run)       				if :State() = kIdle then       					:DoEvent( 'Unbind, nil );       				else       					:DoEvent( 'Disconnect, nil );       				nil;       			end;              end,     ExceptionHandler:       // Our exception handler just prints out an error when one occurs       func(error)       begin       	:NotifyError( "Endpoint ExceptionHandler", error, self );       end,     fOutputQueue: nil,     viewClass: 74 /* clView */    };// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/RemoveSlot(thisView, 'viewClass);thisView._proto := protoBasicEndpoint;/*	The profile code is duplicated for output and input.  It could be combined using helper	functions, but I wanted to incur as little Newtonscript overhead as possible.*/constant |layout_Endpoint.lyt| := _v74_0;// End of file Endpoint.lyt// Beginning of file Endpoint FSM.lytEndpoint FSM :=    {     DebugFSM:       func(reason, state, event, params)       begin       	nil;       	// Debug code goes here       end,     fStatusDialogView: nil,     IsDisconnected:       func()       begin       	fState = 'disconnected;       end,     fState: nil,     OpenStatusDialog:       func( set )       begin       	if kDebugOn then       		:DebugPrint( "In OpenStatusDialog", set );              	if NOT fStatusDialogView then        		begin       			fStatusDialogView := BuildContext( GetLayout("StatusView.lyt") );       			fStatusDialogView.stateMachine := fsm;       			fStatusDialogView._nextKeyView := toolTimeBase;       		end;       	       	fStatusDialogView:ViewSet( set );       	fStatusDialogView:Open();       	       	// If it is a barber pole then setup an idleScript to rotate the barber       	if set.name = 'vBarber then       		fStatusDialogView:SetupIdle( 400 );       	else       		fStatusDialogView:SetupIdle( 0 );       end,     CloseStatusDialog:       func()       begin       	if kDebugOn then       		:DebugPrint( "In CloseStatusDialog", nil );              	if fStatusDialogView then       		begin       			fStatusDialogView:Close();	       			fStatusDialogView := nil;       		end;       end,     fEmergencyContext: nil,     GetToolEndpoint:       func()       begin       	fEndpoint;       end,     viewBounds: {left: 0, top: 0, right: 496, bottom: 496},     GetState:       func()       begin       	return fState;       end,     _proto: _v218_0,     fConnectAction: nil,     fQuiet: nil,     CancelRequest:       func( why )       begin       	if kDebugOn then       		:DebugPrint( "In CancelRequest", why );       		       	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vBarber,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			true,       								closeBox:		nil,       								primary:			nil,       							},       					});		              	if FSM:IsConnected() then       		FSM:DoEvent( 'CancelRequest, [nil] );       	else       		FSM:DoEvent( 'Cancel, nil );       end,     fAbort: nil,     fEndpoint: nil,     Instantiate:       func( theContext )       begin       	local obj := inherited:?instantiate();       	obj._parent := theContext;       	obj.fState := 'disconnected;       	obj.fStatusDialogView := nil;       	       	obj;       end,     IsConnected:       func()       begin       	fState = 'connected;       end,     declareSelf: 'EndpointFSM,     SetupEmergencyCallback:       func( theContext )       begin       	fEmergencyContext := theContext;       end,     TraceFSM:       func(when, state, event, params)       begin       	// write(when); write("  "); write(state); write("  "); write(event); write("  "); print(params);       	// Trace code goes here       end    };Genesis :=    {viewBounds: {left: 8, top: 16, right: 112, bottom: 56},     terminal: true,     declareSelf: 'Genesis,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Genesis);Create :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func( connectAction )       begin       	fsm.fEmergencyContext	:= nil;       	fsm.fConnectAction 		:= connectAction;       	fsm.fState 					:= 'Connecting;       	fsm.fQuiet 					:= nil;       	fsm.fEndpoint 				:= {_proto: GetLayout("Endpoint.lyt")};       	fsm.fEndpoint._parent 	:= fsm;       		       	:DoEvent('Instantiate, nil);       end,     nextState: 'Instantiate,     declareSelf: 'Create,     fStarting: nil,     _proto: _v218_0    };AddStepForm(Genesis, Create);Instantiate :=    {viewBounds: {left: 120, top: 16, right: 224, bottom: 88},     declareSelf: 'Instantiate,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Instantiate);Instantiate :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vBarber,       						values:        							{       								statusText: 	kConnectingString,       								titleText:		:GetInstanceName(),       								barber: 			true,       								closeBox:		nil,       								primary:       									{       										text:		kCancelButtonString,       										script:	func()       													begin       														stateMachine:DoEvent( 'Cancel, nil );       													end,       									},       							},       					});              	try       		fEndPoint:Instantiate(fEndPoint, :?GetInstantiateOptions(fConnectAction) );       	onexception |evt.ex| do       		return :DoEvent('InstantiateFailure, [CurrentException()]);       	       	:DoEvent('InstantiateSuccess, nil);       end,     declareSelf: 'Instantiate,     nextState: 'Instantiating,     _proto: _v218_0    };AddStepForm(Instantiate, Instantiate);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	       	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       end,     _proto: _v218_0    };AddStepForm(Instantiate, Cancel);Instantiating := {declareSelf: 'Instantiating, _proto: _v473_0};AddStepForm(Endpoint FSM, Instantiating);InstantiateSuccess :=    {     action:       func()       begin       	if fAbort then       		return :DoEvent('Abort, nil);              	// Setup the output queue       	fEndpoint.fOutputQueue := QueueTemplate:Instantiate();       	       	:DoEvent('Bind, nil);       end,     declareSelf: 'InstantiateSuccess,     nextState: 'Bind,     _proto: _v218_0    };AddStepForm(Instantiating, InstantiateSuccess);InstantiateFailure :=    {     action:       func(error)       begin       	:NotifyError("Endpoint Instantiate", error, toolInstanceBase);       	:DoEvent('CleanUp, nil);       end,     declareSelf: 'InstantiateFailure,     nextState: 'CleanUp,     _proto: _v218_0    };AddStepForm(Instantiating, InstantiateFailure);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	       	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       end,     _proto: _v218_0    };AddStepForm(Instantiating, Cancel);Bind :=    {viewBounds: {left: 120, top: 96, right: 224, bottom: 200},     declareSelf: 'Bind,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Bind);Bind :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'Bind,     action:       func()       begin       	try       		fEndPoint:Bind( :?GetBindOptions(fConnectAction), fCompletionSpec );       	onexception |evt.ex| do       		:DoEvent('BindFailure, [CurrentException()]);       end,     fCompletionSpec:       {	async:				true,       	reqTimeout:			kBindTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('BindFailure, [result]);       									else       										ep:DoEvent('BindSuccess, nil);       								end,	},     nextState: 'Binding,     _proto: _v218_0    };AddStepForm(Bind, Bind);Abort :=    {declareSelf: 'Abort,     action:       func()       begin       	:DoEvent('Dispose, nil);       end,     nextState: 'Dispose,     _proto: _v218_0    };AddStepForm(Bind, Abort);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	       	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       end,     fCancelSpec:       nil; //{async: true}       ,     _proto: _v218_0    };AddStepForm(Bind, Cancel);Binding := {declareSelf: 'Binding, _proto: _v473_0};AddStepForm(Endpoint FSM, Binding);Bind Success :=    {declareSelf: 'BindSuccess,     action:       func()       begin       	if fAbort then       		return :DoEvent('Abort, nil);       	       	:DoEvent('Connect, nil);       end,     nextState: 'Connect,     _proto: _v218_0    };AddStepForm(Binding, Bind Success);Bind Failure :=    {declareSelf: 'BindFailure,     action:       func(error)       begin       	:NotifyError("Endpoint Bind", error, toolInstanceBase);       	:DoEvent('Dispose, nil);       end,     nextState: 'Dispose,     _proto: _v218_0    };AddStepForm(Binding, Bind Failure);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       						       	try       		fEndPoint:Cancel(nil);       	onexception |evt.ex.comm| do       		nil;       end,     _proto: _v218_0    };AddStepForm(Binding, Cancel);Connect :=    {viewBounds: {left: 120, top: 208, right: 224, bottom: 344},     declareSelf: 'Connect,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Connect);Connect :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'Connect,     action:       func()       begin       	if fConnectAction = kConnectSymbol then       		begin       			try       				fEndPoint:Connect( :?GetConnectOptions(), fCompletionSpec_Connect );       			onexception |evt.ex.comm| do       				:DoEvent( 'ConnectFailure, [CurrentException()] );       		end;       	else       		begin       			try       				fEndPoint:Listen( :?GetListenOptions(), fCompletionSpec_Listen );       			onexception |evt.ex.comm| do       				:DoEvent( 'ConnectFailure, [CurrentException()] );       		end;       end,     fCompletionSpec_Connect:       {	async:				true,       	reqTimeout:			kConnectTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('ConnectFailure, [result]);       									else       										ep:DoEvent('ConnectSuccess, nil);       								end,	},     fCompletionSpec_Listen:       {	async:				true,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('ListenFailure, [result]);       									else       										ep:DoEvent('ListenSuccess, nil);       								end,	},     nextState: 'Connecting,     _proto: _v218_0    };AddStepForm(Connect, Connect);Cancel :=    {viewBounds: {left: 8, top: 96, right: 96, bottom: 112},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       end,     fCancelSpec:       nil; //{async: true}       ,     _proto: _v218_0    };AddStepForm(Connect, Cancel);Abort :=    {declareSelf: 'Abort,     action:       func()       begin       	fAbort := true;       	       	:DoEvent('UnBind, nil);       end,     nextState: 'UnBind,     _proto: _v218_0    };AddStepForm(Connect, Abort);Connecting :=    {declareSelf: 'Connecting,     viewBounds: {left: 8, top: 16, right: -8, bottom: 120},     _proto: _v473_0    };AddStepForm(Endpoint FSM, Connecting);Connect Success :=    {     action:       func()       begin       	if fAbort then       		return :DoEvent('Disconnect, nil);       	       	:DoEvent('Connected, nil);       end,     declareSelf: 'ConnectSuccess,     nextState: 'Connected,     _proto: _v218_0    };AddStepForm(Connecting, Connect Success);Connect Failure :=    {     action:       func(error)       begin       	:NotifyError("Endpoint Connect", error, toolInstanceBase);       	       	:DoEvent('UnBind, nil);       end,     declareSelf: 'ConnectFailure,     nextState: 'UnBind,     _proto: _v218_0    };AddStepForm(Connecting, Connect Failure);Listen Sucess :=    {     action:       func()       begin       	if fAbort then       		return :DoEvent('Abort, nil);       	       	:DoEvent('Accept, nil);       end,     declareSelf: 'ListenSuccess,     nextState: 'Accept,     _proto: _v218_0    };AddStepForm(Connecting, Listen Sucess);Listen Failure :=    {     action:       func(error)       begin       	:NotifyError("Endpoint Listen", error, toolInstanceBase);              	:DoEvent('UnBind, nil);       end,     declareSelf: 'ListenFailure,     nextState: 'UnBind,     _proto: _v218_0    };AddStepForm(Connecting, Listen Failure);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       	       	try       		fEndPoint:Cancel(nil);       	onexception |evt.ex.comm| do       		nil;       end,     _proto: _v218_0    };AddStepForm(Connecting, Cancel);Accept :=    {viewBounds: {left: 120, top: 384, right: 224, bottom: 488},     declareSelf: 'Accept,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Accept);Accept :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'Accept,     action:       func()       begin	       	try       		fEndPoint:Accept( :?GetAcceptOptions(), fCompletionSpec );       	onexception |evt.ex| do       		:DoEvent( 'AcceptFailure, [CurrentException()] );       end,     fCompletionSpec:       {	async:				true,       	reqTimeout:			kAcceptTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('AcceptFailure, [result]);       									else       										ep:DoEvent('AcceptSuccess, nil);       								end,	       },     nextState: 'Accepting,     _proto: _v218_0    };AddStepForm(Accept, Accept);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       func()       begin       	fQuiet := true;              	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});              	fEndPoint:Cancel(fCancelSpec);       end,     fCancelSpec:       nil; //{async: true}       ,     _proto: _v218_0    };AddStepForm(Accept, Cancel);Abort :=    {declareSelf: 'Abort,     action:       func()       begin       	:DoEvent('Disconnect, nil);       end,     nextState: 'Disconnect,     _proto: _v218_0    };AddStepForm(Accept, Abort);Accepting := {declareSelf: 'Accepting, _proto: _v473_0};AddStepForm(Endpoint FSM, Accepting);Accept Success :=    {     action:       func()       begin       	if fAbort then       		return :DoEvent('Disconnect, nil);       	       	:DoEvent('Connected, nil);       end,     declareSelf: 'AcceptSuccess,     nextState: 'Connected,     _proto: _v218_0    };AddStepForm(Accepting, Accept Success);Accept Failure :=    {     action:       func(error)       begin       	:NotifyError( "Endpoint Accept", error, toolInstanceBase );       	       	:DoEvent('UnBind, nil);       end,     declareSelf: 'AcceptFailure,     nextState: 'UnBind,     _proto: _v218_0    };AddStepForm(Accepting, Accept Failure);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});       	       	try       		fEndPoint:Cancel(nil);       	onexception |evt.ex.comm| do       		nil;       end,     _proto: _v218_0    };AddStepForm(Accepting, Cancel);Connected :=    {viewBounds: {left: 232, top: 16, right: 336, bottom: 88},     declareSelf: 'Connected,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Connected);Connected :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	// Close the status dialogs and set the state flag       	// to indicate that we are connected.       	:CloseStatusDialog();       	fState := 'Connected;       	       	// This will eventually make it to the tool time base       	:ConnectionComplete( toolInstanceBase );       end,     declareSelf: 'Connected,     _proto: _v218_0    };AddStepForm(Connected, Connected);Disconnect :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	fState := 'Disconnecting;       	fQuiet := true;              	// This will eventually make it to the tool time base       	:ConnectionFinished( toolInstanceBase );              	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatus,       						values:        							{       								statusText: 	kDisconnectingString,       								titleText:		:GetInstanceName(),       								closeBox:		nil,       								primary:			nil,       							},       					});       		       	fEndPoint:Cancel( fCancelSpec );       end,     declareSelf: 'Disconnect,     nextState: 'Disconnect,     fCancelSpec:       {       	async: true,       	CompletionScript: 	func( ep, options, result )        								begin       									ep:DoEvent( 'Disconnect, nil );       								end       },     _proto: _v218_0    };AddStepForm(Connected, Disconnect);Unbind :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	fState := 'Disconnecting;       	fQuiet := true;              	// This will eventually make it to the tool time base       	:ConnectionFinished( toolInstanceBase );       	       	:DoEvent( 'Unbind, nil );       end,     declareSelf: 'Unbind,     nextState: 'Unbind,     _proto: _v218_0    };AddStepForm(Connected, Unbind);DoOutput :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func( theData, theSendOptions, theSendSpecTemplate )       begin       	if kDebugOn then       		:DebugPrint( "In DoOutput event", [theData, theSendOptions, theSendSpecTemplate] );              	// queue up the data if we are currently outputting data       	if fEndpoint.fOutputting then        		begin       			fEndpoint.fOutputQueue:EnQueue( [theData, theSendOptions, theSendSpecTemplate] );       			return;       		end;              	// set the outputting flag so that we queue any other data       	fEndpoint.fOutputting := true;              	// open a status dialog if we are in test mode.  The currentViewMode variable is found in the application's base view       	local viewMode := :GetViewMode();       	if viewMode = kTestModeSymbol then       		:OpenStatusDialog(        			{       				appSymbol: 		kAppSymbol,       				name: 			'vBarber,       				values:        					{       						statusText: 	kSendingString,       						titleText:		:GetInstanceName(),       						barber: 			true,       						closeBox:		nil,       						primary:       							{       								text:		kCancelButtonString,       								script:	func()       											begin       												stateMachine:DoEvent( 'Cancel, nil );       											end,       							},       					},       			});              	// Initialize the output profiling information.       	fEndpoint:InitializeOutputProfileRun( theData );       	       	// Setup the completion script and the async slot       	local theSendSpec := Clone( theSendSpecTemplate );       	theSendSpec.async := true;       	theSendSpec.completionScript := fCompletionScript;       	       	// If there is a target frame, then the user is outputting something       	// that can be sent in pieces.  Save away the data so that it can       	// be used in the completion script.       	if theSendSpec.target then       		theSendSpec.data := theData;       	       	// Do the real output       	try       		fEndpoint:StartOutputProfileRun();       		fEndpoint:Output( theData, theSendOptions, theSendSpec );       	onexception |evt.ex.comm| do       		begin       			:NotifyError( "In DoOutput Event", CurrentException(), toolInstanceBase );       			fEndpoint.fOutputting := nil;       			:CloseStatusDialog();       		end;       end,     declareSelf: 'DoOutput,     fCompletionScript:       func( ep, options, result )       begin       	// Pause the profiling information.       	ep:PauseOutputProfileRun();              	// If there was an error outputting the data, then notify the user and return;       	if result then       		begin       			ep:NotifyError( kErrorInOutputString, result, ep );       			ep.fOutputQueue:Reset();       			ep:StopOutputProfileRun();       			ep.fOutputting := nil;       			return;       		end;       		       	// If the specification has a send length, and there is still more data to send       	// then send it.  Otherwise clean up and return.       	// Self is the output specification frame.       	if self.data AND self.target.offset + self.target.length < Length( self.data ) then       		begin				       			// Update the offset  slot and continue outputting       			self.target.offset := self.target.offset + self.target.length;       			       			// If the offset plus length is greater than the length of the data,       			// then modify the length so that it only outputs what is left to       			// output and notify the user.       			if self.target.offset + self.target.length > Length( self.data ) then       				begin       					self.target.length := Length( self.data ) - self.target.offset;       					ep:NotifyAlert( kWrongChunkSizeString, ep:GetInstanceName() );       				end;              			// Restart the profiling information and output the next chunk of data       			ep:StartOutputProfileRun();       			ep:Output( self.data, options, self );       		end;       	else       		begin       			// Stop the profiling run.       			ep:StopOutputProfileRun();       			       			// set the outputting flag so that we queue any other data       			ep.fOutputting := nil;       			       			// Close the status dialog if we are in test mode       			if ep:GetViewMode() = kTestModeSymbol then       				ep:CloseStatusDialog();       			       			// Dequeue the next output object and send it on its way       			local queueData := ep.fOutputQueue:DeQueue();       			if queueData then       				ep:DoEvent( 'DoOutput, queueData );       		end;       end       ,     _proto: _v218_0    };AddStepForm(Connected, DoOutput);DoInput :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func( theInputSpecTemplate )       begin       	if kDebugOn then       		:DebugPrint( "In DoInput event", [theInputSpecTemplate] );              	// Setup the input specification       	local theSpec := Clone( theInputSpecTemplate );       	theSpec.InputScript := fInputScript;       	theSpec.PartialScript := fPartialScript;       	theSpec.fCompletionScript := fCompletionScript;              	// Inialize and begin the profile       	fEndpoint:InitializeInputProfileRun();       	fEndpoint:StartInputProfileRun();       	       	// Set the input specification       	try       		fEndpoint:SetInputSpec( theSpec );       	onexception |evt.ex.comm| do       		:NotifyError( "DoInput Event", CurrentException(), self );       end,     declareSelf: 'DoInput,     fInputScript:       func( ep, data, terminator, options )       begin       	// Stop the current profile run       	ep:StopInputProfileRun( data );       	       	// Post the data to the base view       	ep:GotInput( data, options );       	       	// If there is a target slot, then we are receiving a binary object.       	// Else if the user wanted to terminate after the input script, then       	// don't post another input script.       	// Else, reinitialize the profiling run and go on.       	if self.target then       		begin       			// Make sure there is still data to be received before posting another inputspec       			if terminator.byteCount + self.target.offset < Length( self.target.data ) then       				begin       					ep:SetInputSpec( nil );              					self.target.offset := self.target.offset + terminator.byteCount;       					ep:DoEvent( 'DoInput, [self] );       				end;       			else if self.terminate then       				ep:SetInputSpec( nil );       		end;       	else if self.terminate then       		ep:SetInputSpec( nil );       	else       		begin       			// Restart the profiling       			ep:InitializeInputProfileRun();       			ep:StartInputProfileRun();       		end;       end,     fPartialScript:       func( ep, data )        begin       	// Stop the current profile run       	ep:PauseInputProfileRun();       	       	// Send the data to the base view and flush the partial buffer       	ep:GotInput( data, nil );       	ep:FlushPartial();       	       	ep:StartInputProfileRun();       end,     fCompletionScript:       func( ep, options, result )       begin       	// Notify the user that something happened       	ep:NotifyError( "InputSpec CompletionScript", result, ep );       end,     _proto: _v218_0    };AddStepForm(Connected, DoInput);Cancel :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     declareSelf: 'Cancel,     action:       func()       begin       	:OpenStatusDialog(        					{       						appSymbol: 		kAppSymbol,       						name: 			'vStatusTitle,       						values:        							{       								statusText: 	kCancellingString,       								titleText:		:GetInstanceName(),       								barber: 			nil,       								closeBox:		nil,       								primary:			nil,       							},       					});              	// Cancel all outstanding stuff       	try       		fEndpoint:Cancel( nil );       	onexception |evt.ex.comm| do       		:NotifyError( "In Cancel", CurrentException(), toolInstanceBase );       end,     _proto: _v218_0    };AddStepForm(Connected, Cancel);DoHelper :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     declareSelf: 'DoHelper,     action:       func( type )       begin       	if kDebugOn then       		:DebugPrint( "HelperAction", type );       		       	:OpenStatusDialog(        			{       				appSymbol: 		kAppSymbol,       				name: 			'vStatusTitle,       				values:        					{       						statusText: 	kProcessingCommandString,       						titleText:		:GetInstanceName(),       						barber: 			true,       						closeBox:		nil,       						primary:       							{       								text:		kCancelButtonString,       								script:	func()       											begin       												stateMachine:DoEvent( 'Cancel, nil );       											end,       							},       					},       			});       	try       		if type = 'flushInput then       			fEndpoint:FlushInput();       		else if type = 'flushPartial then       			fEndpoint:FlushPartial();       		else if type = 'forceInput then       			begin       				local input := fEndpoint:Input();       				if input then       					:DoInput( input, toolInstanceBase );       			end;       		else if type = 'forcePartial then       			begin       				local input := fEndpoint:Partial();       				if input then       					:DoInput( input, toolInstanceBase );       			end;       		else if type = 'cancelSync then       			begin       				fEndpoint:Cancel(nil);       			end;       		else if type = 'cancelAsync then       			begin       				fEndpoint:Cancel( fCancelCompletionSpec );       			end;       		else        			begin       				// clone the option data so that it can be modified       				local option := {_proto: fFlushCBufferOption};       				option.data := TotalClone( option.data );       				       				if type = 'flushOutAsync then       					begin       						option.data.argList[1] := true;       						fEndpoint:Option( [fFlushCBufferOption], fFlushBufferCompletionSpec );       						return;       					end;       				else if type = 'flushOutSync then       					begin       						option.data.argList[1] := true;       						fEndpoint:Option( [fFlushCBufferOption], nil );       					end;       				else if type = 'flushInSync then       					begin       						option.data.argList[0] := true;       						fEndpoint:Option( [fFlushCBufferOption], nil );       					end;       				else if type = 'flushInAsync then       					begin       						option.data.argList[0] := true;       						fEndpoint:Option( [fFlushCBufferOption], fFlushBufferCompletionSpec );       						return;       					end;       			end;       	onexception |evt.ex.comm| do       		:NotifyError( "DoHelper Event", CurrentException(), toolInstanceBase );              		       	// Close the status dialog       	:CloseStatusDialog();       end,     fFlushCBufferOption:       {       	 type:		'option,       	 label:		kCMOSerialDiscard,       	 opCode:	opSetRequired,       	 form:		'template,       	 result:	nil,       	 data:		       	 	{        	 		argList: 	[nil, nil],       	 		typeList: 	['struct, 'boolean, 'boolean],       	 	}       },     fFlushBufferCompletionSpec:       {        async: 			true,        CompletionScript:	func( ep, options, result )        						begin        							if result then        								ep:NotifyError( "Endpoint Cancel", result, ep );        							        							// Close the status dialog       							ep:CloseStatusDialog();        						end,       },     fCancelCompletionSpec:       {       	async: 				true,       	CompletionScript:	func( ep, options, result )       							begin       								if result then       									ep:NotifyError( "Endpoint Cancel CompletionScript", result, ep );       								       								// Finally, close the status dialog       								ep:CloseStatusDialog();       							end,       },     _proto: _v218_0    };AddStepForm(Connected, DoHelper);StepDeclare(Endpoint FSM, DoHelper, 'DoHelper);Disconnect :=    {viewBounds: {left: 232, top: 96, right: 336, bottom: 200},     declareSelf: 'Disconnect,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Disconnect);Disconnect :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'Disconnect,     action:       func()       begin       	try       		fEndPoint:Disconnect( true, fCompletionSpec );       	onexception |evt.ex| do       		:DoEvent('DisconnectFailure, [CurrentException()]);       end,     fCompletionSpec:       {	async:					true,       	reqTimeout:			kNoTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('DisconnectFailure, [result]);       									else       										ep:DoEvent('DisconnectSuccess, nil);       								end,	},     _proto: _v218_0    };AddStepForm(Disconnect, Disconnect);Disconnect Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       func()       begin       	:DoEvent('UnBind, nil);       end,     declareSelf: 'DisconnectSuccess,     nextState: 'UnBind,     _proto: _v218_0    };AddStepForm(Disconnect, Disconnect Success);Disconnect Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action:       func(error)       begin       	:NotifyError( "Endpoint Disconnect", error, toolInstanceBase );              	:DoEvent('UnBind, nil);       end,     declareSelf: 'DisconnectFailure,     nextState: 'UnBind,     _proto: _v218_0    };AddStepForm(Disconnect, Disconnect Failure);UnBind :=    {viewBounds: {left: 232, top: 208, right: 336, bottom: 312},     declareSelf: 'UnBind,     _proto: _v473_0    };AddStepForm(Endpoint FSM, UnBind);UnBind :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'UnBind,     action:       func()       begin       	try       		fEndPoint:UnBind( fCompletionSpec );       	onexception |evt.ex| do       		:DoEvent('UnBindFailure, [CurrentException()]);       end,     fCompletionSpec:       {	async:					true,       	reqTimeout:			kNoTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('UnBindFailure, [result]);       									else       										ep:DoEvent('UnBindSuccess, nil);       								end,	},     _proto: _v218_0    };AddStepForm(UnBind, UnBind);UnBind Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       func()       begin       	:DoEvent('Dispose, nil);       end,     declareSelf: 'UnBindSuccess,     nextState: 'Dispose,     _proto: _v218_0    };AddStepForm(UnBind, UnBind Success);UnBind Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action:       func(exception)       begin       	:NotifyError( "Endpoint UnBind", exception, fsm );       	       	:DoEvent('Dispose, nil);       end,     declareSelf: 'UnBindFailure,     nextState: 'Dispose,     _proto: _v218_0    };AddStepForm(UnBind, UnBind Failure);Dispose :=    {viewBounds: {left: 232, top: 320, right: 336, bottom: 392},     declareSelf: 'Dispose,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Dispose);Dispose :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	// Get rid of the output queue       	fEndpoint.fOutputQueue:Reset();       	fEndpoint.fOutputQueue := nil;       	       	try       		fEndPoint:Dispose();       	onexception |evt.ex| do       		return :DoEvent('DisposeFailure, [CurrentException()]);       	       	:DoEvent('DisposeSuccess, nil);       end,     declareSelf: 'Dispose,     _proto: _v218_0    };AddStepForm(Dispose, Dispose);Dispose Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       func()       begin       	:DoEvent('CleanUp, nil);       end,     declareSelf: 'DisposeSuccess,     nextState: 'CleanUp,     _proto: _v218_0    };AddStepForm(Dispose, Dispose Success);Dispose Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action:       func(error)       begin       	:NotifyError( "Endpoint Dispose", error, toolInstanceBase );       	       	:DoEvent('CleanUp, nil);       end,     declareSelf: 'DisposeFailure,     nextState: 'CleanUp,     _proto: _v218_0    };AddStepForm(Dispose, Dispose Failure);Clean Up :=    {viewBounds: {left: 344, top: 16, right: 448, bottom: 56},     declareSelf: 'CleanUp,     _proto: _v473_0    };AddStepForm(Endpoint FSM, Clean Up);Clean Up :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	fEndpoint := nil;       	fQuiet := nil;       	fState := 'Disconnected;       	fConnectAction := nil;       	       	fInstantiateOptions := nil;       	fBindOptions := nil;       	fConnectOptions := nil;       	fListenOptions := nil;       	fAcceptOptions := nil;       	       	:CloseStatusDialog();       	       	AddDelayedSend( toolManagerBase, 'DeleteInstance, [toolInstanceBase, fEmergencyContext], 1 );       end,     declareSelf: 'CleanUp,     nextState: 'Genesis,     _proto: _v218_0    };AddStepForm(Clean Up, Clean Up);// After Script for Endpoint FSMthisView := Endpoint FSM;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/call kFSMCleanUpFunc with (thisView);constant |layout_Endpoint FSM.lyt| := Endpoint FSM;// End of file Endpoint FSM.lyt// Beginning of file ModalStatus.lyt_v467_0 :=    {viewBounds: {left: -4, top: 16, right: 180, bottom: 120},     New:       func( theToolManager, theStatusString, theTitleString )       begin       	// Build ourselves and setup the original status set.       	local slip := BuildContext( {_proto: self, toolManager: theToolManager} );       	       	slip:ViewSet(        			{       				appSymbol:		kAppSymbol,       				name:				'vStatusTitle,       				values:       					{       						statusText:	theStatusString,       						titleText:	theTitleString,       						primary:		nil,       						closeBox:	nil,       					},       			});              	// Now open the status dialog.       	slip:ModalDialog();       end,     viewSetupDoneScript:       func()       begin       	// If there are instances then disconnect each one       	// otherwise let the floater know we are finished       	local theInstances := toolManager:GetToolInstances();       	if Length( theInstances ) > 0 then       		theInstances[0]:DoEmergencyDisconnect( modalStatusBase );       	else       		:AllInstancesDisconnected();       	       	// be sure to let the status template do its thing       	inherited:?viewSetupDoneScript();       end,     toolManager: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.modalStatusBase := self;       	       	inherited:?ViewSetupFormScript();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	self.modalStatusBase := nil;       	       	inherited:?ViewQuitScript();       end,     InstanceDisconnected:       func()       begin       	// This is called once an instance is disconnected       	// check and see if there are more instances to disconnect       	// and do it.              	local theInstances := toolManager:GetToolInstances();       	if Length( theInstances ) > 0 then       		theInstances[0]:DoEmergencyDisconnect( modalStatusBase );       	else       		:AllInstancesDisconnected();       end,     AllInstancesDisconnected:       func()       begin       	AddDeferredSend( self, 'Close, nil );       end,     _proto: @467 /* protoStatusTemplate */    };// After Script for _v467_0thisView := _v467_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_ModalStatus.lyt| := _v467_0;// End of file ModalStatus.lyt// Beginning of file Serial Extras.lytserialInfoFloater :=    {viewBounds: {left: 0, top: 0, right: 184, bottom: 254},     viewFlags: 1,     viewFormat: 16,     width: 231,     height: 245,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target 			:= toolInstance:GetInstancePrefs();       	self.toolEndpoint 	:= toolInstance.instanceMachine:GetToolEndpoint();       	       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };serialInfoFloater_v218_0 :=    {text: "PCMCIA Sound Pass-through",     viewBounds: {left: 6, top: 1, right: 164, bottom: 17},     _proto: @218 /* protoStaticText */    };AddStepForm(serialInfoFloater, serialInfoFloater_v218_0);serialInfoFloater_v203_0 :=    {viewBounds: {left: 18, top: 1, right: 178, bottom: 17},     clusterChanged:       func()       begin       	target.(targetPath) := clusterValue;       	       	if clusterValue = kOnSymbol then       		begin       			// Setup the data to turn on sound passthrough       			local option := Clone( passthroughOptionTemplate );       			option.data := Clone( option.data );       			option.data.arglist := [true];       		       			toolEndpoint:Option( [option], nil );       		end;       	else       		toolEndpoint:Option( [passthroughOptionTemplate], nil );       end,     clusterValue: kOffSymbol,     passthroughOptionTemplate:       {       		type: 		'option,       		label: 		"msnd",				// Hardcoded for now...       		opCode: 		opSetRequired,       		form: 		'template,		       		result: 		nil,       		data:			{       							arglist: [nil],       							typelist: ['struct, 'boolean],       						},       },     viewSetupFormScript:       func()       begin       	// calculate and set the default clusterValue       	self.clusterValue := target.(targetPath);       end,     viewJustify: 8192,     targetPath: 'sound,     _proto: @203 /* protoRadioCluster */    };AddStepForm(serialInfoFloater, serialInfoFloater_v203_0);serialInfoFloater_v203_0_v202_0 :=    {buttonValue: kOnSymbol,     viewBounds: {left: 0, top: 0, right: 77, bottom: 16},     text: "On",     _proto: @202 /* protoRadioButton */    };AddStepForm(serialInfoFloater_v203_0, serialInfoFloater_v203_0_v202_0);serialInfoFloater_v203_0_v202_0 :=    {buttonValue: kOffSymbol,     viewBounds: {left: 88, top: 0, right: 161, bottom: 16},     text: "Off",     _proto: @202 /* protoRadioButton */    };AddStepForm(serialInfoFloater_v203_0, serialInfoFloater_v203_0_v202_0);serialInfoFloater_v0_2 :=    {     labelCommands:       [       	{item: "None", val: nil},       	{item: "XON/XOFF", val: 'software},       	{item: "Hardware", val: 'hardware}       ],     text: "Flow Control",     viewBounds: {left: 4, top: 6, right: 173, bottom: 20},     labelActionScript:       func(cmd)       begin       	inherited:?labelActionScript(cmd);       	       	:DoFlowControl( target.(targetPath) );       end,     viewJustify: 8192,     DoFlowControl:       func( newFlowValue )       begin       	local options :=        		[       			{	       				type: 		'option,       				label:		kCMOOutputFlowControlParms,       				opCode:		opSetRequired,       				form:			'template,       				result:		nil,       				data: {       							argList: [unicodeDC1, unicodeDC3, newFlowValue = 'software, newFlowValue = 'hardware, 0, 0],       							typeList: ['struct, 'byte, 'byte, 'boolean, 'boolean, 'boolean, 'boolean]        						}        			},       			{	       				type: 		'option,       				label:		kCMOInputFlowControlParms,       				opCode: 		opSetRequired,       				form:			'template,       				result:		nil,       				data: {       							argList: [unicodeDC1, unicodeDC3, newFlowValue = 'software, newFlowValue = 'hardware, 0, 0],       							typeList: ['struct, 'byte, 'byte, 'boolean, 'boolean, 'boolean, 'boolean]        						}        			},									       		];              	toolEndpoint:Option( options, nil );       end,     targetPath: 'flowControl,     _proto: _v190_0    };AddStepForm(serialInfoFloater, serialInfoFloater_v0_2);serialInfoFloater_v218_0 :=    {text: "Serial Event Flags",     viewBounds: {left: 6, top: 6, right: 164, bottom: 22},     viewJustify: 8192,     _proto: @218 /* protoStaticText */    };AddStepForm(serialInfoFloater, serialInfoFloater_v218_0);serialInfoFloater_v74_0 :=    {viewBounds: {left: 17, top: 1, right: 177, bottom: 127},     viewFlags: 1,     viewFormat: 0,     viewJustify: 8192,     targetPath: 'serialEventMask,     viewClass: 74 /* clView */    };AddStepForm(serialInfoFloater, serialInfoFloater_v74_0);serialInfoFloater_v74_0_v0_0 :=    {text: "Serial Break Started",     viewBounds: {left: 0, top: 0, right: 110, bottom: 16},     mask: kSerialEventBreakStartedMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_0);serialInfoFloater_v74_0_v0_1 :=    {text: "Serial Break Ended",     viewBounds: {left: 0, top: 2, right: 105, bottom: 18},     viewJustify: 8324,     mask: kSerialEventBreakEndedMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_1);serialInfoFloater_v74_0_v0_2 :=    {text: "DCD Asserted",     viewBounds: {left: 0, top: 2, right: 85, bottom: 18},     viewJustify: 8324,     mask: kSerialEventDCDAssertedMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_2);serialInfoFloater_v74_0_v0_3 :=    {text: "DCD Negated",     viewBounds: {left: 0, top: 2, right: 90, bottom: 18},     viewJustify: 8324,     mask: kSerialEventDCDNegatedMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_3);serialInfoFloater_v74_0_v0_4 :=    {text: "HSKi Negated",     viewBounds: {left: 0, top: 2, right: 85, bottom: 18},     viewJustify: 8324,     mask: kSerialEventHSKiNegatedMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_4);serialInfoFloater_v74_0_v0_5 :=    {text: "HSKi Asserted",     viewBounds: {left: 0, top: 2, right: 85, bottom: 18},     viewJustify: 8324,     mask: kSerialEventHSKiAssertedMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_5);serialInfoFloater_v74_0_v0_6 :=    {text: "Clock Detect Enable",     viewBounds: {left: 0, top: 2, right: 110, bottom: 18},     viewJustify: 8324,     mask: kSerialEventExtClkDetectEnableMask,     _proto: _v164_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_6);serialInfoFloater_v74_0_v0_7 :=    {viewBounds: {left: 92, top: 36, right: 158, bottom: 70},     viewLineSpacing: 30,     viewFlags: 10753,     targetPath: 'dcdTime,     defaultValue: 0,     filter: 'integer,     _proto: _v189_0    };AddStepForm(serialInfoFloater_v74_0, serialInfoFloater_v74_0_v0_7);serialInfoFloater_v226_0 :=    {     buttonClickScript:       func()       begin       	local option :=	{       								type:				'option,       								label:			kCMOSerialEventEnables,       								opCode:			opSetRequired,       								form:  			'template,		// not needed       								result: 			nil,			// not needed; returned       								data : {       									arglist: [       										target.serialEventMask,       										target.dcdTime,       									],       									typelist: [       										'struct,       										'ulong, 				// event masks       										'ulong, 				// DCD down time, in microseconds       									]       								}       							};              	toolEndpoint:Option( [option], nil );       end,     text: "Set Options",     viewBounds: {left: 0, top: 4, right: 75, bottom: 18},     viewJustify: 8396822,     _proto: @226 /* protoTextButton */    };AddStepForm(serialInfoFloater, serialInfoFloater_v226_0);serialInfoFloater_v226_0 :=    {     buttonClickScript:       func()       begin       	local option := {       			type:				'option,       			label:			kCMOSerialBreak,       			opCode:			opSetRequired,       			form:				'number,		       			result: 			nil,	       			data: 			target.breakTime,       		};              	toolEndpoint:Option( [option], nil );       end,     text: "Send Break",     viewBounds: {left: 6, top: 10, right: 81, bottom: 24},     viewJustify: 8396806     ,     _proto: @226 /* protoTextButton */    };AddStepForm(serialInfoFloater, serialInfoFloater_v226_0);serialInfoFloater_v0_7 :=    {viewBounds: {left: 88, top: 0, right: 168, bottom: 25},     viewFlags: 10753,     targetPath: 'breakTime,     filter: 'integer,     defaultValue: 0     ,     viewJustify: 8392768,     _proto: _v189_0    };AddStepForm(serialInfoFloater, serialInfoFloater_v0_7);// After Script for serialInfoFloaterthisView := serialInfoFloater;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Serial Extras.lyt| := serialInfoFloater;// End of file Serial Extras.lyt// Beginning of file Serial Info.lytserialInfoFloater :=    {viewBounds: {left: 0, top: 0, right: 225, bottom: 21},     viewFlags: 1,     viewFormat: 16,     width: 225,     height: 21,     GetConnectionSpeed:       func()       begin       	local toolEndpoint := toolInstance.instanceMachine:GetToolEndpoint();       	       	local speedOption :=        			{       				type:				'option,       				label:			kCMOSerialBitRate,       				opCode:			opGetCurrent,       				form: 			'number,		       				result:			nil,				// not needed; returned       				data: 			0,					// change to 19200       			};       			       	// Grab the current connection speed       	local retOptions := toolEndpoint:Option( [speedOption], nil );              	// return the current connection speed       	retOptions[0].data;       end       ,     viewClass: 74 /* clView */    };serialInfoFloater_v218_0 :=    {text: "Connection Speed",     viewBounds: {left: 12, top: 0, right: 110, bottom: 16},     _proto: @218 /* protoStaticText */    };AddStepForm(serialInfoFloater, serialInfoFloater_v218_0);serialInfoFloater_v218_0 :=    {text: "",     viewBounds: {left: 5, top: 0, right: 100, bottom: 16},     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local speed := :GetConnectionSpeed();       	       	self.text := NumberStr( speed ) && "bps";       	inherited:?ViewSetupFormScript();       end,     viewJustify: 8389632,     viewFont: ROM_fontSystem10,     _proto: @218 /* protoStaticText */    };AddStepForm(serialInfoFloater, serialInfoFloater_v218_0);// After Script for serialInfoFloaterthisView := serialInfoFloater;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Serial Info.lyt| := serialInfoFloater;// End of file Serial Info.lyt// Beginning of file Serial EndpointOptions.lytserialOptionsTemplate :=    {viewBounds: {left: 0, top: 0, right: 231, bottom: 186},     viewFlags: 1,     viewFormat: 0,     width: 231,     height: 186,     target: nil,     viewSetupChildrenScript:       func()       begin       	// If the user has not selected to use MNP, then hide       	// the appropriate picker       	if NOT target.useEC then       		ecPicker.viewFlags := bxor( ecPicker.viewFlags, vVisible );       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target := toolManager:GetToolPrefs();       	       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };serialOptionsTemplate_v0_0 :=    {viewBounds: {left: 12, top: 1, right: 190, bottom: 15},     text: "Open information slip after connect",     targetPath: 'openInfoSlip,     _proto: _v164_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_0);serialOptionsTemplate_v0_1 :=    {     labelCommands:       [       	{item: "300", value: k300bps},       	{item: "600", value: k600bps},       	{item: "1200", value: k1200bps},       	{item: "2400", value: k2400bps},       	{item: "4800", value: k4800bps},       	{item: "7200", value: k7200bps},       	{item: "9600", value: k9600bps},       	{item: "12000", value: k12000bps},       	{item: "14400", value: k14400bps},       	{item: "19200", value: k19200bps},       	{item: "38400", value: k38400bps},       	{item: "57600", value: k57600bps},       	{item: "115200", value: k115200bps},       	{item: "230400", value: k230400bps},       ],     text: "Speed",     viewBounds: {left: 12, top: 5, right: 110, bottom: 19},     targetPath: 'speed,     viewJustify: 8396800,     _proto: _v190_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_1);serialOptionsTemplate_v0_2 :=    {     labelCommands:       [       	{item: "5", value: k5DataBits},       	{item: "6", value: k6DataBits},       	{item: "7", value: k7DataBits},       	{item: "8", value: k8DataBits}       ]        ,     text: "Data Bits",     viewBounds: {left: 7, top: 0, right: 87, bottom: 14},     targetPath: 'dataBits     ,     viewJustify: 8406016,     _proto: _v190_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_2);serialOptionsTemplate_v0_3 :=    {     labelCommands:       [       	{item: "None", value: kNoParity},        	{item: "Odd", value: kOddParity},        	{item: "Even", value: kEvenParity}       ],     text: "Parity",     viewBounds: {left: 12, top: 5, right: 110, bottom: 19}     ,     targetPath: 'parity,     viewJustify: 8396800,     _proto: _v190_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_3);serialOptionsTemplate_v0_4 :=    {     labelCommands:       [       	{item: "1", value: k1StopBits},       	{item: "1.5", value: k1pt5StopBits},       	{item: "2", value: k2StopBits}       ],     text: "Stop Bits",     viewBounds: {left: 7, top: 0, right: 87, bottom: 14},     targetPath: 'stopBits     ,     viewJustify: 8406016,     _proto: _v190_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_4);serialOptionsTemplate_v0_5 :=    {     labelCommands:       [       	{item: "None", value: nil},       	{item: "XON/XOFF", value: 'software},       	{item: "Hardware", value: 'hardware}       ],     text: "Flow Control",     viewBounds: {left: 12, top: 5, right: 200, bottom: 19},     targetPath: 'flowControl,     viewJustify: 8396800,     _proto: _v190_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_5);serialOptionsTemplate_v0_6 :=    {text: "Use Error Corrected Connection",     viewBounds: {left: 11, top: 7, right: 201, bottom: 23},     targetPath: 'useEC,     viewJustify: 8396800,     _proto: _v164_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_6);ecPicker :=    {     labelCommands:       [       	{item: "MNP", value: kMNPCompressionMNP5},       	{item: "V42.bis", value: kMNPCompressionV42bis},       	'pickSeparator,       	{item: "Try Both", value: kMNPCompressionV42bis + kMNPCompressionMNP5},       ],     text: "Error Correction",     viewBounds: {left: 12, top: 79, right: 200, bottom: 93},     equalityTest:       // The value of this slot is used in the FindPreviousItem method       func( item, listElt )       begin       	// Make sure this element is a frame before trying the       	// equality.  This guarantees that pickSeparators are       	// weeded out.       	if IsFrame( listElt ) then       		if item = listElt.value then       			return true;       			       	nil;       end,     FindPreviousItem:       // This method can be overriden if necessary.       // It returns the item frame if found in labelCommands       func()       begin       	LFetch( labelCommands, target.(targetPath), 0, equalityTest, nil );       end,     targetPath: 'mnp,     _proto: _v190_0    };AddStepForm(serialOptionsTemplate, ecPicker);StepDeclare(serialOptionsTemplate, ecPicker, 'ecPicker);serialOptionsTemplate_v0_8 :=    {viewBounds: {left: 0, top: 101, right: 185, bottom: 128},     label: "Send Buffer Size",     entryFlags: 276993,     targetPath: 'sendBuffers,     _proto: _v189_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_8);serialOptionsTemplate_v0_9 :=    {viewBounds: {left: 0, top: 5, right: 185, bottom: 32},     label: "Receive Buffer Size",     entryFlags: 276993,     targetPath: 'receiveBuffers,     viewJustify: 8396800,     _proto: _v189_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_9);serialOptionsTemplate_v0_10 :=    {viewBounds: {left: 12, top: 4, right: 227, bottom: 20},     targetPath: 'location,     viewJustify: 8396800,     _proto: _v0_0    };AddStepForm(serialOptionsTemplate, serialOptionsTemplate_v0_10);// After Script for serialOptionsTemplatethisView := serialOptionsTemplate;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Serial EndpointOptions.lyt| := serialOptionsTemplate;// End of file Serial EndpointOptions.lyt// Beginning of file Serial Instance.lyt_v0_0 :=    {     GetInstantiateOptions:       func( theConnectDirection )       begin       	local options := nil;              	// Create the options based on whether we are using MNP or not       	if instancePrefs.useEC then        		begin       			options := 	[       				{	label:		kCMSMNPID,			       					type:		'service,       					result:		nil,       					opCode:		opSetRequired	},       								        				{	type: 		'option,       					label:		kCMOMNPCompression,       					opCode:		opSetRequired,       					form:		'number,       					result:		nil,       					data:		instancePrefs.mnp,       				}	,       				       				{	type: 		'option,       					label:		kCMOMNPDataRate,       					opCode:		opSetRequired,       					form:		'number,       					result:		nil,       					data:		instancePrefs.speed,       				}	];       		end        	else        		begin       			options := [       				 {	label:		kCMSAsyncSerial,       					type:		'service,       					result:		nil,       					opCode:		opSetRequired	} ];       		end;              	// Add a serial buffers option       	ArrayInsert( options, 	{	type:		'option,       								label:		kCMOSerialBuffers,       								opCode:		opSetRequired,       								form: 		'template,       								result: 	nil,       								data : 		{ 	arglist: [ Floor(StringToNumber(instancePrefs.sendBuffers)),        														   Floor(StringToNumber(instancePrefs.receiveBuffers)), 8,],       												typelist: [ 'struct, 'ulong, 'ulong, 'ulong, ] },       							}, 1 );       	       	// Add a chip hardware location if one exists.  This option must be specified       	// directly after the service option       	if StrFilled( instancePrefs.location ) then       		ArrayInsert( options, {	type:		'option,       									label: 		kCMOSerialHWChipLoc,       									opCode:		opSetRequired,       									form: 		'template,       									result:		nil,       									data:		{argList: [instancePrefs.location, 0],	//   kHWLocPCMCIAAnySlot       							 					 typeList: ['struct, ['array, 'char, 4], 'uLong]} }, 1 );              	// Create the serial IO params option       	AddArraySlot( options, {	type:		'option,       								label:		kCMOSerialIOParms,       								opCode:		opSetRequired,       								form:		'template,       								result:		nil,       								data:		{argList: [instancePrefs.stopBits, instancePrefs.parity, instancePrefs.dataBits, instancePrefs.speed],       											 typeList: ['struct, 'long, 'long, 'long, 'long] } } );       	       	// Create the flow control options if necessary							        	if instancePrefs.flowControl then        		begin       			AddArraySlot( options, {	type: 	'option,       										label:	kCMOOutputFlowControlParms,       										opCode: opSetRequired,       										form:	'template,       										result:	nil,       										data: {       											argList: [unicodeDC1, unicodeDC3, instancePrefs.flowControl = 'software, instancePrefs.flowControl = 'hardware, 0, 0],       											typeList: ['struct, 'byte, 'byte, 'boolean, 'boolean, 'boolean, 'boolean] } });       	       			AddArraySlot( options, {	type: 	'option,       										label:	kCMOInputFlowControlParms,       										opCode: opSetRequired,       										form:	'template,       										result:	nil,       										data: {       											argList: [unicodeDC1, unicodeDC3, instancePrefs.flowControl = 'software, instancePrefs.flowControl = 'hardware, 0, 0],       											typeList: ['struct, 'byte, 'byte, 'boolean, 'boolean, 'boolean, 'boolean] } });										       		end;              	// Return the options       	options;       end,     New:       func( theContext, theInstanceName, theEndpointPrefs )       begin       	local toolInstance := inherited:?New( theContext, theInstanceName, theEndpointPrefs );       	       	// Setup some more slots       	toolInstance.sound := kOffSymbol;       	       	// return the tool instance       	toolInstance;       end,     machineTemplate: GetLayout("Endpoint FSM.lyt"),     GetEndpointInfoTemplate:       func( when )       begin       	// Return the endpoint info template       	if (when = 'connect AND instancePrefs.openInfoSlip) OR when = 'user then       		endpointInfoTemplate;       end,     _proto: _v74_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Serial Instance.lyt| := _v0_0;// End of file Serial Instance.lyt// Beginning of file IrDA EndpointOptions.lyt_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 230, bottom: 108},     viewFlags: 1,     viewFormat: 0,     height: 108,     width: 251,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target := toolManager:GetToolPrefs();       	       	inherited:?ViewSetupFormScript();       end,     target: nil,     viewClass: 74 /* clView */    };_v74_0_v0_0 :=    {     labelCommands:       [{item: "9600", value: k9600bps},        {item: "19200", value: k19200bps},        {item: "38400", value: k38400bps},        {item: "57600", value: k57600bps},        {item: "115200", value: k115200bps},        {item: "4 mbit/s", value: 4194304}],     text: "Speed",     viewBounds: {left: 12, top: 0, right: 115, bottom: 16},     targetPath: 'speed,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_0);_v74_0_v0_1 :=    {     labelCommands:       [        {item: "3", value: 3},        {item: "8", value: 8},        {item: "12", value: 12},        {item: "16", value: 16},        {item: "20", value: 20},        {item: "25", value: 25},        {item: "30", value: 30},        {item: "40", value: 40},       ],     text: "Disc Time",     viewBounds: {left: 13, top: 0, right: 112, bottom: 16},     targetPath: 'discTime,     viewJustify: 8406016,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_1);_v74_0_v0_2 :=    {     labelCommands:       [        {item: "64", value: 64},        {item: "128", value: 128},        {item: "256", value: 256},        {item: "512", value: 512},        {item: "1024", value: 1024},        {item: "2048", value: 2048},       ],     text: "Buff Size",     viewBounds: {left: 12, top: 5, right: 115, bottom: 21},     targetPath: 'buffSize,     viewJustify: 8396800,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_2);_v74_0_v0_3 :=    {     labelCommands:       [        {item: "1", value: 1},        {item: "2", value: 2},        {item: "3", value: 3},        {item: "4", value: 4},        {item: "5", value: 5},        {item: "6", value: 6},        {item: "7", value: 7},       ],     text: "Num Buffs",     viewBounds: {left: 13, top: 0, right: 112, bottom: 16},     targetPath: 'numBuffs,     viewJustify: 8406016,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_3);_v74_0_v0_4 :=    {viewBounds: {left: 0, top: 12, right: 161, bottom: 39},     label: "Peer Name",     targetPath: 'peerName,     entryFlags: 276993,     viewJustify: 8396800,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_4);_v74_0_v0_5 :=    {viewBounds: {left: 0, top: 0, right: 76, bottom: 27},     label: "ID",     entryFlags: 10753,     targetPath: 'peerID,     viewJustify: 8406016,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_5);_v74_0_v0_6 :=    {viewBounds: {left: 0, top: 5, right: 161, bottom: 32},     label: "My Name",     targetPath: 'myName,     entryFlags: 276993,     viewJustify: 8396800,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_6);_v74_0_v0_7 :=    {viewBounds: {left: 0, top: 0, right: 76, bottom: 27},     label: "ID",     entryFlags: 10753,     targetPath: 'myID,     viewJustify: 8406016,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_7);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_IrDA EndpointOptions.lyt| := _v74_0;// End of file IrDA EndpointOptions.lyt// Beginning of file IrDA Instance.lyt_v0_0 :=    {     GetInstantiateOptions:       func( theConnectDirection )       begin       	local options :=        		[       			{	       				label:	"irda",       				type:		'service,       				opCode:	opSetRequired,       				result:	nil,	       			},        			{	       				label:	"sbps",				// serial bit rate       				type:		'option,       				opCode:	opSetRequired,       				result:	nil,       				form:		'template,       				data:	       				{       					arglist:	       					[       						instancePrefs.speed,       					],       					typelist:       					[       						kStruct,       						kULong,       					],	       				},       			},       			{	       				label:	"irrb",				// IrDA recv buffers info       				type:	'option,       				opCode:	opSetRequired,       				result:	nil,       				form:	'template,       				data:	       				{       					arglist:	       					[       						instancePrefs.buffSize,       						instancePrefs.numBuffs,       					],       					typelist:       					[       						kStruct,       						kULong,       						kULong,       					],	       				},       			},       			{	       				label:	"irld",				// IrDA link disconnect threshold       				type:	'option,       				opCode:	opSetRequired,       				result:	nil,       				form:	'template,       				data:	       				{       					arglist:	       					[       						instancePrefs.discTime,       					],       					typelist:       					[       						kStruct,       						kULong,       					],	       				},       			},       			{	       				label:	"irci",				// IrDA connect info       				type:	'option,       				opCode:	opSetRequired,       				result:	nil,       				form:	'template,       				data:	       				{       					arglist:	       					[       						Floor(StringToNumber(instancePrefs.myID)),       						Floor(StringToNumber(instancePrefs.peerID)),       						StrLen(instancePrefs.myName),       						StrLen(instancePrefs.peerName),       						instancePrefs.myName,       						instancePrefs.peerName,       					],       					typelist:       					[       						kStruct,       						kULong,       						kULong,       						kULong,       						kULong,       						[kArray, kChar, 0],       						[kArray, kChar, 0],       					],	       				},       			},       		];       	       	// Return the options       	options;       end,     machineTemplate: GetLayout("Endpoint FSM.lyt"),     _proto: _v74_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_IrDA Instance.lyt| := _v0_0;// End of file IrDA Instance.lyt// Beginning of file Modem EndpointOptions.lyt// Before Script for modemBaseDeclareGlobalFn('OpenPrefsTo, 1);modemBase :=    {viewBounds: {left: 0, top: 0, right: 206, bottom: 199},     viewFlags: 1,     viewFormat: 0,     height: 199,     width: 231,     GetOptions:       func( direction )       begin       	local protocol := nil;       	local compression := nil;       	       	// Add in the fallback specifier if the user has selected       	// to fallback if the choosen protocol was not established       	if GetView( protocolFallbackCheckbox ) AND target.protocolFallback then       		protocol := target.protocol + kModemECProtocolNone;       	else        		protocol := target.protocol;       		       	// Add in the fallback specifier if the user has selected       	// to fallback if the choosen compression was not established       	if GetView( compressionFallbackCheckbox ) AND target.compressionFallback then       		compression := target.compression + kMNPCompressionNone;       	else       		compression := target.compression;              	local options :=       		[       			{	label:		kCMSModemID,       				type:		'service,       				result:		nil,       				opCode:		opSetRequired},        				       			{	label:		kCMOModemECType,       				type:		'option,       				opCode:		opSetNegotiate,       				result:		nil,       				form: 		'number,       				data:		protocol },       		];              	// Add the hardware chip location option if necessary       	if target.location then       		ArrayInsert( options, {		type:		'option,       											label: 		kCMOSerialHWChipLoc,       											opCode:		opSetRequired,       											form: 		'template,       											result:		nil,       											data:		{argList: [target.location, 0],       									 					 typeList: ['struct, ['array, 'char, 4], 'uLong]} }, 1 );              	       	// if we are using something other than external EC then add a compression option       	if target.protocol = kModemECInternalOnly then	       		AddArraySlot( options, {	label:		kCMOMNPCompression,       											type:		'option,       											opCode:		opSetNegotiate,       											result:		nil,       											form: 		'number,       											data:		compression } );              	// return the correct options based on the current target       	{instantiate: options, bind: [], connect: [MakePhoneOption(target.phone)]};       end,     viewSetupChildrenScript:       func()       begin       	// Setup the compression/protocol checkboxes and pickers based       	// on the current protocol value.       	if band( target.protocol, kModemECProtocolNone ) <> 0 OR        		band( target.protocol, kModemECProtocolExternal ) <> 0 then       		begin       			compressionTypePicker.viewFlags := bxor( compressionTypePicker.viewFlags, vVisible );       			compressionFallbackCheckbox.viewFlags := bxor( compressionFallbackCheckbox.viewFlags, vVisible );       			       			// The fallback checkbox is only closed if protocol none was selected       			if band( target.protocol, kModemECProtocolNone ) <> 0 then       				protocolFallbackCheckbox.viewFlags := bxor( protocolFallbackCheckbox.viewFlags, vVisible );       		end;              end,     target: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target := toolManager:GetToolPrefs();       	       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };modemBase_v0_0 :=    {viewBounds: {left: 0, top: 0, right: -5, bottom: 32},     label: "Dial",     entryFlags: 264705,     targetPath: 'phone,     viewJustify: 8388656     ,     _proto: _v189_0    };AddStepForm(modemBase, modemBase_v0_0);modemBase_v203_0 :=    {viewBounds: {left: 14, top: 2, right: 140, bottom: 58},     clusterValue: 1,     clusterChanged:       func()       begin       	// Jam the correct value in the target frame anc       	// close or open the corresponding compression pickers       	// and checkboxes for each type.       	if clusterValue = 1 then        		begin       			target.(targetPath) := kModemECProtocolExternal;       			compressionFallbackCheckbox:Close();       			protocolFallbackCheckbox:Open();       			compressionTypePicker:Close();       		end        	else if clusterValue = 2 then        		begin       			target.(targetPath) := kModemECInternalOnly;       			compressionFallbackCheckbox:Open();       			protocolFallbackCheckbox:Open();       			compressionTypePicker:Open();       		end        	else if clusterValue = 3 then        		begin       			target.(targetPath) := kModemECProtocolNone;       			compressionFallbackCheckbox:Close();       			protocolFallbackCheckbox:Close();       			compressionTypePicker:Close();       		end;       end,     viewSetupFormScript:       func()       begin       	// Setyp the initial value of the cluster based on       	// the previously selected value       	if target.(targetPath) = kModemECInternalOnly then       		self.clusterValue := 2;       	else if target.(targetPath) = kModemECProtocolNone then       		self.clusterValue := 3;       	else       		self.clusterValue := 1;              	inherited:?viewSetupFormScript();       end,     targetPath: 'protocol,     viewJustify: 8320,     _proto: @203 /* protoRadioCluster */    };AddStepForm(modemBase, modemBase_v203_0);modemBase_v203_0_v202_0 :=    {buttonValue: 1,     viewBounds: {left: 8, top: 1, right: 120, bottom: 17},     text: "Use Modem's EC",     _proto: @202 /* protoRadioButton */    };AddStepForm(modemBase_v203_0, modemBase_v203_0_v202_0);modemBase_v203_0_v202_0 :=    {buttonValue: 2,     viewBounds: {left: 8, top: 20, right: 120, bottom: 36},     text: "Use Newton's EC",     _proto: @202 /* protoRadioButton */    };AddStepForm(modemBase_v203_0, modemBase_v203_0_v202_0);modemBase_v203_0_v202_0 :=    {buttonValue: 3,     viewBounds: {left: 8, top: 39, right: 120, bottom: 55},     text: "Use No EC",     _proto: @202 /* protoRadioButton */    };AddStepForm(modemBase_v203_0, modemBase_v203_0_v202_0);protocolFallbackCheckbox :=    {text: "Fallback if protocol not established",     viewBounds: {left: 14, top: 98, right: 204, bottom: 114},     targetPath: 'protocolFallback,     _proto: _v164_0    };AddStepForm(modemBase, protocolFallbackCheckbox);StepDeclare(modemBase, protocolFallbackCheckbox, 'protocolFallbackCheckbox);compressionFallbackCheckbox :=    {text: "Fallback if MNP not established",     viewBounds: {left: 14, top: 115, right: 204, bottom: 131},     targetPath: 'compressionFallback,     _proto: _v164_0    };AddStepForm(modemBase, compressionFallbackCheckbox);StepDeclare(modemBase, compressionFallbackCheckbox, 'compressionFallbackCheckbox);compressionTypePicker :=    {     labelCommands:       [       	{item: "MNP5", 	value: kMNPCompressionMNP5},        	{item: "V42bis", 	value: kMNPCompressionV42bis},       	'pickSeparator,        	{item: "Try Both", value: kMNPCompressionV42bis + kMNPCompressionMNP5},       ],     text: "Compression",     viewBounds: {left: 15, top: 133, right: 203, bottom: 147},     targetPath: 'compression,     FindPreviousItem:       // This method can be overriden if necessary.       // It returns the item frame if found in labelCommands       func()       begin       	LFetch( labelCommands, target.(targetPath), 0, equalityTest, nil );       end,     equalityTest:       // The value of this slot is used in the FindPreviousItem method       func( item, listElt )       begin       	// Make sure this element is a frame before trying the       	// equality.  This guarantees that pickSeparators are       	// weeded out.       	if IsFrame( listElt ) then       		if item = listElt.value then       			return true;       			       	nil;       end,     _proto: _v190_0    };AddStepForm(modemBase, compressionTypePicker);StepDeclare(modemBase, compressionTypePicker, 'compressionTypePicker);modemBase_v0_5 :=    {viewBounds: {left: 15, top: 152, right: 203, bottom: 167},     targetPath: 'location,     _proto: _v0_0    };AddStepForm(modemBase, modemBase_v0_5);modemBase_v226_0 :=    {     buttonClickScript:       func()       begin       	OpenPrefsTo("Modem");       end,     text: "Modem Prefs",     viewBounds: {left: 0, top: 10, right: 83, bottom: 24},     viewJustify: 8396822     ,     _proto: @226 /* protoTextButton */    };AddStepForm(modemBase, modemBase_v226_0);// After Script for modemBasethisView := modemBase;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Modem EndpointOptions.lyt| := modemBase;// End of file Modem EndpointOptions.lyt// Beginning of file Modem Instance.lyt_v0_0 :=    {     GetInstantiateOptions:       func( theConnectDirection )       begin       	local protocol := nil;       	local compression := nil;       	       	// Add in the fallback specifier if the user has selected       	// to fallback if the choosen protocol was not established       	if instancePrefs.protocolFallback then       		protocol := instancePrefs.protocol + kModemECProtocolNone;       	else        		protocol := instancePrefs.protocol;       		       	// Add in the fallback specifier if the user has selected       	// to fallback if the choosen compression was not established       	if instancePrefs.compressionFallback then       		compression := instancePrefs.compression + kMNPCompressionNone;       	else       		compression := instancePrefs.compression;              	local options :=       		[       			{	label:		kCMSModemID,       				type:		'service,       				result:		nil,       				opCode:		opSetRequired},        				       			{	label:		kCMOModemECType,       				type:		'option,       				opCode:		opSetNegotiate,       				result:		nil,       				form: 		'number,       				data:		protocol },       		];              	// Add the hardware chip location option if necessary       	if instancePrefs.location then       		ArrayInsert( options, {		type:		'option,       											label: 		kCMOSerialHWChipLoc,       											opCode:		opSetRequired,       											form: 		'template,       											result:		nil,       											data:		{argList: [instancePrefs.location, 0],       									 					 typeList: ['struct, ['array, 'char, 4], 'uLong]} }, 1 );              	       	// if we are using something other than external EC then add a compression option       	if instancePrefs.protocol = kModemECInternalOnly then	       		AddArraySlot( options, {	label:		kCMOMNPCompression,       											type:		'option,       											opCode:		opSetNegotiate,       											result:		nil,       											form: 		'number,       											data:		compression } );       	       	// Return the options       	options;       end,     GetConnectOptions:       func()       begin       	// Return the correct phone option       	[MakePhoneOption( instancePrefs.phone )];       end,     machineTemplate: GetLayout("Endpoint FSM.lyt"),     _proto: _v74_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Modem Instance.lyt| := _v0_0;// End of file Modem Instance.lyt// Beginning of file AppleTalk EndpointOptions.lytappleTalk :=    {viewBounds: {left: 0, top: 0, right: 206, bottom: 138},     viewFlags: 1,     viewFormat: 0,     NetworkChooserDone:       func( newServer, newZone )       begin       	SetValue( serverTextView.entryLine, 'text, newServer );       	SetValue( zoneTextView.entryLine, 'text, newZone );       end,     height: 138,     width: 231,     zone: nil,     target: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target := toolManager:GetToolPrefs();       	       	inherited:?ViewSetupFormScript();       end,     viewClass: 74 /* clView */    };filterLine :=    {viewBounds: {left: 0, top: 1, right: -5, bottom: 33},     label: "Server Type",     labelCommands:       [       	"  Macintosh",       	"Docker",       	"Workstation",       	"AFPServer",       	"DLMonitorAgnt",       	"Timbuktu Host",       ],     targetPath: 'type,     viewJustify: 8388656,     _proto: _v189_0    };AddStepForm(appleTalk, filterLine);StepDeclare(appleTalk, filterLine, 'filterLine);appleTalk_v226_0 :=    {     buttonClickScript:       func()       begin       	// If no type is specified then display a slip.  Otherwise       	// start a lookup based on that type       	if NOT StrFilled( target.type ) then       		:Notify(kNotifyAlert, EnsureInternal( kAppName ), EnsureInternal( kNoAppletalkFilterString ) );       	else        		begin       			local NBPLookupName := ParamStr( "=:^0@", [target.type] );       			GetRoot().netChooser:OpenNetChooser(nil, NBPLookupName, nil, self:Parent(), kChooserButtonString, kChooserHeaderString,        								  		   	    kChooserLookForString );       		end;       end,     text: "Choose Machine",     viewBounds: {left: 0, top: 5, right: 84, bottom: 25},     viewJustify: 8396822,     _proto: @226 /* protoTextButton */    };AddStepForm(appleTalk, appleTalk_v226_0);serverTextView :=    {text: "<not selected>",     viewBounds: {left: 0, top: 5, right: -5, bottom: 37},     label: "Server Name",     targetPath: 'server,     viewJustify: 8396848,     _proto: _v189_0    };AddStepForm(appleTalk, serverTextView);StepDeclare(appleTalk, serverTextView, 'serverTextView);zoneTextView :=    {text: "<not selected>",     viewBounds: {left: 0, top: 5, right: -5, bottom: 37},     label: "Server Zone",     targetPath: 'zone,     viewJustify: 8396848,     _proto: _v189_0    };AddStepForm(appleTalk, zoneTextView);StepDeclare(appleTalk, zoneTextView, 'zoneTextView);// After Script for appleTalkthisView := appleTalk;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_AppleTalk EndpointOptions.lyt| := appleTalk;// End of file AppleTalk EndpointOptions.lyt// Beginning of file AppleTalk Instance.lyt_v0_0 :=    {     GetInstantiateOptions:       func( theConnectDirection )       begin       	local options :=        		[       			{ label:	kCMSAppleTalkID,        			  type:		'service,        			  opCode:	opSetRequired       			},        			{ label:	kCMSAppleTalkID,        			  type:		'option,        			  opCode:	opSetRequired,       			  data:		{	arglist: ["adsp"],       							typelist:['struct, ['array, 'char, 4] ] }       			},       			{ label:	kCMOEndpointName,        			  type:		'option,       			  opCode:	opSetRequired,        			  data: 	{	arglist: [kADSPEndpoint],       							typelist:['struct, ['array, 'char, 0] ] }       			},       			{	label:		kCMOAppleTalkBuffer,       				type:		'option,       				opCode:		opSetRequired,       				data:		{       					arglist:		[       						kSndBuffer,       						511,		],       					typeList:	['struct,       						'ulong,       						'ulong,	],	},	},       			       			{	label:		kCMOAppleTalkBuffer,       				type:		'option,       				opCode:		opSetRequired,       				data:		{       					arglist:		[       						kRcvBuffer,       						511,		],       					typeList:	['struct,       						'ulong,       						'ulong,	],	},	},       			       			{	label:		kCMOAppleTalkBuffer,       				type:		'option,       				opCode:		opSetRequired,       				data:		{       					arglist:	[       						kAtnBuffer,       						511,		],       					typeList:	['struct,       						'ulong,       						'ulong,	],	},	}        		];       		       	// return the options       	options;       end,     GetConnectOptions:       func()       begin       	local NBPName := ParamStr( "^0:^1@^2", [instancePrefs.server, instancePrefs.type, instancePrefs.zone] );              	[MakeAppletalkOption( NBPName )];       end,     GetListenOptions:       func()       begin       	local NBPName := ParamStr( "^0:^1@^2", [instancePrefs.server, instancePrefs.type, instancePrefs.zone] );              	[MakeAppletalkOption( NBPName )];       end,     machineTemplate: GetLayout("Endpoint FSM.lyt"),     _proto: _v74_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_AppleTalk Instance.lyt| := _v0_0;// End of file AppleTalk Instance.lyt// Beginning of text file NIE Public API//	NIE 2.0 public platform file API definitions//	Copyright 1997 Apple Computer, Inc.//	All rights reserved.//	by Jim Schramif not knownGlobalFunctions.InetGrabLinkVerboseor not globalFnHelpStrings.InetGrabLinkVerbose then	begin		knownGlobalFunctions.DNSCancelRequests := 2;		knownGlobalFunctions.DNSGetAddressFromName := 3;		knownGlobalFunctions.DNSGetMailAddressFromName := 3;		knownGlobalFunctions.DNSGetMailServerNameFromDomainName := 3;		knownGlobalFunctions.DNSGetNameFromAddress := 3;		knownGlobalFunctions.InetAddNewLinkEntry := 1;		knownGlobalFunctions.InetAddNewLinkEntryInternal := 1;		knownGlobalFunctions.InetCancelCurrentRequest := 1;		knownGlobalFunctions.InetCancelLink := 3;		knownGlobalFunctions.InetDisconnectLink := 3;		knownGlobalFunctions.InetDisplayStatus := 3;		knownGlobalFunctions.InetGetAllLinksStatus := 0;		knownGlobalFunctions.InetGetDefaultLinkID := 0;		knownGlobalFunctions.InetGetLinkEntry := 1;		knownGlobalFunctions.InetGetLinkStatus := 1;		knownGlobalFunctions.InetGrabLink := 3;		knownGlobalFunctions.InetOpenConnectionSlip := 3;		knownGlobalFunctions.InetReleaseLink := 3;		knownGlobalFunctions.InetSetDefaultLinkID := 1;		knownGlobalFunctions.InetGetExceptionError := 1;		knownGlobalFunctions.InetGetErrorString := 1;		knownGlobalFunctions.InetBuildStatusFrame := 6;		knownGlobalFunctions.InetObjectToString := 1;		knownGlobalFunctions.RegInetLinkStatusChange := 3;		knownGlobalFunctions.UnRegInetLinkStatusChange := 1;		knownGlobalFunctions.InetIPAddressToString := 1;		knownGlobalFunctions.InetIPStringToAddress := 1;		knownGlobalFunctions.InetIsSameIPAddress := 2;		knownGlobalFunctions.InetIsSameIPAddressStr := 2;		knownGlobalFunctions.InetIsValidIPAddress := 1;		knownGlobalFunctions.InetIsValidIPAddressStr := 1;		knownGlobalFunctions.InetIsZeroIPAddress := 1;		knownGlobalFunctions.InetGetIPAddress := 1;		knownGlobalFunctions.InetGrabLinkVerbose := 3;		knownGlobalFunctions.InetReleaseLinkVerbose := 3;				globalFnHelpStrings.DNSCancelRequests := ['globalFn, "(clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.DNSGetAddressFromName := ['globalFn, "(name, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.DNSGetMailAddressFromName := ['globalFn, "(name, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.DNSGetMailServerNameFromDomainName := ['globalFn, "(name, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.DNSGetNameFromAddress := ['globalFn, "(address, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.InetAddNewLinkEntry := ['globalFn, "(newLinkInfo) linkID or nil", 'Run];		globalFnHelpStrings.InetAddNewLinkEntryInternal := ['globalFn, "(newLinkInfo) linkID or nil", 'Run];		globalFnHelpStrings.InetCancelCurrentRequest := ['globalFn, "(linkID)", 'Run];		globalFnHelpStrings.InetCancelLink := ['globalFn, "(linkID, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.InetDisconnectLink := ['globalFn, "(linkID, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.InetDisplayStatus := ['globalFn, "(linkID, statusView, statusFrame) statusView", 'Run];		globalFnHelpStrings.InetGetAllLinksStatus := ['globalFn, "() linksStatusFrame", 'Run];		globalFnHelpStrings.InetGetDefaultLinkID := ['globalFn, "() linkID", 'Run];		globalFnHelpStrings.InetGetLinkEntry := ['globalFn, "(linkID) linkEntry", 'Run];		globalFnHelpStrings.InetGetLinkStatus := ['globalFn, "(linkID) statusSymbol", 'Run];		globalFnHelpStrings.InetGrabLink := ['globalFn, "(linkID, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.InetOpenConnectionSlip := ['globalFn, "(linkID, clientFrame, clientSymbol) view or nil", 'Run];		globalFnHelpStrings.InetReleaseLink := ['globalFn, "(linkID, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.InetSetDefaultLinkID := ['globalFn, "(linkID) linkID or nil", 'Run];		globalFnHelpStrings.InetGetExceptionError := ['globalFn, "(exception) number", 'Run];		globalFnHelpStrings.InetGetErrorString := ['globalFn, "(error) string", 'Run];		globalFnHelpStrings.InetBuildStatusFrame := ['globalFn, "(linkID, infoStatus, infoError, infoText1, infoText2, infoText3) statusFrame", 'Run];		globalFnHelpStrings.InetObjectToString := ['globalFn, "(obj) string", 'Run];		globalFnHelpStrings.RegInetLinkStatusChange := ['globalFn, "(uniqueSymbol, clientFrame, clientSymbol) uniqueSymbol", 'Run];		globalFnHelpStrings.UnRegInetLinkStatusChange := ['globalFn, "(uniqueSymbol)", 'Run];		globalFnHelpStrings.InetIPAddressToString := ['globalFn, "(address) string", 'Run];		globalFnHelpStrings.InetIPStringToAddress := ['globalFn, "(addressStr) address", 'Run];		globalFnHelpStrings.InetIsSameIPAddress := ['globalFn, "(address1, address2) true or nil", 'Run];		globalFnHelpStrings.InetIsSameIPAddressStr := ['globalFn, "(addressStr1, addressStr2) true or nil", 'Run];		globalFnHelpStrings.InetIsValidIPAddress := ['globalFn, "(address) true or nil", 'Run];		globalFnHelpStrings.InetIsValidIPAddressStr := ['globalFn, "(addressStr) true or nil", 'Run];		globalFnHelpStrings.InetIsZeroIPAddress := ['globalFn, "(address) true or nil", 'Run];		globalFnHelpStrings.InetGetIPAddress := ['globalFn, "(whichAddress) address", 'Run];		globalFnHelpStrings.InetGrabLinkVerbose := ['globalFn, "(linkID, clientFrame, clientSymbol)", 'Run];		globalFnHelpStrings.InetReleaseLinkVerbose := ['globalFn, "(linkID, clientFrame, clientSymbol)", 'Run];	end;// End of text file NIE Public API// Beginning of file NIE Output.lyt_v180_0 :=    {viewBounds: {left: 0, top: 5, right: 216, bottom: 165},     target: nil,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	if toolInstance.instanceMachine then       		begin       			local options :=        					[       						{       							label:		"iuds",       							type:			'option,       							opCode:		opSetRequired,       							result:		nil,       							form:		'template,       							data:		{       											argList:	[ theReceiveAddress, theReceiverPort ],       											typeList:	['struct, ['array, 'byte, 4], 'short],       										},       						},       					];       			       			if theByte then       				ArrayInsert( options, 	{       											label:		"iexp",       											type: 		'option,       											opCode:		opSetRequired,       											result:		nil,       											form:		'template,       											data:		{       															argList:	[theByte],       															typeList:	['struct, 'byte],       														},       										}, 0 );        		       			// Send the data along       			toolInstance.instanceMachine:DoEvent( 'DoOutput, [data, options, sendSpec] );       		end;              	inherited:?ViewQuitScript();       end,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local thePrefs := toolInstance:GetInstancePrefs();       	       	self.target 				:= self;       	self.theReceiverPort 	:= thePrefs.connectPortInteger;       	self.theReceiveAddress	:= thePrefs.hostIPAddressArray;       	self.theByte				:= nil;       	       	inherited:?ViewSetupFormScript();       end,     theReceiverPort: nil,     theReceiveAddress: nil,     theByte: nil,     viewJustify: 80,     _proto: @180 /* protoFloatNGo */    };_v180_0_v229_0 :=    {title: kAppName,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.title := toolInstance:GetInstanceName();       	       	inherited:?ViewSetupFormScript();       end,     _proto: @229 /* protoTitle */    };AddStepForm(_v180_0, _v180_0_v229_0);_v180_0_v218_0 :=    {text: "Send To Address",     viewBounds: {left: 8, top: 23, right: 144, bottom: 39},     _proto: @218 /* protoStaticText */    };AddStepForm(_v180_0, _v180_0_v218_0);_v180_0_v0_2 :=    {viewBounds: {left: 0, top: 41, right: 0, bottom: 72},     filter: 'integer,     targetPath: 'theReceiveAddress,     viewJustify: 48,     _proto: _v74_0    };AddStepForm(_v180_0, _v180_0_v0_2);_v180_0_v0_3 :=    {viewBounds: {left: 0, top: 76, right: -5, bottom: 104},     label: "Send To Port Number:",     entryFlags: 10753,     targetPath: 'theReceiverPort,     filter: 'integer,     defaultValue: 0,     viewJustify: 48,     _proto: _v189_0    };AddStepForm(_v180_0, _v180_0_v0_3);_v180_0_v0_4 :=    {viewBounds: {left: 0, top: 109, right: -5, bottom: 136},     label: "Expedited Byte:",     entryFlags: 10753,     targetPath: 'theByte,     defaultValue: nil,     filter: 'integer,     viewJustify: 48,     _proto: _v189_0    };AddStepForm(_v180_0, _v180_0_v0_4);// After Script for _v180_0thisView := _v180_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Output.lyt| := _v180_0;// End of file NIE Output.lyt// Beginning of file NIE Instance.lyt_v0_0 :=    {machineTemplate: GetLayout("Endpoint FSM.lyt"),     GetBindOptions:       func( theConnectDirection )       begin       	[       		{	label:		"ilpt",					// set the local port       			type:		'option,       			opCode:		opSetRequired,       			result:		nil,       			form:		'template,       			data:		{       				arglist:		[       						instancePrefs.localPortInteger,			// local port number       						instancePrefs.useDefault,	],									// use default port       				typelist:	[	'struct,       						'short,       						'boolean,	],	},	},       	];       end,     GetConnectOptions:       func()       begin       	// return the connect options       	if instancePrefs.protocolType = kUDP then       		return [];              	local remoteAddr := instancePrefs.hostIPAddressArray;       	local options := TotalClone(       			[       				{	label:		"itrs",					// set the TCP remote socket       					type:			'option,       					opCode:		opSetRequired,       					result:		nil,       					form:			'template,       					data:		{       						arglist:		[       							Clone( remoteAddr[0] ),									// destination host addr - byte 1       							Clone( remoteAddr[1] ),									// destination host addr - byte 2       							Clone( remoteAddr[2] ),									// destination host addr - byte 3       							Clone( remoteAddr[3] ),									// destination host addr - byte 4       							Clone( instancePrefs.connectPortInteger),	],		// destination port number	       						typelist:	[	'struct,       							'byte,       							'byte,       							'byte,       							'byte,       							'short,	],	},	},       			] );       		       	// return the options       	options;       end,     GetInstantiateOptions:       func( theConnectDirection )       begin       	// return the instantiate options       	[       		{	label:		"inet",       			type:			'service,       			opCode:		opSetRequired,       			result:		nil,	},       		       		{	label:		"ilid",				// set the link id       			type:			'option,       			opCode:		opSetRequired,       			result:		nil,       			form:			'template,       			data:		{       				arglist:	[       					instancePrefs.linkID,	],       				typelist:	[	'struct,       					'ulong,	],	},	},       		       		{	label:		"itsv",				// set the transport protocol (TCP or UCP)       			type:		'option,       			opCode:		opSetRequired,       			result:		nil,       			form:		'template,       			data:		{       				arglist:	[       					instancePrefs.protocolType,	],       				typelist:	[	'struct,       					'ulong,	],	},	},       	];       end,     DoSetInputSpec:       func( theInputSpecification )       begin       	if instancePrefs.protocolType = kUDP then       		begin       			// If we were using test mode then the rcvFlags would already       			// be set.       			if NOT theInputSpecification.rcvFlags then       				theInputSpecification.rcvFlags := :GetDefaultReceiveFlags();              			theInputSpecification.rcvOptions :=        					[       						{       							label:	"iuss",       							type:		'option,       							opCode:	opGetCurrent,       							result:	nil,       							form:		'template,       							data:		{       											argList:	[ [0,0,0,0], 0 ],       											typeList:	['struct, ['array, 'byte, 4], 'short],       										},       						},       					];       		end;              	instanceMachine:DoEvent( 'DoInput, [theInputSpecification] );       end,     DoOutput:       func( data, sendOptions, sendSpec )       begin       	if instancePrefs.protocolType = kUDP then       		begin       			// If we were using test mode then the sendFlags would already       			// be set.       			if NOT sendSpec.sendFlags then       				sendSpec.sendFlags := :GetDefaultSendFlags();              			if call kViewIsOpenFunc with (outputFloater) then       				outputFloater:Close();       				       			outputFloater.toolInstance := toolInstanceBase;       			outputFloater.data := data;       			outputFloater.sendSpec := sendSpec;       			outputFloater:Open();       		end;       	else       		instanceMachine:DoEvent( 'DoOutput, [data, sendOptions, sendSpec] );       end,     inputFloater: nil,     Dispose:       func()       begin       	inherited:?Dispose();       	       //	if call kViewIsOpenFunc with (inputFloater) then       //		inputFloater:Close();              	if call kViewIsOpenFunc with (outputFloater) then       		outputFloater:Close();       		       	inputFloater := nil;       	outputFloater := nil;	       end,     New:       func( theContext, theInstanceName, theEndpointPrefs )       begin       	local toolInstance := inherited:?New( theContext, theInstanceName, theEndpointPrefs );              	// Setup the output floater used for UDP       	toolInstance.outputFloater := BuildContext( GetLayout("NIE Output.lyt") );       	       	// return the tool instance       	toolInstance;       end,     outputFloater: nil,     GetEndpointInfoTemplate:       func( when )       begin       	// Return the endpoint info template       	if (when = 'connect AND instancePrefs.openInfoSlip) OR when = 'user then       		endpointInfoTemplate;       end,     GotInput:       func( theData, theOptions )       begin       	// Just pass this on to the tool time base view       	:PrintToTerminal( theData, toolInstanceBase:GetInstanceName(), toolInstanceBase );       end,     _proto: _v74_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Instance.lyt| := _v0_0;// End of file NIE Instance.lyt// Beginning of file NIE Extras.lytstatView :=    {viewBounds: {left: 0, top: 0, right: 240, bottom: 124},     viewFlags: 1,     viewFormat: 16,     width: 250,     height: 124,     viewSetupFormScript:       func()       begin       	self.target := self;							// fudge the target       	self.prefs := toolManager:GetToolPrefs();       	       	// Setup the initial value from the cached value       	local thePrefs := toolManager:GetToolPrefs();       	if IsArray( thePrefs.dnsCache ) then       		theIPAddress := TotalClone( thePrefs.dnsCache );       	else       		theHostName := TotalClone( thePrefs.dnsCache );       	       	inherited:?viewSetupFormScript();		// this method is defined internally       end,     theHostName: nil,     target: nil,     theIPAddress: nil,     GetAddressCallback:       func( results, error )       begin       	linkStatusView := InetDisplayStatus( nil, linkStatusView, nil );              	if error then       		begin       			context:NotifyError( "In GetAddressCallback", error, toolManager );       			       			theIPAddress := [nil, nil, nil, nil];       		end;       	else if results AND Length( results ) > 0 then       		theIPAddress := TotalClone( results[0].resultIPAddress );       		       	:RedoChildren();       end,     GetHostNameCallback:       func( results, error )       begin       	linkStatusView := InetDisplayStatus( nil, linkStatusView, nil );              	if error then       		begin       			context:NotifyError( "In GetHostNameCallback", error, toolManager );       			       			theHostName := "";       		end;       	else if results AND Length( results ) > 0 then       		theHostName := Clone( results[0].resultDomainName );       	       	:RedoChildren();       end,     IPAddressFilled:       func( IPArray )       begin       	foreach dotNumber in IPArray do       		if NOT dotNumber then       			return nil;       	       	// return true       	true;       end,     linkStatusView: nil,     declareSelf: 'toolExtrasBaseView,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	if linkStatusView then       		linkStatusView := InetDisplayStatus( nil, linkStatusView, nil );       		       	inherited:?ViewQuitScript();       end,     viewClass: 74 /* clView */    };hostNameView :=    {viewBounds: {left: 0, top: 16, right: -10, bottom: 43},     label: "Host Name:",     entryFlags: 14849,     viewLineSpacing: 25,     targetPath: 'theHostName,     viewJustify: 8388656,     _proto: _v189_0    };AddStepForm(statView, hostNameView);StepDeclare(statView, hostNameView, 'hostNameView);statView_v226_0 :=    {     buttonClickScript:       func()       begin       	local thePrefs := toolManager:GetToolPrefs();       	       	// If linkStatusView is non-nil, then a lookup is already taking place.       	// Otherwise do the appropriate lookup       	if linkStatusView then       			:SysBeep();       	else if StrFilled( theHostName ) then       		begin       			linkStatusView := InetDisplayStatus( nil, nil, nil );        			InetDisplayStatus( nil, linkStatusView, {statusText: "Looking up IP Address..."} );       			       			// Save the old value so we can restore it next time this slip is opened       			thePrefs.dnsCache := TotalClone( theHostName );       			       			// Do the lookup       			DNSGetAddressFromName( theHostName, toolExtrasBaseView, 'GetAddressCallback );       		end;       	else if :IPAddressFilled( theIPAddress ) then       		begin       			linkStatusView := InetDisplayStatus( nil, nil, nil );        			InetDisplayStatus( nil, linkStatusView, {statusText: "Looking up Host Name..."} );       			       			// Save the old value so we can restore it next time this slip is opened       			thePrefs.dnsCache := TotalClone( theIPAddress );       			       			// Do the lookup       			DNSGetNameFromAddress( theIPAddress, toolExtrasBaseView, 'GetHostNameCallback );       		end;       	else       		:SysBeep();       end,     text: "Do DNS Lookup",     viewBounds: {left: 0, top: 10, right: 100, bottom: 30},     viewJustify: 8396822,     _proto: @226 /* protoTextButton */    };AddStepForm(statView, statView_v226_0);hostAddressView :=    {viewBounds: {left: 10, top: 10, right: -10, bottom: 46},     filter: 'integer,     targetPath: 'theIPAddress,     viewJustify: 8240,     _proto: _v74_0    };AddStepForm(statView, hostAddressView);StepDeclare(statView, hostAddressView, 'hostAddressView);// After Script for statViewthisView := statView;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Extras.lyt| := statView;// End of file NIE Extras.lyt// Beginning of file NIE Info.lyt_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 224, bottom: 88},     viewFlags: 1,     viewFormat: 16,     width: 224,     height: 88,     viewSetupFormScript:       func()       begin       	self.target := self;       	self.localIPAddressArray := InetGetIPAddress( 'localAddress );       	self.gatewayIPAddressArray := InetGetIPAddress( 'gatewayAddress );       	       	inherited:?viewSetupFormScript();       end,     target: nil,     gatewayIPAddressArray: nil,     localIPAddressArray: nil,     viewClass: 74 /* clView */    };_v74_0_v218_0 :=    {text: "Local IP Address",     viewBounds: {left: 4, top: 1, right: 138, bottom: 14},     _proto: @218 /* protoStaticText */    };AddStepForm(_v74_0, _v74_0_v218_0);_v74_0_v0_1 :=    {viewBounds: {left: 0, top: 10, right: 221, bottom: 41},     readOnly: true,     filter: 'integer,     targetPath: 'localIPAddressArray,     localIPAddressArray: nil,     _proto: _v74_0    };AddStepForm(_v74_0, _v74_0_v0_1);_v74_0_v218_0 :=    {text: "Gateway IP Address",     viewBounds: {left: 4, top: 46, right: 138, bottom: 59},     _proto: @218 /* protoStaticText */    };AddStepForm(_v74_0, _v74_0_v218_0);_v74_0_v0_3 :=    {viewBounds: {left: 0, top: 55, right: 221, bottom: 86},     readOnly: true,     filter: 'integer,     targetPath: 'gatewayIPAddressArray,     _proto: _v74_0    };AddStepForm(_v74_0, _v74_0_v0_3);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Info.lyt| := _v74_0;// End of file NIE Info.lyt// Beginning of file NIE EndpointOptions.lytendpointOptionsTemplate :=    {viewBounds: {left: 0, top: 0, right: 259, bottom: 170},     viewFlags: 1,     viewFormat: 0,     width: 259,     height: 190,     target: nil,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target := toolManager:GetToolPrefs();       	self.endpointOptionsBaseView := self;       	       	inherited:?ViewSetupFormScript();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	self.endpointOptionsBaseView := nil;       	       	inherited:?ViewQuitScript();       end,     endpointOptionsBaseView: nil,     viewClass: 74 /* clView */    };endpointOptionsTemplate_v0_0 :=    {viewBounds: {left: 12, top: 1, right: 190, bottom: 15},     text: "Open information slip after connect",     targetPath: 'openInfoSlip,     _proto: _v164_0    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v0_0);endpointOptionsTemplate_v203_0 :=    {viewBounds: {left: 0, top: 5, right: 115, bottom: 21},     clusterValue: 'tcp,     viewSetupFormScript:       func()       begin       	// setup the initial value       	self.clusterValue := target.(targetPath);       	       	inherited:?viewSetupFormScript();       end,     clusterChanged:       func()       begin       	target.(targetPath) := clusterValue;       	       	endpointOptionsBaseView:RedoChildren();       end,     targetPath: 'protocolType,     viewJustify: 8208,     _proto: @203 /* protoRadioCluster */    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v203_0);endpointOptionsTemplate_v203_0_v202_0 :=    {buttonValue: kTCP,     viewBounds: {left: 0, top: 0, right: 80, bottom: 16},     text: "TCP",     _proto: @202 /* protoRadioButton */    };AddStepForm(endpointOptionsTemplate_v203_0,endpointOptionsTemplate_v203_0_v202_0);endpointOptionsTemplate_v203_0_v202_0 :=    {buttonValue: kUDP,     viewBounds: {left: 88, top: 0, right: 133, bottom: 16},     text: "UDP",     _proto: @202 /* protoRadioButton */    };AddStepForm(endpointOptionsTemplate_v203_0,endpointOptionsTemplate_v203_0_v202_0);endpointOptionsTemplate_v218_0 :=    {text: "Connect to IP Address",     viewBounds: {left: 12, top: 5, right: 218, bottom: 21},     viewJustify: 8396800,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	if target.protocolType = kUDP then       		self.text := "Connect to IP Address (Default)";       	else       		self.text := "Connect to IP Address";       		       	inherited:?ViewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v218_0);endpointOptionsTemplate_v0_3 :=    {viewBounds: {left: 3, top: 0, right: -3, bottom: 31},     filter: 'integer,     viewJustify: 8240,     targetPath: 'hostIPAddressArray,     _proto: _v74_0    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v0_3);endpointOptionsTemplate_v0_4 :=    {viewBounds: {left: 0, top: 2, right: 191, bottom: 29},     label: "Connect Port Number",     entryFlags: 10753,     targetPath: 'connectPortInteger,     filter: 'integer,     defaultValue: 0,     viewJustify: 8396800,     _proto: _v189_0    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v0_4);connectPortText :=    {text: "",     viewBounds: {left: -60, top: 0, right: 0, bottom: 26},     viewJustify: 16422,     viewSetupFormScript:       func()       begin       	if target.protocolType = kTCP then       		self.text := "";       	else       		self.text := kPortDefaultString;       end,     _proto: @218 /* protoStaticText */    };AddStepForm(endpointOptionsTemplate, connectPortText);StepDeclare(endpointOptionsTemplate, connectPortText, 'connectPortText);endpointOptionsTemplate_v0_6 :=    {viewBounds: {left: 0, top: 120, right: 191, bottom: 147},     label: "Local Port Number",     entryFlags: 10753,     targetPath: 'localPortInteger,     filter: 'integer,     defaultValue: nil,     viewJustify: 8388608,     _proto: _v189_0    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v0_6);localPortText :=    {text: kPortRequiredForListenString,     viewBounds: {left: -60, top: 0, right: 0, bottom: 26},     viewJustify: 16422,     viewSetupFormScript:       func()       begin       	if target.protocolType = kTCP then       		self.text := kPortRequiredForListenString;       	else       		self.text := kPortRequiredString;       end,     _proto: @218 /* protoStaticText */    };AddStepForm(endpointOptionsTemplate, localPortText);StepDeclare(endpointOptionsTemplate, localPortText, 'localPortText);endpointOptionsTemplate_v0_8 :=    {text: "Let NIE pick a local port",     viewBounds: {left: -125, top: 5, right: -8, bottom: 21},     viewJustify: 8228,     targetPath: 'useDefault,     _proto: _v164_0    };AddStepForm(endpointOptionsTemplate, endpointOptionsTemplate_v0_8);// After Script for endpointOptionsTemplatethisView := endpointOptionsTemplate;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE EndpointOptions.lyt| := endpointOptionsTemplate;// End of file NIE EndpointOptions.lyt// Beginning of file NIE Endpoint Info.lyt_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 224, bottom: 28},     viewFlags: 1,     viewFormat: 16,     width: 224,     height: 28,     viewSetupFormScript:       func()       begin       	self.target := self;       	       	:GetCurrentOptions();       	       	inherited:?viewSetupFormScript();       end,     target: nil,     localPortInteger: nil,     GetCurrentOptions:       func()       begin       	local theOptions :=        		[       			{	label:		"ilpt",			       				type:			'option,       				opCode:		opGetCurrent,       				result:		nil,       				form:		'template,       				data:		{       					arglist:		[       							0,					// local port number       							nil,	],			// use default port       					typelist:	[	'struct,       							'short,       							'boolean,	],	},	       							},       		];              	local theEndpoint := toolInstance.instanceMachine:GetToolEndpoint();       	local retOptions := theEndpoint:Option( theOptions, nil );              	// Check for any errors in the options before printing them out       	if NOT toolInstance:DoOptionExceptionCheck( retOptions[0] ) then       		self.localPortInteger := retOptions[0].data.argList[0];       end,     viewClass: 74 /* clView */    };_v74_0_v0_0 :=    {readOnly: true,     label: "Local Port Number",     viewBounds: {left: -7, top: 0, right: 153, bottom: 24},     targetPath: 'localPortInteger,     localPortInteger: nil,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_0);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Endpoint Info.lyt| := _v74_0;// End of file NIE Endpoint Info.lyt// Beginning of file NIE Endpoint Extras.lytendpointExtrasView :=    {viewBounds: {left: 0, top: 0, right: 250, bottom: 244},     viewFlags: 1,     viewFormat: 16,     width: 250,     height: 244,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.toolEndpoint 			:= toolInstance.instanceMachine:GetToolEndpoint();       	self.target 					:= self;       	       	local thePrefs := toolInstance:GetInstancePrefs();              	self.joinMulticastAddress 	:= TotalClone( thePrefs.multicastJoin );       	self.leaveMulticastAddress	:= TotalClone( thePrefs.multicastLeave );       	self.broadcastArgList		:= TotalClone( thePrefs.broadcastArgs );              	inherited:?ViewSetupFormScript();       end,     broadcastArgList: nil,     leaveMulticastAddress: nil,     joinMulticastAddress: nil,     SetOptions:       func()       begin       	local options := [];       	local tempOption;       	       	if setJoinView:GetValue() then       		begin       			tempOption := TotalClone( kNIEMulticastOptionTemplate );       			tempOption.data.argList[2] := kJoinMulticastGroup;       			tempOption.data.argList[3] := joinMulticastAddress;       			       			AddArraySlot( options, tempOption );       		end;       		       	if setLeaveView:GetValue() then       		begin       			tempOption := TotalClone( kNIEMulticastOptionTemplate );       			tempOption.data.argList[2] := kLeaveMulticastGroup;       			tempOption.data.argList[3] := leaveMulticastAddress;       			       			AddArraySlot( options, tempOption );       		end;       		       	if setBroadcastView:GetValue() then       		begin       			tempOption := TotalClone( kNIEBroadcastOptionTemplate );       			tempOption.data.argList := broadcastArgList;       			       			AddArraySlot( options, tempOption );       		end;              	try       		local retOptions := toolEndpoint:Option( options, nil );       	onexception |evt.ex.comm| do       		toolInstance:NotifyError( "In SetOption", CurrentException(), toolInstance );       		       	// Print out any problems with the options       	foreach option in retOptions do       		toolInstance:DoOptionExceptionCheck( option );       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	local thePrefs := toolInstance:GetInstancePrefs();              	thePrefs.multicastJoin := TotalClone( self.joinMulticastAddress  );       	thePrefs.multicastLeave	:= TotalClone( self.leaveMulticastAddress );       	thePrefs.broadcastArgs := TotalClone( self.broadcastArgList );              	inherited:?ViewQuitScript();       end,     viewClass: 74 /* clView */    };setJoinView :=    {text: "Set join multi-cast group option",     viewBounds: {left: 10, top: 0, right: -10, bottom: 16},     viewJustify: 52,     GetValue:       func()       begin       	viewValue;       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(endpointExtrasView, setJoinView);StepDeclare(endpointExtrasView, setJoinView, 'setJoinView);endpointExtrasView_v0_1 :=    {viewBounds: {left: 10, top: 5, right: -10, bottom: 41},     filter: 'integer,     targetPath: 'joinMulticastAddress,     viewJustify: 8240,     _proto: _v74_0    };AddStepForm(endpointExtrasView, endpointExtrasView_v0_1);setLeaveView :=    {text: "Set leave multi-cast group option",     viewBounds: {left: 10, top: 10, right: -10, bottom: 26},     viewJustify: 8240,     GetValue:       func()       begin       	viewValue;       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(endpointExtrasView, setLeaveView);StepDeclare(endpointExtrasView, setLeaveView, 'setLeaveView);endpointExtrasView_v0_3 :=    {viewBounds: {left: 10, top: 5, right: -10, bottom: 41},     filter: 'integer,     targetPath: 'leaveMulticastAddress,     viewJustify: 8240,     _proto: _v74_0    };AddStepForm(endpointExtrasView, endpointExtrasView_v0_3);setBroadcastView :=    {text: "Set Broadcast Option",     viewBounds: {left: 10, top: 10, right: -10, bottom: 26},     viewJustify: 8240,     GetValue:       func()       begin       	viewValue;       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(endpointExtrasView, setBroadcastView);StepDeclare(endpointExtrasView, setBroadcastView, 'setBroadcastView);endpointExtrasView_v0_5 :=    {text: "Receive Broadcast Packets",     viewBounds: {left: 20, top: 5, right: -10, bottom: 21},     viewJustify: 8240,     targetPath: [pathExpr: 'broadcastArgList, 0];,     _proto: _v164_0    };AddStepForm(endpointExtrasView, endpointExtrasView_v0_5);endpointExtrasView_v0_6 :=    {text: "Receive Multi-Cast Packets",     viewBounds: {left: 20, top: 2, right: -10, bottom: 18},     viewJustify: 8240,     targetPath: [pathExpr: 'broadcastArgList, 1];,     _proto: _v164_0    };AddStepForm(endpointExtrasView, endpointExtrasView_v0_6);endpointExtrasView_v0_7 :=    {text: "Echo Multi-Cast Packets",     viewBounds: {left: 20, top: 2, right: -10, bottom: 18},     viewJustify: 8240,     targetPath: [pathExpr: 'broadcastArgList, 2];,     _proto: _v164_0    };AddStepForm(endpointExtrasView, endpointExtrasView_v0_7);endpointExtrasView_v226_0 :=    {     buttonClickScript:       func()       begin       	:SetOptions();       end,     text: "Set Options",     viewBounds: {left: 0, top: 10, right: 80, bottom: 26},     viewJustify: 8214,     _proto: @226 /* protoTextButton */    };AddStepForm(endpointExtrasView, endpointExtrasView_v226_0);// After Script for endpointExtrasViewthisView := endpointExtrasView;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Endpoint Extras.lyt| := endpointExtrasView;// End of file NIE Endpoint Extras.lyt// Beginning of file NIE LinkFSM.lyt// Before Script for Link Machine//	Newton Developer Technical Support Sample Code//	ThumbFSM - An NTK Finite State Machine Implementation//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes.// Eventually the following global functions will be defined...  for now let's tell NTK to be quiet about their use.DeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('InetOpenConnectionSlip, 3);DeclareGlobalFn('InetDisplayStatus, 3);DeclareGlobalFn('InetGetErrorString, 1);DeclareGlobalFn('InetGrabLink, 3);DeclareGlobalFn('InetReleaseLink, 3);DeclareGlobalFn('InetCancelLink, 3);DeclareGlobalFn('DNSGetAddressFromName, 3);DeclareGlobalFn('DNSCancelRequests, 2);Link Machine :=    {viewBounds: {left: 0, top: 0, right: 192, bottom: 2000},     fState: nil,     fProtocol: nil,     fLinkID: nil,     fLinkStatusView: nil,     declareSelf: 'LinkMachine,     fAbort: nil,     fConnectionSlipView: nil,     fGrabLinkReceiver: nil,     fReleaseLinkReceiver: nil,     fDNSReceiver: nil,     IsConnected:       func()       begin       	fState = 'Connected;       end,     IsDisconnected:       func()       begin       	fState = 'Disconnected;       end,     Instantiate:       func( theContext )       begin       	local obj := inherited:?instantiate();       	obj._parent := theContext;       	obj.fState := 'disconnected;       	       	obj;       end,     TraceFSM:       func(when, state, event, params)       begin       	// write(when); write("  "); write(state); write("  "); write(event); write("  "); print(params);       	// Trace code goes here       	nil;       end,     _proto: _v218_0    };Genesis :=    {terminal: true,     declareSelf: 'Genesis,     viewBounds: {left: 8, top: 16, right: -8, bottom: 56},     _proto: _v473_0    };AddStepForm(Link Machine, Genesis);Create :=    {     action:       func()       begin       	fsm.fState := 'Connecting;       	fsm.fAbort := nil;       	       	fsm.fConnectionSlipView := nil;       	fsm.fGrabLinkReceiver := nil;       	fsm.fReleaseLinkReceiver := nil;       	fsm.fProtocol := 1;							// 1 = TCP, 2 = UDP       	       	fsm.fLinkID := nil;       	fsm.fLinkStatusView := nil;              	if GetGlobalFn('InetGrabLink) then       		:DoEvent('OpenConnectionSlip, nil);       	else       		:DoEvent('Abort, nil);       end,     nextState: 'OpenConnectionSlip,     declareSelf: 'Create,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Genesis, Create);Open Connection Slip :=    {declareSelf: 'OpenConnectionSlip,     viewBounds: {left: 8, top: 16, right: -8, bottom: 120},     _proto: _v473_0    };AddStepForm(Link Machine, Open Connection Slip);Open Connection Slip :=    {declareSelf: 'OpenConnectionSlip,     action:       func()       begin       	fConnectionSlipView := InetOpenConnectionSlip( fLinkID, self, 'MConnectionSlipCallback );       end,     MConnectionSlipCallback:       func(what)       begin       	if what = kConnectSymbol then       		:DoEvent('OpenConnectionConnect, nil);       	else       		:DoEvent('OpenConnectionClose, nil);       end,     _proto: _v218_0    };AddStepForm(Open Connection Slip, Open Connection Slip);Open Connection Connect :=    {declareSelf: 'OpenConnectionConnect,     action:       func()       begin       	fLinkStatusView := InetDisplayStatus( fLinkID, nil, nil );       	       	:DoEvent('OpenLink, nil);       end,     nextState: 'OpenLink,     _proto: _v218_0    };AddStepForm(Open Connection Slip, Open Connection Connect);Open Connection Close :=    {declareSelf: 'OpenConnectionClose,     action:       func()       begin       	:DoEvent('CleanUp, nil);       end,     nextState: 'CleanUp,     _proto: _v218_0    };AddStepForm(Open Connection Slip, Open Connection Close);Abort :=    {declareSelf: 'Abort,     action:       func()       begin       	:NotifyAlert("The Newton Internet Enabler is not installed.", :GetCommToolName() );       	       	:DoEvent('CleanUp, nil);       end,     nextState: 'CleanUp,     _proto: _v218_0    };AddStepForm(Open Connection Slip, Abort);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	       	if fConnectionSlipView then       		fConnectionSlipView:Close();       	       	:DoEvent('CleanUp, nil);       end,     nextState: 'CleanUp,     _proto: _v218_0    };AddStepForm(Open Connection Slip, Cancel);Open Link :=    {declareSelf: 'OpenLink,     viewBounds: {left: 8, top: 16, right: -8, bottom: 136},     _proto: _v473_0    };AddStepForm(Link Machine, Open Link);Open Link :=    {declareSelf: 'OpenLink,     action:       func()       begin       	InetDisplayStatus(fLinkID, fLinkStatusView,	{statusText:	"Opening link..."} );       	       	fGrabLinkReceiver := self;	// remember this in case we need to call InetCancelLink later on...       	InetGrabLink(fLinkID, fGrabLinkReceiver, 'MGrabLinkCallback);       end,     MGrabLinkCallback:       func(linkID, newStatus, error)       begin       	fLinkID := linkID;		// make sure it's set...       	       	InetDisplayStatus(fLinkID, fLinkStatusView, newStatus);       	       	if error then       		return :DoEvent('OpenLinkFailure, [error]);       	       	if newStatus.linkStatus = 'Connected then       		:DoEvent('OpenLinkSuccess, nil);       end,     MCancelLinkCallback:       func(linkID, newStatus, error)       begin       	InetDisplayStatus(fLinkID, fLinkStatusView, newStatus);       	       	if error then       		:DoEvent('CancelLinkFailure, [error]);       	else       		:DoEvent('CancelLinkSuccess, nil);       end,     _proto: _v218_0    };AddStepForm(Open Link, Open Link);Open Link Success :=    {nextState: 'CloseLink,     declareSelf: 'OpenLinkSuccess,     action:       func()       begin       	fGrabLinkReceiver := nil;       	       	if fAbort then       		return :DoEvent('Abort, nil);       	       	fState := 'connected;       	fLinkStatusView := InetDisplayStatus( fLinkID, fLinkStatusView, nil );       	       	// Set the linkID       	local thePrefs := :GetToolPrefs();       	thePrefs.linkID := fLinkID;       end,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Open Link, Open Link Success);Open Link Failure :=    {nextState: 'CleanUp,     declareSelf: 'OpenLinkFailure,     action:       func(error)       begin       	fGrabLinkReceiver := nil;       	:NotifyError("Open Link", error, toolManagerBase);              	:DoEvent('CleanUp, nil);       end,     _proto: _v218_0    };AddStepForm(Open Link, Open Link Failure);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	       	fLinkStatus := {	statusText:	"Cancelling Open Link Request..."};       	InetDisplayStatus(fLinkID, fLinkStatusView, fLinkStatus);       	       	InetCancelLink(fLinkID, fGrabLinkReceiver, 'MCancelLinkCallback);       end,     _proto: _v218_0    };AddStepForm(Open Link, Cancel);Cancel Link Success := {declareSelf: 'CancelLinkSuccess, _proto: _v218_0};AddStepForm(Open Link, Cancel Link Success);Cancel Link Failure :=    {declareSelf: 'CancelLinkFailure,     action:       func(error)       begin       	:NotifyError("Cancel Open Link", error, toolManagerBase);       end,     _proto: _v218_0    };AddStepForm(Open Link, Cancel Link Failure);Close Link :=    {declareSelf: 'CloseLink,     viewBounds: {left: 8, top: 16, right: -8, bottom: 136},     _proto: _v473_0    };AddStepForm(Link Machine, Close Link);Close Link :=    {declareSelf: 'CloseLink,     action:       func()       begin       	fLinkStatusView := InetDisplayStatus( fLinkID, fLinkStatusView, {statusText: "Closing link..."} );       	       	fReleaseLinkReceiver := self;	// remember this in case we need to call InetCancelLink later on...       	InetReleaseLink(fLinkID, fReleaseLinkReceiver, 'MReleaseLinkCallback);       end,     MReleaseLinkCallback:       func(linkID, newStatus, error)       begin       	InetDisplayStatus(fLinkID, fLinkStatusView, newStatus);       	       	if error then       		:DoEvent('CloseLinkFailure, [error]);       	else       		:DoEvent('CloseLinkSuccess, nil);       end,     MCancelLinkCallback:       func(linkID, newStatus, error)       begin       	InetDisplayStatus(fLinkID, fLinkStatusView, newStatus);       	       	if error then       		:DoEvent('CancelLinkFailure, [error]);       	else       		:DoEvent('CancelLinkSuccess, nil);       end,     _proto: _v218_0    };AddStepForm(Close Link, Close Link);Close Link Success :=    {nextState: 'CleanUp,     declareSelf: 'CloseLinkSuccess,     action:       func()       begin       	fReleaseLinkReceiver := nil;       	       	:DoEvent('CleanUp, nil);       end,     _proto: _v218_0    };AddStepForm(Close Link, Close Link Success);Close Link Failure :=    {nextState: 'CleanUp,     declareSelf: 'CloseLinkFailure,     action:       func(error)       begin       	fReleaseLinkReceiver := nil;       	       	:NotifyError("Close Link", error, toolManagerBase);       	       	:DoEvent('CleanUp, nil);       end,     _proto: _v218_0    };AddStepForm(Close Link, Close Link Failure);Cancel :=    {declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	       	InetDisplayStatus(fLinkID, fLinkStatusView,	{statusText: "Cancelling Close Link Request...", titleText:	""} );       	       	InetCancelLink(fLinkID, fReleaseLinkReceiver, 'MCancelLinkCallback);       end,     _proto: _v218_0    };AddStepForm(Close Link, Cancel);Cancel Link Success := {declareSelf: 'CancelLinkSuccess, _proto: _v218_0};AddStepForm(Close Link, Cancel Link Success);Cancel Link Failure :=    {declareSelf: 'CancelLinkFailure,     action:       func(error)       begin       	:NotifyAlert("Cancel Close Link", error, toolManagerBase);       end,     _proto: _v218_0    };AddStepForm(Close Link, Cancel Link Failure);Clean Up :=    {declareSelf: 'CleanUp,     viewBounds: {left: 8, top: 16, right: -8, bottom: 56},     _proto: _v473_0    };AddStepForm(Link Machine, Clean Up);Clean Up :=    {     action:       func()       begin       	if fLinkStatusView then       		fLinkStatusView := InetDisplayStatus(fLinkID, fLinkStatusView, nil);       	fLinkID := nil;       	       	fProtocol := nil;       		       	fReleaseLinkReceiver := nil;       	fGrabLinkReceiver := nil;       	fConnectionSlipView := nil;              	fState := 'Disconnected;       end,     declareSelf: 'CleanUp,     nextState: 'Genesis,     _proto: _v218_0    };AddStepForm(Clean Up, Clean Up);// After Script for Link MachinethisView := Link Machine;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/call kFSMCleanUpFunc with (thisView);constant |layout_NIE LinkFSM.lyt| := Link Machine;// End of file NIE LinkFSM.lyt// Beginning of file NIE Prefs.lyt_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 250, bottom: 63},     viewFlags: 1,     viewFormat: 16,     width: 250,     height: 63,     viewSetupFormScript:       func()       begin       	// Setup the target       	self.target := toolManager:GetToolPrefs();       	       	inherited:?viewSetupFormScript();       end,     target: nil,     viewClass: 74 /* clView */    };_v74_0_v0_0 :=    {viewJustify: 52,     viewBounds: {left: 10, top: 0, right: -10, bottom: 16},     text: "On EmergencyShutdown leave endpoints connected",     targetPath: 'leaveEndpoints,     _proto: _v164_0    };AddStepForm(_v74_0, _v74_0_v0_0);_v74_0_v0_1 :=    {viewBounds: {left: 10, top: 5, right: -10, bottom: 21},     viewJustify: 8244,     targetPath: 'leaveLink,     text: "On EmergencyShutdown leave link up",     _proto: _v164_0    };AddStepForm(_v74_0, _v74_0_v0_1);_v74_0_v0_2 :=    {viewBounds: {left: 10, top: 5, right: -30, bottom: 21},     viewJustify: 8244,     targetPath: 'ignoreDisconnectEvent,     text: "Ignore endpoint disconnect events",     _proto: _v164_0    };AddStepForm(_v74_0, _v74_0_v0_2);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_NIE Prefs.lyt| := _v74_0;// End of file NIE Prefs.lyt// Beginning of file NIE Manager.lyt_v0_0 :=    {     emergencyShutdownTemplate:       {       	_proto:								GetLayout("ModalStatus.lyt"),       	toolPrefs:							nil,       	viewIdleScript:					func()       											begin       												// periodically check to see if the link has been torn down and close the view       												// when it has been       												if toolManager:ReadyToDispose() then       													begin       														AddDeferredSend( self, 'Close, nil );       														return 0;       													end;       												       												// Return the number of milliseconds to delay or nil to end idling.       												500;	       											end,       	AllInstancesDisconnected:		func()       											begin       												// Only do the postflight if the user wants the link       												// to be torn down.       												if NOT toolPrefs.leaveLink then       													begin       														:ViewSet(        																{       																	appSymbol:		kAppSymbol,       																	name:				'vStatusTitle,       																	values:       																		{       																			statusText:	kDisconnectingString,       																			titleText:	kDisconnectingLinkString,       																			primary:		nil,       																			closeBox:	nil,       																		},       																});       		       														toolManager:DoPostFlight();       														       														:SetupIdle( 500 );       													end;	       												else       													AddDeferredSend( self, 'Close, nil );       											end,       	viewSetupDoneScript:			func()       										begin       											self.toolPrefs := toolManager:GetToolPrefs();       											       											// If the user wants the endpoints left around then don't do       											// the default behavior       											if toolPrefs.leaveEndpoints then       												:AllInstancesDisconnected();       											else       												inherited:?viewSetupDoneScript();       										end,       	viewQuitScript:				func()       										begin       											self.toolPrefs := nil;       										       											inherited:?viewQuitScript();       										end,       },     DoOptionExceptionCheck:       func( option )       begin       	// Check and see whether the option failed or not       	if NOT option.result then       		return nil;       	else if option.result = -54021 then       		begin       			// Check for a couple of specific options       			if StrEqual( option.label, "iumc" ) then       				:NotifyError( "iumc : Option Failed", option.data.argList[1], self );       			else       				:NotifyError( option.label && ": Option Failed", option.result, self );       		end;       	else       		:NotifyError( "In DoOptionExceptionCheck", option.result, self );       		       	true;       end,     endpointInfoTemplate: GetLayout("NIE Endpoint Info.lyt"),     toolPrefsTemplate: GetLayout("NIE Prefs.lyt"),     GetPostflightName:       func()       begin       	// If the link is connected, then return       	// the Close Link string.       	// Otherwise implicitly return nil       	if linkMachine:IsConnected() then       		kCloseLinkString;       end,     toolInfoTemplate: GetLayout("NIE Info.lyt"),     instanceTemplate: GetLayout("NIE Instance.lyt"),     DoPreflight:       func()       begin       	// Send the link machine on its way       	linkMachine:DoEvent( 'Create, nil );       end,     linkMachine: nil,     endpointOptionsTemplate: GetLayout("NIE EndpointOptions.lyt"),     GetToolExtrasTemplate:       func()       begin       	// return the tools extra template       	if linkMachine:IsConnected() then       		toolExtrasTemplate;       end,     _proto: _v74_0,     GetEndpointName:       func()       begin       	// return the name if the link machine is connected.       	// Otherwise implicitly return nil       	if linkMachine:IsConnected() then       		kTCPIPString;       end,     GetPreflightName:       func()       begin       	// If the link is NOT connected, then return       	// the Open Link string.       	// Otherwise implicitly return nil       	if linkMachine:IsDisconnected() then       		kOpenLinkString;       end,     symbol: kNIEToolSymbol,     TranslateError:       func( error )       begin       	// Make sure it is an inet error before decoding       	if (error <= -60500 AND error >= -60599) OR       		(error <= -60700 AND error >= -60899) OR       		(error <= -60000 AND error >= -60099) then       			InetGetErrorString( error );       	else       		error;       end,     name: kNIEToolString,     New:       func( theContext, thePrefs )       begin       	local theInstance := inherited:?New( theContext, thePrefs );              	theInstance.linkMachine := GetLayout("NIE LinkFSM.lyt"):Instantiate( theInstance );              	// return the instance       	theInstance;       end,     Dispose:       func()       begin       	// Dispose of the link machine       	linkMachine:Dispose();       	       	inherited:?Dispose();       end,     GetToolInfoTemplate:       func()       begin       	// return the tools extra template       	if linkMachine:IsConnected() then       		toolInfoTemplate;       end,     GetDefaultSendFlags:       func()       begin       	// Return kPacket + kEOP       	kPacket + kEOP;       end,     endpointExtrasTemplate: GetLayout("NIE Endpoint Extras.lyt"),     EmergencyShutdown:       func()       begin       	if kDebugOn then       		:DebugPrint( "In EmergencyShutdown", [instances] );       		       	// Need to synchronously disconnect each of the instances from here       	// and only return once all instances have been disconnected.       	if NOT :ReadyToDispose() then       		begin       			local titleString;       			if toolPrefs.leaveEndpoints OR Length( instances) = 0 then       				titleString := kDisconnectingLinkString;       			else if toolPrefs.leaveLink OR Length( instances ) > 0 then       				titleString := ParamStr( kDisconnectingEndpoints, [name] );       				       			emergencyShutdownTemplate:New( self, kDisconnectingString, titleString );       		end;       end,     GetDefaultReceiveFlags:       func()       begin       	// return kPacket       	kPacket;       end,     defaultPrefs:       {       	 protocolType:				kTCP,       	 hostNameString:			"",        	 hostIPAddressArray: 	[0, 0, 0, 0],        	 connectPortInteger:		0,       	 localPortInteger:		nil,       	 linkID:						nil,       	 useDefault:				nil,       	 openInfoSlip:				nil,       	 leaveEndpoints:			nil,       	 leaveLink:					nil,       	 ignoreDisconnectEvent:	nil,       	 dnsCache:					"",       	 multicastJoin:			[0, 0, 0, 0],       	 multicastLeave:			[0, 0, 0, 0],       	 broadcastArgs:			[nil, nil, nil],       },     PreflightTerminalOutput:       func( theString )       begin       	// return the string appended with CRLF       	theString & unicodeCR & unicodeLF;       end,     ReadyToDispose:       func()       begin       	// We have five cases to handle here.       	// 1) The user wants the link and the endpoints disconnected and the link is disconnected       	// (which implicitly means the endpoints have disconnected) then return true       	// 2) The user does not want the link disconnected but does want the endpoints disconnected       	// and all the endpoints have been disconnected, then return true.       	// 3) The user wants the link disconnected but not the endpoints and the link has gone down,       	// then return true.       	// 4) The user doesn't want either the link or the endpoints disconnected so return true.       	// 5) all other cases return nil.       	if NOT toolPrefs.leaveLink AND NOT toolPrefs.leaveEndpoints AND linkMachine:IsDisconnected() then       		true;       	else if toolPrefs.leaveLink AND NOT toolPrefs.leaveEndpoints AND Length( instances ) = 0 then       		true;       	else if NOT toolPrefs.leaveLink AND toolPrefs.leaveEndpoints AND linkMachine:IsDisconnected() then       		true;       	else if toolPrefs.leaveLink AND toolPrefs.leaveEndpoints then       		true;       	else	       		nil;       end,     toolExtrasTemplate: GetLayout("NIE Extras.lyt"),     machineTemplate: GetLayout("Endpoint FSM.lyt"),     DoPostFlight:       func()       begin       	// Tell the link machine to close down the link       	linkMachine:DoEvent( 'CloseLink, nil );       end    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/SetPartFrameSlot( 'nieManager, thisView );constant |layout_NIE Manager.lyt| := _v0_0;// End of file NIE Manager.lyt// Beginning of file IrDA MUX Prefs.lyt_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 250, bottom: 33},     viewFlags: 1,     viewFormat: 16,     width: 250,     height: 33,     viewSetupFormScript:       func()       begin       	// Setup the target       	self.target := toolManager:GetToolPrefs();       	       	inherited:?viewSetupFormScript();       end,     target: nil,     viewClass: 74 /* clView */    };_v74_0_v0_0 :=    {viewBounds: {left: -2, top: 1, right: 222, bottom: 33},     alwaysCallPickActionScript: true,     label: kServiceNameString,     targetPath: 'serviceName,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_0);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_IrDA MUX Prefs.lyt| := _v74_0;// End of file IrDA MUX Prefs.lyt// Beginning of file IrDA MUX EndpointOptions.lyt_v74_0 :=    {viewBounds: {left: 0, top: 0, right: 230, bottom: 108},     viewFlags: 1,     viewFormat: 0,     height: 108,     width: 251,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	self.target := toolManager:GetToolPrefs();       	       	inherited:?ViewSetupFormScript();       end,     target: nil,     viewClass: 74 /* clView */    };_v74_0_v0_0 :=    {     labelCommands:       [{item: "9600", value: k9600bps},        {item: "19200", value: k19200bps},        {item: "38400", value: k38400bps},        {item: "57600", value: k57600bps},        {item: "115200", value: k115200bps},        {item: "4 mbit/s", value: 4194304}],     text: "Speed",     viewBounds: {left: 12, top: 0, right: 115, bottom: 16},     targetPath: 'speed,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_0);_v74_0_v0_1 :=    {     labelCommands:       [        {item: "3", value: 3},        {item: "8", value: 8},        {item: "12", value: 12},        {item: "16", value: 16},        {item: "20", value: 20},        {item: "25", value: 25},        {item: "30", value: 30},        {item: "40", value: 40},       ],     text: "Disc Time",     viewBounds: {left: 13, top: 0, right: 112, bottom: 16},     targetPath: 'discTime,     viewJustify: 8406016,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_1);_v74_0_v0_2 :=    {     labelCommands:       [        {item: "64", value: 64},        {item: "128", value: 128},        {item: "256", value: 256},        {item: "512", value: 512},        {item: "1024", value: 1024},        {item: "2048", value: 2048},       ],     text: "Buff Size",     viewBounds: {left: 12, top: 5, right: 115, bottom: 21},     targetPath: 'buffSize,     viewJustify: 8396800,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_2);_v74_0_v0_3 :=    {     labelCommands:       [        {item: "1", value: 1},        {item: "2", value: 2},        {item: "3", value: 3},        {item: "4", value: 4},        {item: "5", value: 5},        {item: "6", value: 6},        {item: "7", value: 7},       ],     text: "Num Buffs",     viewBounds: {left: 13, top: 0, right: 112, bottom: 16},     targetPath: 'numBuffs,     viewJustify: 8406016,     _proto: _v190_0    };AddStepForm(_v74_0, _v74_0_v0_3);_v74_0_v0_4 :=    {viewBounds: {left: 0, top: 12, right: 161, bottom: 39},     label: "Peer Name",     targetPath: 'peerName,     entryFlags: 276993,     viewJustify: 8396800,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_4);_v74_0_v0_5 :=    {viewBounds: {left: 0, top: 0, right: 76, bottom: 27},     label: "ID",     entryFlags: 10753,     targetPath: 'peerID,     viewJustify: 8406016,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_5);_v74_0_v0_6 :=    {viewBounds: {left: 0, top: 5, right: 161, bottom: 32},     label: "My Name",     targetPath: 'myName,     entryFlags: 276993,     viewJustify: 8396800,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_6);_v74_0_v0_7 :=    {viewBounds: {left: 0, top: 0, right: 76, bottom: 27},     label: "ID",     entryFlags: 10753,     targetPath: 'myID,     viewJustify: 8406016,     _proto: _v189_0    };AddStepForm(_v74_0, _v74_0_v0_7);// After Script for _v74_0thisView := _v74_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_IrDA MUX EndpointOptions.lyt| := _v74_0;// End of file IrDA MUX EndpointOptions.lyt// Beginning of file IrDA MUX Instance.lyt_v0_0 :=    {     GetInstantiateOptions:       func( theConnectDirection )       begin       	local options :=        		[       			{	       				label:	instancePrefs.serviceName,       				type:		'service,       				opCode:	opSetRequired,       				result:	nil,	       			},        			{	       				label:	"sbps",				// serial bit rate       				type:		'option,       				opCode:	opSetRequired,       				result:	nil,       				form:		'template,       				data:	       				{       					arglist:	       					[       						instancePrefs.speed,       					],       					typelist:       					[       						kStruct,       						kULong,       					],	       				},       			},       			{	       				label:	"irrb",				// IrDA recv buffers info       				type:	'option,       				opCode:	opSetRequired,       				result:	nil,       				form:	'template,       				data:	       				{       					arglist:	       					[       						instancePrefs.buffSize,       						instancePrefs.numBuffs,       					],       					typelist:       					[       						kStruct,       						kULong,       						kULong,       					],	       				},       			},       			{	       				label:	"irld",				// IrDA link disconnect threshold       				type:	'option,       				opCode:	opSetRequired,       				result:	nil,       				form:	'template,       				data:	       				{       					arglist:	       					[       						instancePrefs.discTime,       					],       					typelist:       					[       						kStruct,       						kULong,       					],	       				},       			},       			{	       				label:	"irci",				// IrDA connect info       				type:	'option,       				opCode:	opSetRequired,       				result:	nil,       				form:	'template,       				data:	       				{       					arglist:	       					[       						Floor(StringToNumber(instancePrefs.myID)),       						Floor(StringToNumber(instancePrefs.peerID)),       						StrLen(instancePrefs.myName),       						StrLen(instancePrefs.peerName),       						instancePrefs.myName,       						instancePrefs.peerName,       					],       					typelist:       					[       						kStruct,       						kULong,       						kULong,       						kULong,       						kULong,       						[kArray, kChar, 0],       						[kArray, kChar, 0],       					],	       				},       			},       		];       	       	// Return the options       	options;       end,     machineTemplate: GetLayout("Endpoint FSM.lyt"),     _proto: _v74_0    };// After Script for _v0_0thisView := _v0_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_IrDA MUX Instance.lyt| := _v0_0;// End of file IrDA MUX Instance.lyt// Beginning of text file Module Frames/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/SetPartFrameSlot( 'serialManager,	{		_proto:							GetLayout("protoToolManager"),		name: 							kSerialToolString, 		symbol: 							kSerialToolSymbol, 		endpointInfoTemplate: 		GetLayout("Serial Info.lyt"), 		endpointOptionsTemplate:	GetLayout("Serial EndpointOptions.lyt"),		endpointExtrasTemplate:		GetLayout("Serial Extras.lyt"),		instanceTemplate:				GetLayout("Serial Instance.lyt"),		emergencyShutdownTemplate:	GetLayout("ModalStatus.lyt"),		defaultPrefs:					{												location: 			nil, 												flowControl: 		nil, 												mnp:					nil, 												stopBits: 			k1StopBits, 												parity: 				kNoParity, 												dataBits: 			k8DataBits, 												speed: 				k115200bps,												sendBuffers: 		"1024",												receiveBuffers: 	"1024",												sound:				kOffSymbol,												serialEventMask:	0,												dcdTime:				0,												breakTime:			0,												openInfoSlip:		nil,											};	} );	SetPartFrameSlot( 'modemManager,  	{		_proto:							GetLayout("protoToolManager"),		name: 							kModemToolString, 		symbol: 							kModemToolSymbol, 		endpointOptionsTemplate: 	GetLayout("Modem EndpointOptions.lyt"), 		endpointInfoTemplate: 		nil, 		endpointExtrasTemplate: 		nil,		instanceTemplate:				GetLayout("Modem Instance.lyt"),		emergencyShutdownTemplate:	GetLayout("ModalStatus.lyt"),		defaultPrefs:					{												phone: 					"", 												protocol: 				kModemECProtocolExternal, 												compression: 			kMNPCompressionMNP5,												protocolFallback: 	true,												compressionFallback: true,												location: 				nil											},	} );	SetPartFrameSlot( 'appleTalkManager,  	{		_proto:							GetLayout("protoToolManager"),		name: 							kAppleTalkToolString, 		symbol: 							kAppleTalkToolSymbol, 		endpointOptionsTemplate: 	GetLayout("AppleTalk EndpointOptions.lyt"), 		endpointInfoTemplate: 		nil, 		endpointExtrasTemplate: 		nil,		instanceTemplate:				GetLayout("AppleTalk Instance.lyt"),		emergencyShutdownTemplate:	GetLayout("ModalStatus.lyt"),		defaultPrefs:					{												server: "",												type: "",												zone: "" 											},	} );	SetPartFrameSlot( 'IrDAManager,  	{		_proto:							GetLayout("protoToolManager"),		name: 							kIrDAToolString, 		symbol: 							kIrDAToolSymbol,		endpointOptionsTemplate: 	GetLayout("IrDA EndpointOptions.lyt"), 		instanceTemplate:				GetLayout("IrDA Instance.lyt"),		emergencyShutdownTemplate:	GetLayout("ModalStatus.lyt"),		defaultPrefs:					{												speed: 		k115200bps,										 		discTime: 	40,												buffSize: 	512,										 		numBuffs: 	1,										 		peerName: 	"X",										 		peerID: 		"0",										 		myName: 		"X",										 		myID: 		"0",											},	} );	SetPartFrameSlot( 'IrDAMUXManager,  	{		_proto:							GetLayout("protoToolManager"),		name: 							kIrDAMUXToolString, 		symbol: 							kIrDAMUXToolSymbol,		endpointOptionsTemplate: 	GetLayout("IrDA MUX EndpointOptions.lyt"), 		instanceTemplate:				GetLayout("IrDA MUX Instance.lyt"),		toolPrefsTemplate:			GetLayout("IrDA MUX Prefs.lyt"),		emergencyShutdownTemplate:	GetLayout("ModalStatus.lyt"),		defaultPrefs:					{												speed: 		k115200bps,										 		discTime: 	40,												buffSize: 	512,										 		numBuffs: 	1,										 		peerName: 	"X",										 		peerID: 		"0",										 		myName: 		"X",										 		myID: 		"0",										 		serviceName: "irmx",											},	} );// End of text file Module Frames// Beginning of file Standard Tools.lyt_v180_0 :=    {viewBounds: {left: 0, top: 0, right: 220, bottom: 110},     viewJustify: 80,     viewSetupFormScript:       func()       begin       	// start by being as big as possible, we will shrink later       	self.viewJustify := vjParentCenterH + vjParentCenterV;       	       	// Setup the bounds based on the screen size or based on        	// a couple of compile time flags.       	if kTestMinAppSize then       		self.viewBounds := SetBounds( 0,0, kMinWidth, kMinHeight );       	else if kTestMaxAppSize then       		self.viewBounds := SetBounds( 0,0, kMaxWidth, kMaxHeight );       	else       		self.viewBounds := SetBounds( 0,0,       										GetAppParams().appAreaWidth,       										GetAppParams().appAreaHeight );       	       	// shrink if needed for max width/height       	local bordersize := BAND(self.viewformat, vfPenMask)>>vfPenShift       								+BAND(self.viewformat, vfInsetMask)>>vfInsetShift;       	local fullScreenWidth := self.viewBounds.right-2*borderSize;       	local fullScreenHeight := self.viewBounds.bottom-2*borderSize;       	       	// Now setup the appropriate view bounds.       	if fullScreenWidth > kMaxWidth OR fullScreenHeight > kMaxHeight then       		begin       			// not full screen, so inset remainder and room for border       			self.viewBounds.right := Min(fullScreenWidth, kMaxWidth);       			self.viewBounds.bottom := Min(fullScreenHeight, kMaxHeight);       		end;       	else       		begin       	      // really are full screen, so no border, no clickable (assumes dragger)       			self.viewFormat := vfNone;       			self.viewFlags := BAND(self.viewFlags, BNOT(vClickable));       		end;       	       	// If the screen is too small then create a message to display to the user       	local message;       	if self.viewBounds.right < kMinWidth then       		message := "The display is to narrow for " & kAppName & " to open"       	else if self.viewBounds.bottom < kMinHeight then       		message := "The display is to short for " & kAppName & " to open";              	// If there is a message, then close the application and display the message       	if message then       		begin       			self.viewBounds := SetBounds( 0, 0, 0, 0 );       			GetRoot():Notify( kNotifyAlert, kAppName, message );       			AddDelayedCall(func(v)       				begin       					RemoveSlot(v, 'viewbounds);       					v:Close();       				end,       				[self], 1);       		end;              	inherited:?viewSetupFormScript();		// this method is defined internally       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	// Remove the RAM version of viewFormat so       	// that we don't have anything left over from       	// what was setup in the viewSetupFormScript       	RemoveSlot( self, 'viewFormat );       	       	inherited:?ViewQuitScript();       end,     ReorientToScreen: ROM_DefRotateFunc,     _proto: @180 /* protoFloatNGo */    };_v180_0_v218_0 :=    {text: kAboutString,     viewBounds: {left: 10, top: 25, right: -10, bottom: -25},     viewJustify: 240,     _proto: @218 /* protoStaticText */    };AddStepForm(_v180_0, _v180_0_v218_0);_v180_0_v229_0 :=    {title: kAppName,     viewBounds: {left: 0, top: 0, right: 72, bottom: 16},     _proto: @229 /* protoTitle */    };AddStepForm(_v180_0, _v180_0_v229_0);// After Script for _v180_0thisView := _v180_0;/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant |layout_Standard Tools.lyt| := _v180_0;// End of file Standard Tools.lyt// Beginning of text file Project Scripts/***      Newton Developer Technical Support Sample Code****      by Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/InstallScript := func( installPart )begin	call kInstallToolTimeModuleFunc with ( kNIEToolSymbol, installPart.nieManager );	call kInstallToolTimeModuleFunc with ( kSerialToolSymbol, installPart.serialManager );	call kInstallToolTimeModuleFunc with ( kModemToolSymbol, installPart.modemManager );	call kInstallToolTimeModuleFunc with ( kAppleTalkToolSymbol, installPart.appleTalkManager );	call kInstallToolTimeModuleFunc with ( kIrDAToolSymbol, installPart.IrDAManager );	call kInstallToolTimeModuleFunc with ( kIrDAMUXToolSymbol, installPart.IrDAMUXManager );end;	RemoveScript := func( removePart )begin	call kRemoveToolTimeModuleFunc with ( kNIEToolSymbol );	call kRemoveToolTimeModuleFunc with ( kSerialToolSymbol );	call kRemoveToolTimeModuleFunc with ( kModemToolSymbol );	call kRemoveToolTimeModuleFunc with ( kAppleTalkToolSymbol );	call kRemoveToolTimeModuleFunc with ( kIrDAToolSymbol );		call kRemoveToolTimeModuleFunc with ( kIrDAMUXToolSymbol );	end;// The DeletionScript is called when a package is scrubed from the// extras drawer, or when NTK downloads a new version of a package.// Since we don't want the the module preferences deleted each time// we download a new version, we first check to see whether kDebugOn// is true.SetPartFrameSlot( 'DeletionScript, func() 	begin		if NOT kDebugOn then			begin				call kDeleteToolTimeModuleFunc with ( kNIEToolSymbol );						call kDeleteToolTimeModuleFunc with ( kSerialToolSymbol );				call kDeleteToolTimeModuleFunc with ( kModemToolSymbol );				call kDeleteToolTimeModuleFunc with ( kAppleTalkToolSymbol );				call kDeleteToolTimeModuleFunc with ( kIrDAToolSymbol );					call kDeleteToolTimeModuleFunc with ( kIrDAMUXToolSymbol );				end;	end );	// This is necessary so that the icon is filed in the extensions folderSetPartFrameSlot( 'labels, '_extensions );// End of text file Project Scripts
<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Difference Between LockScreen and RefreshViews</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Difference Between LockScreen and RefreshViews</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Difference Between LockScreen and RefreshViews  (1/15/97)</H3><DL><DD>Q:    In the NPG, it states that sending a view the<CODE> view:LockScreen(nil)</CODE> message forces an "immediate update". How is this different from calling <CODE>RefreshViews</CODE>?<BR><BR>A:    When you post drawing commands (for example,  <CODE>DrawShape</CODE>) the system normally renders the shape on the screen immediately.  <CODE>:LockScreen(true) </CODE>provides a way to "batch up" the screen updates for multiple drawing calls.  Sending <CODE>:LockScreen(nil)</CODE> "unplugs" the temporary block that has been placed on the screen updater, causing all the batched drawing changes to be rendered on the LCD.<BR><BR>    <CODE>RefreshViews </CODE>tells the system to execute the commands needed to draw every view that has a dirty region.  You can think of it as working at a level "above" the screen lock routines.  When you send the message <CODE>Dirty</CODE>, it does not immediately cause the system to redraw the dirtied view, instead it adds the view to the dirty area for later redrawing.<BR><BR>    You could lock the screen, dirty a view with a <CODE>SetValue</CODE>, call <CODE>RefreshViews</CODE> (and not see an update) draw a few shapes, and then, when you unlock the screen, the refreshes to the dirty regions and your shapes will all appear at once.<BR><BR>    A bit more detail on the interaction between <CODE>LockScreen</CODE> and <CODE>RefreshViews</CODE>:<BR>    1. Does <CODE>LockScreen(nil)</CODE> result in a <CODE>RefreshViews</CODE>?<BR><BR>    No. <CODE>LockScreen(true)</CODE> just stops the hardware screen from updating from the offscreen buffer. <CODE>LockScreen(nil)</CODE> releases that lock which usually causes the hardware screen to update soon thereafter.<BR><BR>    2. While the screen is locked, will <CODE>SetValues</CODE> draw into the offscreen buffer?<BR><BR>    <CODE>SetValue</CODE> doesn't draw. Otherwise, see 1.<BR><BR>    3. While the screen is locked, what is the result of calling <CODE>RefreshViews</CODE>?<BR><BR>    It will draw any dirty views into the offscreen buffer.<BR></DL>
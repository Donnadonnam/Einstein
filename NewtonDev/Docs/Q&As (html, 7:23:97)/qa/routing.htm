<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Routing</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Routing</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="routing.htm">Routing</H2></A><UL><A HREF="#Printing_Resolution_72DPI/300DPI"><B> </B>Printing Resolution 72DPI/300DPI  (2/8/94)<BR></A><A HREF="#PICT_Printing_Limitations"><B> </B>PICT Printing Limitations  (6/9/94)<BR></A><A HREF="#Printing_Fonts_with_a_PostScript_Printer"><B> </B>Printing Fonts with a PostScript Printer  (7/26/94)<BR></A><A HREF="#Printing_Does_Not_Have_Access_to_My_Application_Slots"><B> </B>Printing Does Not Have Access to My Application Slots  (11/27/95)<BR></A><A HREF="#How_to_Open_the_Call_Slip_or_Other_Route_Slips"><B> </B>How to Open the Call Slip or Other Route Slips  (12/19/95)<BR></A><A HREF="#Routing_Multiple_Items"><B> </B>Routing Multiple Items  (5/15/96)<BR></A><A HREF="#When_to_Call_Inherited_ProtoPrintFormat_ViewSetupFormScript"><B> </B>When to Call Inherited ProtoPrintFormat ViewSetupFormScript  (1/6/97)<BR></A><A HREF="#Limitations_with_NewtOverview_Data_Class"><B> </B>Limitations with NewtOverview Data Class  (1/8/97)<BR></A><A HREF="#Beam_is_Partially_Available_for_Text_Routing"><B>NEW: </B>Beam is Partially Available for Text Routing  (5/22/97)<BR></A><A HREF="#Page_Sizes_Cannot_Be_Determined_Before_Printing_Begins"><B>NEW: </B>Page Sizes Cannot Be Determined Before Printing Begins  (7/10/97)<BR></A><A HREF="#Not_All_Drawing_Modes_Work_with_a_PostScript_Printer"><B>CHANGED: </B>Not All Drawing Modes Work with a PostScript Printer  (7/16/97)<BR></A></UL><A NAME="Printing_Resolution_72DPI/300DPI"><H3><HR><B> </B>Printing Resolution 72DPI/300DPI  (2/8/94)</A></H3><DL><DD>Q:    I've tried to print PICT resources; the picture was designed in Illustrator and copied to the clipboard as a PICT. The picture printed correctly but at a very low resolution. Is there any way of printing PICTs with a higher resolution?<BR><BR>A:    Currently the only supported screen resolution for PICT printing is 72dpi. This may change in future platforms, so stay tuned for more information.<BR></DL><A NAME="PICT_Printing_Limitations"><H3><HR><B> </B>PICT Printing Limitations  (6/9/94)</A></H3><DL><DD>Q:    My large pictures cannot print on my LaserWriter. Is there a maximum size Newton picture?<BR><BR>A:    The current PostScript printing system in the Newton ROMs is unable to print extremely large individual bitmap frames, the kind of pictures created using the NTK Picture editor or the GetPictAsBits routine. This is because in order to print these, the Newton must copy the bitmaps into an internal buffer. Thus the GetPictAsBits case fails (current limitation is a 168K buffer, but do not rely on a specific number for other Newton devices).<BR><BR>    Using the <CODE>GetNamedResource(..., 'picture)</CODE> routine, you can use PICT resources to be drawn in clPictureViews. MacOS PICT resources often contain multiple opcodes (instructions). For single-opcode PICTs, compression is done for the whole picture. You can check <I>Inside Macintosh </I>documentation for specifications of the PICT format.  If you are using very large bitmaps which you will print, you should use PICT resources composed of many smaller 'bitmap copy' opcodes because they will print much faster and more reliably on PostScript printers. This is because very large PICT opcodes printed to LaserWriters must be decompressed on the printer. The printer's decompression buffer is sometimes too small if the opcodes represent large bitmaps. Check your MacOS graphics application documentation for more information on segmenting your large PICTs into smaller pieces.  For some applications, you might have two versions of the PICTs, one for displaying (using <CODE>GetPictAsBits </CODE>for faster screen drawing), and a large tiled PICT for printing.<BR><BR>    Starting with Newton 2.1 OS, color PICTs (PICT 2) are supported. Colors will be interpolated into gray values.</DL><A NAME="Printing_Fonts_with_a_PostScript_Printer"><H3><HR><B> </B>Printing Fonts with a PostScript Printer  (7/26/94)</A></H3><DL><DD>Q:    When printing from my application on the Newton to a PostScript Laser printer, I noticethat the fonts are substituted.  Printing always looks fine on a fax or bitmap printer like the StyleWriter.<BR><BR> A:    Yes, this is true.The additional System font (Espy Sans) or any custom Newton font created with the Newton Font Tool is not printed directly to a LaserWriter because the fonts are missing in the PostScript font versions. Just printing Espy Sans (Newton system fonts) is currently not possible on the LaserWriter, but is possible on faxes and bitmap printer drivers, since the rendering for those is done inside the Newton.<BR><BR>    For the built-in Espy font, the troublesome characters are the Apple-specific ones, starting with Hex FC. The filled diamond is one of these characters, the specific tick box arrow is another.<BR><BR>    For printing, you might need to include bitmaps for special characters or words in your application in order to print them (that is, if the normal LaserWriter fonts are unacceptable)<BR><BR>    Note that if you want a monospaced font, check out the DTS sample "<CODE>MonacoTest</CODE>". That includes a font which will print as the monospaced Courier font.<BR></DL><A NAME="Printing_Does_Not_Have_Access_to_My_Application_Slots"><H3><HR><B> </B>Printing Does Not Have Access to My Application Slots  (11/27/95)</A></H3><DL><DD>Q:    Why can't I find my application slots from my print format?<BR><BR>A:    Print format does not have direct access to your application context because it is not a child of your application, so it cannot rely on the parent inheritance chain. All viewDefs should be designed so that they do not rely on your application being open or rely on state-specific information in your application. The application may be closed, or the user may continue to work in your application while the print/fax transport is imaging.<BR><BR>    Print format does have access to the <CODE>target</CODE> variable (it will contain the "body" of the data sent;  don't use <CODE>fields</CODE>.body). Note that if mulitiple items are sent, the value of <CODE>target</CODE> will change as the print format iterates over the list. Try to put the real "data" for the routing in the target using the view method <CODE>GetTargetInfo</CODE>.<BR><BR>    If, for some reason, you need to access slots from your application, you can access them using <CODE>GetRoot().(yourAppSymbol).theSlot</CODE>.<BR></DL><A NAME="How_to_Open_the_Call_Slip_or_Other_Route_Slips"><H3><HR><B> </B>How to Open the Call Slip or Other Route Slips  (12/19/95)</A></H3><DL><DD>Q:    How do I open the call slip (or other route slips) programmatically?<BR><BR>A:    Use the global function <CODE>OpenRoutingSlip</CODE>. Create a new item with the transport's <CODE>NewItem </CODE>method and add routing information such as the recipient information in the <CODE>toRef </CODE>slot. For the call slip, the transport symbol will be '<CODE>|phoneHome:Newton|</CODE>, but this approach will work for other transports. (For transports other than the call transports, you will also provide the data to route in the <CODE>item.body</CODE> slot.)<BR><BR><B>    Determining the value of the toRef slot<BR></B><BR>    The <CODE>toRef </CODE>slot in the item frame should contain an array of recipients in the form of nameRefs, which are the objects returned from <CODE>protoPeoplePicker </CODE>and other <CODE>protoListPicker</CODE>-based choosers. Each nameRef can be created from one of two forms: a cardfile soup entry, or just a frame of data with minimal slots. (The required slots vary depending on the transport. For instance, the current call transport requires only phone, name, and country.)<BR><BR>     1. Cardfile entry:<BR>        <CODE><PRE>        entry := myCursor:Entry();</PRE><BR></CODE>   <BR>     2. Create your own pseudo-entry:<BR>        <CODE><PRE>        entry := {        phone:"408 555 1234",        name: {first: "Glagly", last: "Wigout"},        country: "UK",    };</PRE><BR></CODE><BR><BR>    Make the entry into a "nameRef" using the nameRef's registered datadef -- an object which describes how to manipulate nameRefs of a specific class. Note that every transport stores its preferred nameRef class symbol in its <CODE>transport.addressingClass </CODE>slot. (Examples are <CODE>'|nameRef.phone|</CODE> and <CODE>'|nameRef.email|</CODE>).<BR><BR><CODE><PRE>local class := '|nameRef.phone|;local nameRef := GetDataDefs(class):MakeNameRef(myData, class);</PRE><BR></CODE><BR><BR><B>    Setting up the targetInfo Frame<BR></B><BR>    Your <CODE>GetTargetInfo </CODE>view method should return a <CODE>targetInfo </CODE>frame, consisting of <CODE>target </CODE>and <CODE>targetView </CODE>slots. Alternatively, you can create a frame consisting of these slots and pass it to <CODE>OpenRoutingSlip</CODE>. As a workaround to a ROM bug, you must also supply an <CODE>appSymbol </CODE>slot in the <CODE>targetInfo </CODE>frame containing your appSymbol. Note that <CODE>targetInfo.target </CODE>could be a multiple item target (see the <CODE>CreateTargetCursor </CODE>documentation for more info.)<BR><BR> <BR><B>    Opening The Slip<BR></B><BR>    You can use <CODE>OpenRoutingSlip </CODE>to open the slip after setting up slots such as <CODE>toRef </CODE>and <CODE>cc </CODE>within the item. You can use code such as the following:<BR><BR><CODE><PRE>/* example using Call Transport */local item, entry, class, nameRef;// just for testing, get an Name...entry := GetUnionSoup("Names"):Query(nil):Entry();item := TransportNotify('|phoneHome:Newton|, 'NewItem, [nil]);if item = 'noTransport or not item then    return 'noTransport; class := '|nameRef.phone|;nameRef := GetDataDefs(class):MakeNameRef(entry, class);item.toRef :=  [nameRef];targetInfo := {    targetView: getroot(),     target: {}/* for non-CALL transports, add your data here! */,     appsymbol: kAppSymbol    };// returns view (succeeded), or fails: nil or 'skipErrorMessageOpenRoutingSlip(item, targetInfo);</CODE></PRE></DL><A NAME="Routing_Multiple_Items"><H3><HR><B> </B>Routing Multiple Items  (5/15/96)</A></H3><DL><DD>Q:    How can my application route multiple items at one time?<BR><BR>A:    The target must be a "multiple item target" created with the <CODE>CreateTargetCursor </CODE>function.<BR>    For instance, your application could use a <CODE>GetTargetInfo </CODE>method like:<BR>        <BR>        <CODE><PRE>        func(reason)    begin        local t := CreateTargetCursor(kDataClassSymbol, myItemArray);        local tv := base; // the targetView            return {target: t, targetView: tv};    end;</PRE><BR></CODE><BR>    The first argument to <CODE>CreateTargetCursor</CODE> is used as the class of the target, which is used to determine what formats and transports are available. You must register formats on that data class symbol in your part's <CODE>InstallScript </CODE>function. <BR><BR>    The item array passed to <CODE>CreateTargetCursor</CODE> can contain any items, including soup entries or soup entry aliases. If you include soup entry aliases, they will automatically be resolved when accessing items using the <CODE>GetTargetCursor </CODE>function.<BR><BR>    Print formats that have their <CODE>usesCursors </CODE>slot set to <CODE>nil </CODE>will automatically print items on separate pages -- print formats must use the target variable to image the current item. To print multiple items, set the format <CODE>usesCursors </CODE>slot to <CODE>true </CODE>and use <CODE>GetTargetCursor(target, nil)</CODE> to navigate through the items. <BR><BR>    If either the format (the <CODE>usesCursors </CODE>slot) or the transport (the <CODE>allowsBodyCursors </CODE>slot) does not support cursors, the system will automatically split the items into separate Out Box items.</DL><A NAME="When_to_Call_Inherited_ProtoPrintFormat_ViewSetupFormScript"><H3><HR><B> </B>When to Call Inherited ProtoPrintFormat ViewSetupFormScript  (1/6/97)</A></H3><DL><DD>Q:    Does it matter when I call the inherited method in my <CODE>protoPrintFormat:viewSetupFormScript()</CODE>?<BR><BR>A:    Yes, you must call the inherited method before doing anything else in the <CODE>viewSetupFormScript</CODE>. <BR><BR>    Among other things, the inherited method sets up the page size. After calling the inherited method, you can call <CODE>self:LocalBox() </CODE>and get the correct page size.  Note that you cannot rely on the <CODE>protoPrintFormat.viewBounds</CODE> slot value. To position subviews within the print format centered or "full" width or height, use  view  justifications like centered, right, and full, or use <CODE>theEnclosingView:LocalBox()</CODE> to determine the exact size of the enclosing view.</DL><A NAME="Limitations_with_NewtOverview_Data_Class"><H3><HR><B> </B>Limitations with NewtOverview Data Class  (1/8/97)</A></H3><DL><DD>Q:    I want to use code like <CODE>CreateTargetCursor('newtOverview, myItemArray) </CODE>in my application to simplify my code which handles overviews. Why would my print format throw an exception when I use this method?<BR><BR>A:    There are limitations to using the <CODE>'newtOverview</CODE> symbol as your data class with <CODE>CreateTargetCursor</CODE>. The biggest limitation is that it requires you to support exactly the set of of datatypes: <CODE>['frame, 'text, 'view].</CODE> In other words, you must register a <CODE>protoFrameFormat</CODE> (by default, it handles <CODE>'frame</CODE> and <CODE>'text</CODE> dataTypes) and a <CODE>protoPrintFormat</CODE>. However, there are two other limitations not mentioned in the final documentation: the system does not guarantee that it will call your print format's <CODE>formatInitScript</CODE> method or a format's <CODE>SetupItem</CODE> method.<BR><BR>    This means that if your print format's <CODE>viewSetupFormScript</CODE> (or other code in the print format) assumed that the <CODE>formatInitScript</CODE> has been called, it could cause errors and/or exceptions.  The workaround to this would be to set a flag in the <CODE>formatInitScript</CODE>; if it was not set at the beginning of <CODE>viewSetupFormScript</CODE>, send your format the <CODE>formatInitScript</CODE> message. Other problems could occur with <CODE>SetupItem</CODE>, but you'd probably not see any errors or exceptions until you tried to beam/mail a frame to another device and then tried to Put Away the item.<BR>    <BR>    About the default overview class: when you use <CODE>CreateTargetCursor</CODE> to prepare a "multiple item target", you may be able to use this special <CODE>'newtOverview</CODE> symbol as your data class. If your application prints every item on separate pages (in other words, not multiple items on one page) and you  want to split beam and mail items into separate items in the Out Box, this might be useful to you. For more information, see the Newton Programmers Guide (not reference) in the Routing chapter "Using the Built-in Overview Data Class" section and the "Move It!" article in the Newton Technology Journal 2.02. Also, check out the MultiRoute DTS sample.</DL><A NAME="Beam_is_Partially_Available_for_Text_Routing"><H3><HR><B>NEW: </B>Beam is Partially Available for Text Routing  (5/22/97)</A></H3><DL><DD>Q:    My application doesn't support <CODE>'frame</CODE> dataTypes. Why is Beam available in my Action picker in Newton 2.1 OS? <BR><BR>A:    The Beam transport in Newton 2.1 OS supports the <CODE>'text</CODE> dataType. If any routing formats for your data supports text export (a <CODE>format.dataTypes</CODE> array  includes <CODE>'text</CODE>), Beam will be available. Unfortunately, there is a bug in current Newton 2.1 OS devices such that Beam does not convert the target to text before sending it. Transports that support sending text should use the <CODE>kItemToTextFunc</CODE>  function (in the Newton 2.x platform files), and that function calls the format's <CODE>TextScript</CODE> to convert the item to text. Since Beam does not do this, this gives the appearance that the item is being sent as <CODE>'frame</CODE>, a dataType that may not be supported by your application's routing formats. <BR><BR>    There are several workarounds (with the first choice recommended):<BR>    #1) Add support for the <CODE>'frame </CODE>datatype. In your routing format, add <CODE>'frame</CODE> to the <CODE>dataTypes</CODE> slot. This will allow all <CODE>'frame</CODE> transports, including  mail transports that can send attachments, to send mail with your application. This will allow your application to avoid text-specific bugs in Beam. For the best user interface, we recommend that you write stationery for your data so that users can view the item in the In Box or Out Box. See the Newton Programmers Guide and Reference for more information about writing and registering stationery. Note that you can test your application with Put Away, using  the built-in Beam transport as well as the DTS sample "Archive Transport".<BR><BR>    #2) Provide a text-only format that converts the item to text in the <CODE>format:SetupItem(...)</CODE>  method. If you don't support overviews or other mechanisms that use multiple item targets, change <CODE>item.body</CODE> to be a new frame of the form <CODE>{text: "the converted item to text", class: 'text}</CODE>. Note that this format should not also support the <CODE>'frame</CODE> dataType because you are destructively modifying the item.<BR><BR>    If you do support multiple item targets, you have to do more work because the items are not split up into seperate items before your <CODE>SetupItem</CODE> method is called. You can use the code like the following in your <CODE>SetupItem</CODE> format after calling the inherited method:<BR><BR><CODE><PRE>// get a 'cursor' to iterate over the items.// Note: this still returns a 'cursor' even if item.body wasn't reallocal cursor := GetTargetCursor(item.body, nil);local newArray := [];local entry := cursor:entry();while (entry) do    begin        // convert item to text in whatever way you normally do it...        // For instance, you might call your format's textscript...        entry := {            text: "blah blah" && entry.a && entry.b,            class: 'text            };         AddArraySlot(newArray, entry);        entry := cursor:Next();    end;        item.body := CreateTargetCursor(classof(item.body), newArray);// remember to return 'item' from SetupItemitem </PRE><BR>    </CODE>You might be wondering if you could route the <CODE>'frame</CODE> data by hiding the data in extra slots in <CODE>item.body</CODE>. If you did that, the item would be much larger than necessary to route <CODE>'frame</CODE> data, and will not be Put Away properly because the <CODE>'class</CODE> slot is set to <CODE>'text</CODE>, not your original data class). If you actually want to support <CODE>'text </CODE>and <CODE>'frame</CODE> dataTypes, use a single <CODE>protoFrameFormat</CODE> with dataTypes <CODE>['frame, 'text] </CODE>and do not convert the <CODE>item.body</CODE> as illustrated above. (This is actually recommendation #1 above).<BR><BR>     Note that <CODE>'text</CODE> stationery must be registered in order to view the item in the In Box and Out Box. Such stationery is not  necessarily installed on the receiving device. Some mail transport packages may have installed <CODE>'text</CODE> stationery, but you may choose not to rely on this. If you are interested in writing text stationery, see the DTS sample "MinMail" and the Newton Programmers Guide and Reference for more information about writing and registering stationery.<BR></DL><A NAME="Page_Sizes_Cannot_Be_Determined_Before_Printing_Begins"><H3><HR><B>NEW: </B>Page Sizes Cannot Be Determined Before Printing Begins  (7/10/97)</A></H3><DL><DD>Q:    How can my application or print format determine the exact page size before the print job actually starts?<BR><BR>A:    There is currently no supported API to do this. You cannot rely on a particular size for the actual printable area of the paper, nor the actual printable area as viewed by your print format. This is a limitation of the current Newton OS printing architecture.<BR><BR>    The correct way for a print format to determine its size is for the print format to call <CODE>:LocalBox()</CODE> in its <CODE>viewSetupFormScript</CODE>, <CODE>viewSetupChildrenScript</CODE>, or <CODE>viewSetupDoneScript</CODE>. This is only accurate during the current print job to the printer or fax driver. You cannot determine this size during Print/Fax preview, nor during  the print format's <CODE>formatInitScript</CODE>, nor in your application's on-screen views.<BR><BR>    The size of the print format is affected by many factors that can change before the print job begins. Factors include, but are not limited to, the printer driver, the printer/fax settings, and whether a fax cover page is selected in the Fax routing slip. (The least intuitive of these variables is the fax cover page, which also controls the fax header strip at the top of the page -- affecting the height of the printable area.)<BR><BR>    A common question is whether the print format <CODE>formatInitScript</CODE> can accurately determine the page height. This special format method was designed to allow time-intensive code to execute before the print job begins. For instance, fax timeouts might be less likely if some data were processed before fax connection. However, there is no supported API to find the actual final printable area that you will have when the system opens the print format view and sends the <CODE>viewSetupFormScript</CODE> message. Although you may be tempted to access undocumented slots which contain information about printer and page settings, this is both unsupported and results in unreliable bounds. (For instance, the undocumented fax cover page information affects the printable area but it's not stored in the printer nor page size structures.)<BR><BR>    On a related note, there are user configurations slots called <CODE>paperSize</CODE> and <CODE>paperSizes</CODE>. You cannot use these to reliably determine the printable area, nor can you create new <CODE>paperSizes</CODE>. See the Newton Programmer's Reference for more details. <BR><BR>    You could hard-code a specific size of "main view" within your print format, but you do so at the risk of view clipping or other cosmetic problems if the actual printable area is too small in either dimension. For instance, you could determine a "lowest common denominator" page size for many printer/fax combinations, and then center a view of that size within the print format. You may waste some vertical/horizontal space if the page is larger and you still risk clipping the view if the printed page is smaller than expected. If you took this approach, you might consider registering multiple print formats that contained different page size/layout assumptions.   We do not recommend hard-coding a specific page size, but it is appropriate for printing official forms whose size and design must be copied excactly. <BR><BR>    We strongly recommend that most applications assume nothing about page size before printing occurs. During printing, get the page size by calling <CODE>:LocalBox()</CODE> in the print format <CODE>viewSetupFormScript</CODE>, <CODE>viewSetupChildrenScript</CODE>, or <CODE>viewSetupDoneScript</CODE>. (Or, use the print format <CODE>pageHeight</CODE> and <CODE>pageWidth</CODE> slots in <CODE>viewSetupChildrenScript</CODE> or later.) Also, add new child views with appropriate center/full/right/relative justification to take advantage of varying page sizes. This will allow your application to work with any paper size, in any printer, and in any locale.</DL><A NAME="Not_All_Drawing_Modes_Work_with_a_PostScript_Printer"><H3><HR><B>CHANGED: </B>Not All Drawing Modes Work with a PostScript Printer  (7/16/97)</A></H3><DL><DD>Q:    It seems that not all drawing modes work with printing. Is that true?<BR><BR>A:    Yes, at least this is true for PostScript printers. PostScript behaves like layers of paint: you can not go back and change something. Anything that uses an invert mode will not work. Specifically, <CODE>modeXOR</CODE> and <CODE>modeNot</CODE> will not work.<BR><BR>    If you want to get the effect of white text on a black/filled background, use bit clear mode (<CODE>modeBic</CODE>) for drawing the text.<BR><BR>    This does not affect non-PostScript print drivers, for instance, Apple StyleWriter printers and Fax.</DL>
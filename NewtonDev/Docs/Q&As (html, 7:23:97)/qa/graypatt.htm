<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Interaction Between Transfer Modes and Gray Patterns</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Interaction Between Transfer Modes and Gray Patterns</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Interaction Between Transfer Modes and Gray Patterns  (1/15/97)</H3><DL><DD>Q:    How do the transfer modes interract with the new gray shades in Newton OS 2.1?<BR><BR>A:    Here is how the transfer modes interact with images. Colors are determined by looking up the value in the color table. For instance, white means that the indexed pixel value is white in the color table. All the NOT modes operate on the values from the color table. In other words, the pixel value is looked up before the NOT is applied.<BR><BR>    When the source and destination are different bit depths, the source is effectively expanded or shrunk to match the depth of the destination bitmap prior to drawing. When expanding, the index into the color table's bit pattern is repeated to fill the destination pixel.  For instance, a 2-bit index of 0x1 (binary 01) is expanded to 0x3 (binary 0011) for 4 bits, while a 2-bit index of 0x2 (binary 10) is expanded to 0xC (binary 1100).<BR><BR>    <CODE>modeOr</CODE> - Replaces pixels under the non-white part of the source image with source pixels.  If the source pixel is white, the destination pixel is unchanged.<BR><BR>    <CODE>modeXor</CODE> - Inverts pixels under the non-white part of the source image.  Destination pixels under the white part of the source image are unchanged.  This actually XORs the values in the source and destination pixels.  For example, for destination of 0xA (75% grey), source 0x0 (white) produces result 0xA (unchanged).  Source 0xF (black), produces result 0x5 (25% grey, or inverted).  Source pixels of other values have less utility.  For example, source 0x5 (25% grey) produces result 0xF (black), while source 0xA (75% grey) produces result 0x0 (white), and source 0x3 (50% grey) produces result 0x9 (slightly less than 75% grey).<BR><BR>    <CODE>modeBic</CODE> - Erases screen pixels under the non-white part of the source image, making them all white. Destination pixels under the white part of the source image are unchanged. This actually, does a bitwise NOT, so it is really only useful when source pixels are either 0 (white) or 0xF (black).  With other values, weird things happen, For example, destination 0xF with source 0xA produces result 0x5.  Destination 0x0 with source 0xA produces result 0x0.  Destination 0x3 with source 0xA produces result 0x1. <BR><BR>    <CODE>modeNotCopy</CODE> - Replaces screen pixels under the black part of the source image with white pixels. Screen pixels under the white part of the source image are made black.<BR><BR>    <CODE>modeNotOr</CODE> - Screen pixels under the black part of the source image are unchanged. Screen pixels under the white part of the source image are made black.<BR><BR>    <CODE>modeNotXor</CODE> - Screen pixels under the black part of the source image are unchanged. Screen pixels under the white part of the source image are inverted.</DL>
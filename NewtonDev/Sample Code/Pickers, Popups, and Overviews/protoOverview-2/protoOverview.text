// Text of project protoOverview written on 6/30/97 at 4:00 PM// Beginning of text file constants.f// Copyright ©1996 by Apple Computer, Inc. All rights reserved.// total number of items to createconstant kNumItems := 40 ;// indent for text in the shape displayed in the overviewconstant kTextIndent := 5 ;// End of text file constants.f// Beginning of file protoOverview.t// Before Script for "_view000"// Copyright ©1996-7 by Apple Computer, Inc. All rights reserved.nil_view000 :=    {title: "protoOverview",     viewBounds: {left: 0, top: 0, right: 224, bottom: 310},     viewFormat: 83951953,     ReorientToScreen: ROM_DefRotateFunc,     viewSetupFormScript:       func()       begin       	// Resize the app to fill the screen.       	// This will look very odd on watch-size or whiteboard-sized Newton       	// devices, but then again this sample isn't exactly useful to a user...       	local l := GetAppParams() ;       	self.viewBounds := RelBounds(l.appAreaLeft, l.appAreaTop, l.appAreaWidth, l.appAreaHeight);       end,     _proto: @157    };theOverview :=    {viewBounds: {left: 5, top: 20, right: -5, bottom: -25},     viewFlags: 517,     viewJustify: 240,     Abstract:       // required function       // returns the shape to show for an individual item in the overview       func(item,bbox)       begin       	// this is the basic form of a displayed item, just some text       	local result := [MakeText(item.data,       			bbox.left + kTextIndent, bbox.top, bbox.right,       			bbox.bottom-8),       		MakeRect(bbox.left,bbox.top,bbox.right,bbox.bottom)];              	result;       end,     viewSetupChildrenScript:       // Required       // use SetupAbstracts to setup the pictures shown       func()       begin       	// can get called when a scroll occurs       	// so clone off the cursor and move       	// it so that the first item is the       	// current top of the displayed items       	local curs := cursor:Clone();              	curs:Reset();       	curs:Move(topIndex);       	:SetupAbstracts(curs);       end,     HitItem:       // Required method       // called when an item is clicked on.       // NOTE: the hitIndex is relative to the top of the list       //       i.e., the item at the top is considered to be hitIndex 0.       //	     This func therefore has to compensate for scrolling.       func(hitIndex, xcoord, ycoord)       begin       	// check if it is a click in the checkbox       	if xcoord < selectIndent then       	    begin       			inherited:HitItem(hitIndex, xcoord, ycoord) ;              			// This code added for version 2 of the protoOverview sample...       			local curs := cursor:Clone();       			curs:Reset();       			curs:Move(topIndex);       		       			:SetupAbstracts(curs);         			:Dirty();       			// ...end of new code        		end;       	else begin       	       		// check hiliting state       		if myHilitedIndex <> hitIndex then       		begin       			hilitedIndex := hitIndex ;       			myHilitedIndex := hitIndex ;       		end ;       		else begin       			hilitedIndex := myHilitedIndex := nil ;       		end;       		:Dirty();              		// find the actual item hit       		// i.e., compensate for any scrolling offset       		local realIndex := hitIndex + topIndex;              		print("hit item" && realIndex & ":" && cursor:GetIndexEntry(realIndex).data);       	end ;       end,     Scroller:       // Required       // This method just updates the savedIndex slot that keeps       // track of the real index of the topmost displayed item.       //       // The viewSetupChildrenScript will refresh the display and put        // the item with the topIndex at the top of the displayed items.       func(dir)       begin       	local newIndex := Min(Max(topIndex + dir, 0), kNumItems-1);       	local realDir := topIndex - newIndex ;              	// can get called when the list is at the top or       	// bottom, so check if we need to do real work       	if realDir <> 0 then       	begin       		// update the index for the item at the top of the display       		topIndex := newIndex ;              		// update the hilitedIndex if there is one       		// use my value since protoOverview tends to        		// reset the hilitedIndex when not appropriate       		if myHilitedIndex then       		begin       			myHilitedIndex := myHilitedIndex + realDir ;       			hilitedIndex := myHilitedIndex ;       		end;		              		// let viewSetupChildrenScript do the work       		:RedoChildren();       	end ;       end,     cursor:       // this is the encapsulating cursor object       // this is required since protoOverivew assumes that a       // cursor exists.       // The GetIndexEntry method is optional but very useful.       {       	items: nil,              	index: 0,              	Entry: func()       	begin       		if index < Length(items) then       		items[index];       	end,              	Next: func()       		if index < Length(items)-1 then       		begin       			index := index + 1;       			items[index];       		end,       		       	Move: func(delta)       	begin       		index := Min(Max(index + delta, 0), kNumItems-1) ;       		items[index];       	end,       	       	Reset: func()       		index := 0,              	Clone: func()       		Clone(self),       		       	GetIndexEntry: func(theIndex)       		items[theIndex],       },     SelectItem:       // Required       // Toggle the selected state of an item       func(hitIndex)       	selectedStateArray[hitIndex + topIndex] :=       		NOT selectedStateArray[hitIndex + topIndex],     IsSelected:       // required       // Returns true if the particular "entry" is selected              // Simple check. However, this is a really inefficient way of doing things       func(entry)       	if selectedStateArray then       		selectedStateArray[entry.index],     viewSetupFormScript:       func()       begin       	// only need to setup cursor if not already there       	if IsReadOnly(cursor) then	       	begin       		cursor := {_proto: cursor};       		local array := cursor.items := Array(kNumItems, nil) ;              		for i := 0 to kNumItems - 1 do       			array[i] := {data: GetRandomWord(5,15), index: nil} ;              		array := cursor.items := Sort(array, '|str<|, 'data);       		       		for i := 0 to kNumItems - 1 do       			array[i].index := i ;       		       		selectedStateArray := Array(kNumItems, nil);       	end;       end,     selectedStateArray:       // An inefficient way to track the selected items       nil,     myHilitedIndex:       // Need to separately track the hilited item since        // protoOverview will sometimes clear the hilitedIndex slot              // This will track the real index of the hilited index. It is updated by scrolling.       nil,     topIndex:       // index of the item that is currently at the top of the displayed items       0,     debug: "theOverview",     _proto: @191    };AddStepForm(_view000, theOverview);constant |layout_protoOverview.t| := _view000;// End of file protoOverview.t
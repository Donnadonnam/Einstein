<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Strategy for Saving Modified Data</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Strategy for Saving Modified Data</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Strategy for Saving Modified Data  (4/8/97)</H3><DL><DD>Q:    What's the best way to save modified data to a soup?  For example, if I try to save the contents of a <CODE>clEditView</CODE> every time some change is made, typing is very slow.  So, when should it be saved?<BR><BR>A:    The best way we've found is to start a timer every time a change is made, and save the data when the timer expires.  If a change is made before the timer expires, you can reset the timer.  This way, the longer operation of saving to a soup won't happen until after the user pauses for a few seconds, but data will still be protected from resets.  The data should also be saved when the views that edit it are closed, or when switching data items.<BR><BR>    The timer can be implemented several ways.  If no view is available, <CODE>AddDelayedCall</CODE> or <CODE>AddDelayedSend</CODE> can be used.  The OS also provides <CODE>AddProcrastinatedSend</CODE> and <CODE>AddProcrastinatedCall</CODE>, which more or less implement the timer-resetting feature for you.<BR><BR>    The best way to implement the timer when views are available is using the <CODE>viewIdleScript</CODE>.  The <CODE>viewIdleScript</CODE> is preferred over <CODE>AddProcrastinatedCall/Send</CODE> because of better management of the event queue by the OS.  When you call <CODE>SetupIdle</CODE> to start an idle timer, any existing idle timer is reset.  Procrastinated calls/sends aren't currently implemented by resetting an existing timer, but rather by creating a delayed event which fires for each call and then checking a flag when the timer expires to see if it's the last one.<BR><BR>    Where these methods are implemented depends on what layer of your code manages the soup entry.  With the NewtApp model, the Entry layer manages the data, and each view in the Data layer is responsible for stuffing the modified data in the <CODE>target</CODE> frame, which is usually a soup entry.  The entry layer implements <CODE>StartFlush</CODE> to start the timer, and <CODE>EndFlush</CODE> is called when the timer expires and which should ensure that the data is saved to the soup.<BR><BR>    Your <CODE>StartFlush</CODE> equivalent could be implemented something like this:<BR><CODE><PRE>    StartFlush: func()        begin            self.entryDirty := TRUE;            :SetupIdle(5000);    // 5 second delay        end;</PRE><BR></CODE><BR>    Your <CODE>viewIdleScript</CODE> would look something like this:<BR><CODE><PRE>    viewIdleScript: func()        begin            :EndFlush();             nil;            // return NIL to stop the idler until next StartFlush        end;</PRE><BR></CODE><BR>    And your <CODE>EndFlush</CODE> equivalent would look something like this:<BR><CODE><PRE>    EndFlush: func()        if self.entryDirty then            begin                // getting data from editView may not                // be necessary at this point</PRE><BR>                    myEntry.editViewData := <I>&lt;editView/self&gt;</I>.viewChildren;<PRE>                EntryChangeXmit(myEntry, kAppSymbol);                self.entryDirty := nil;            end;</PRE><BR></CODE><BR>    Implementing <CODE>EndFlush</CODE> as a separate method rather than just putting the contents in the <CODE>viewIdleScript</CODE> makes it easy to call the method from the <CODE>viewQuitScript</CODE> or <CODE>viewPostQuitScript</CODE>, to guarantee that changes are saved when the view is closed.  (The <CODE>viewIdleScript</CODE> may not have been called if the user makes a change then immediately taps the close box or overview or whatever.)<BR></DL>
/***      Newton Developer Technical Support Sample Code****      MinMail, a Newton 2.0 transport example****      by J. Christopher Bell, Newton Developer Technical Support****      Copyright © 1994-7 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/// This sample uses WeRequireARecipient to determine if it is required to select at least// one person from the "to:" picker. For final code, you probably will want to require a recipient.constant WeRequireARecipient := nil;constant kNeedsRecipientStr := "You must choose a recipient.";// This is for our "temp soup" where items go after they are "sent" but before they are "received".constant kSoupName := "InTransit:MinMail:DTS";constant kVisibleSoupName := "MinMail Items";constant kSoupDescription := "Temporary items 'in transit' in the MinMail transport.";// Because we use a "temp soup" to hold items after they are "sent"// but before they are "received", we need a soup def to describe our soup.DefConst('kMySoupDef, 	{	name: kSoupName,	userName: kVisibleSoupName,	ownerApp: kAppSymbol,	ownerAppName: kAppName,	userDescr: kSoupDescription,	indexes: [], // we don't care about index order; we'll just use the default index to get items	});// Create our viewDef symbol. For example, TextViewDef:MinMail:DTSDefConst('kSimpleTextViewDefSym, intern("TextViewDef:"&kAppSymbol)); constant kTextVersionNumber := 1;constant kMaxTextHeight := 20000;
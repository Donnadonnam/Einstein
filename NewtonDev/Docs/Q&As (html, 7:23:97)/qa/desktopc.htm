<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Desktop Connectivity (DILs)</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Desktop Connectivity (DILs)</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="desktopc.htm">Desktop Connectivity (DILs)</H2></A><UL><A HREF="#Differences_between_MNP,_Modem,_Modem-MNP,_and_Real_Modems"><B> </B>Differences between MNP, Modem, Modem-MNP, and Real Modems  (2/5/96)<BR></A><A HREF="#CDPipeInit_Returning_-28102_on_MacOS_Computers"><B> </B>CDPipeInit Returning -28102 on MacOS Computers  (2/13/96)<BR></A><A HREF="#Getting_Serial_Port_Names_on_MacOS_Computers"><B> </B>Getting Serial Port Names on MacOS Computers  (2/13/96)<BR></A><A HREF="#Corruption_of_Some_Binary_Objects"><B> </B>Corruption of Some Binary Objects  (5/13/96)<BR></A><A HREF="#Error_-28801_or_-28706_from_FDget"><B> </B>Error -28801 or -28706 from FDget  (5/13/96)<BR></A><A HREF="#Using_CDPipeListen_Asynchronously_in_Windows_Applications"><B> </B>Using CDPipeListen Asynchronously in Windows Applications  (7/15/96)<BR></A><A HREF="#Unicode_Strings_and_Memory_Buffers"><B> </B>Unicode Strings and Memory Buffers  (8/26/96)<BR></A></UL><A NAME="Differences_between_MNP,_Modem,_Modem-MNP,_and_Real_Modems"><H3><HR><B> </B>Differences between MNP, Modem, Modem-MNP, and Real Modems  (2/5/96)</A></H3><DL><DD>Q:    I want to just connect to a Newton device over a cable from a MacOS or Windows machine - what do I need to use to get reliable communications?<BR>Q:    I want to have the DILs answer an incoming call over a modem.  How can I do that?<BR>Q:    What's the difference between the "Serial" and "Modem" Mac connection types?<BR><BR>A:    In release 1.0 of the DILs, the best way to connect to a Newton device is by using a MNP connection over a serial cable.  This is what you're using when you set connection type "Modem" on MacOS computers and "MNP" on Windows computers.  This actually has nearly nothing to do with modems as such; it means you're connecting over a serial cable using MNP error correction and compression.  (And on Windows, it's the only supported option at this time.)<BR><BR>    Currently you cannot use a true modem with the DILs to connect to a Newton device.<BR><BR>    In general, you will never use the "Serial" connection type on a MacOS computer; that connects over a serial cable (like "Modem" does) but offers no error detection. Therefore, you would have to write your own code to check that data arrived safely.</DL><A NAME="CDPipeInit_Returning_-28102_on_MacOS_Computers"><H3><HR><B> </B>CDPipeInit Returning -28102 on MacOS Computers  (2/13/96)</A></H3><DL><DD>Q:    When I call the DILs function <CODE>CDPipeInit</CODE>, it returns a -28102 error (Communication tool not found). I've checked that the tool is installed properly, and the DIL sample application works fine. What's wrong?<BR><BR>A:    A common cause of this error code is that the CSTR resources haven't been linked into your final executable.  Those resources are used to find the filenames of the communications tools.  Add the resource file named "<CODE>CSTR.rsrc</CODE>" to your project and see if that fixes things.</DL><A NAME="Getting_Serial_Port_Names_on_MacOS_Computers"><H3><HR><B> </B>Getting Serial Port Names on MacOS Computers  (2/13/96)</A></H3><DL><DD>Q:    Different MacOS computers have different numbers of ports, different names for the ports, and the port names are translated into other languages in non-English MacOS System Software. How can I tell what serial ports are available?<BR><BR>A:    You can use the Communications Toolbox to get the list of available serial ports.  This code has been added to version 2 of the SoupDrink sample code - see the <CODE>SetupPortMenu </CODE>function in SoupDrink.c for an example.</DL><A NAME="Corruption_of_Some_Binary_Objects"><H3><HR><B> </B>Corruption of Some Binary Objects  (5/13/96)</A></H3><DL><DD>Q:    Sometimes when I send a binary object (including a real) from the Newton device, it is corrupted when I read it with the FDILs on the desktop.  What's going on?<BR><BR>A:    When FDILs 1.0 receive a binary object, they must "guess" whether it is a string or not.  This guessing algorithm has a flaw which can result in non-string binary objects being treated as strings, and thus the Unicode conversion process is performed on them, which results in corruption of the desktop binary object.<BR><BR>    The easiest ways to avoid this problem are to either receive the data with the CDIL (in other words, don't include them in the frame), or else to ensure that either the first two or the last two bytes of the binary object are non-zero.  This workaround will not be necessary in future versions of the DIL libraries.<BR><BR>    Note: this has been fixed in the 1.0.2 Windows DILs.</DL><A NAME="Error_-28801_or_-28706_from_FDget"><H3><HR><B> </B>Error -28801 or -28706 from FDget  (5/13/96)</A></H3><DL><DD>Q:    Why does the <CODE>FDget </CODE>function return error -28801 (Out of heap memory) or -28706 (Invalid parameter)?  I don't think I'm out of memory, and I don't always get this error code so my parameters must be right. What is wrong?<BR><BR>A:    Sometimes these error codes are accurate and indicate that not enough memory could be allocated or that a parameter was invalid.  Sometimes they are the result of a bug caused by having multiple copies of a rectangle slot inside a frame.<BR><BR>    The protocol which is used to send frames can perform an optimization for certain rectangle frames, which transmits them in a compact form (5 bytes instead of up to 60).  However, if a given frame holds the exact same rectangle frame in more than one slot, the data will not be handled correctly and will either result in one of these error codes, or alternatively it might substitute some other object in place of the frame, or might possibly crash.<BR><BR>    This is a relatively uncommon problem, since all of the values in the frame must be between 0 and 255, and the frame must have the same rectangle in it twice - two frames with equivalent data would not trigger the problem.  For example, frame "A" would cause the problem, but frames "B", "C" and "D" would not.<BR><BR><CODE><PRE>A:={first: {left:3, right: 30, top:10, bottom:90}};A.second := A.first;           // triggers the problemB:={first: {left:3, right: 30, top:10, bottom:90}};B.second := clone(B.first);    // cloning avoids the problemC:={first: {left:3, right: 30, top:10, bottom:90, foo: nil}};C.second := C.first;           // no problem since C.foo existsD:={first: {left:3, right: 30, top:10, bottom:1000}};D.second := D.first;       // no problem since D.bottom is &gt;255</PRE><BR></CODE><BR>    To work around this problem, you can clone the frame (as in frame "B") or add another slot to the frame (as in frame "C") or ensure that the values are not between 0 and 255 (frame "D").<BR><BR>    Note: this has been fixed in the 1.0.2 Windows DILs.</DL><A NAME="Using_CDPipeListen_Asynchronously_in_Windows_Applications"><H3><HR><B> </B>Using CDPipeListen Asynchronously in Windows Applications  (7/15/96)</A></H3><DL><DD>Q:    I am passing in a callback function to <CODE>CDPipeListen</CODE>, but it never seems to be called.  What is going wrong?<BR><BR>A:    Due to a bug in <CODE>CDPipeListen</CODE>, the callback function never gets called in Windows applications.  You will have to use a synchronous listen, then wait for the state of the DIL pipe to change before accepting the connection.  The following code shows how to properly accept a connection.<BR><CODE><PRE>anErr = CDPipeListen( gOurPipe, kDefaultTimeout, NULL, 0 );if (!anErr) {    // This code doesn't need to be executed on MacOS, but     // is currently required for Windows.  We need to loop,    // waiting for the connection state to change to    // kCDIL_ConnectPending.    endTime = (GetTickCount()/1000) + 30;  // to timeout in 30 seconds    while ((GetTickCount()/1000) &lt; endTime )     {        if (CDGetPipeState( gOurPipe ) == kCDIL_ConnectPending) {            anErr = CDPipeAccept( gOurPipe );            break;        } else            CDIdle( gOurPipe );    }}</PRE><BR></CODE><BR>    Note: this has been fixed in the Windows DILs 1.0.2.</DL><A NAME="Unicode_Strings_and_Memory_Buffers"><H3><HR><B> </B>Unicode Strings and Memory Buffers  (8/26/96)</A></H3><DL><DD>Q:    Sometimes when I use the DILs to get a string, some memory gets corrupted even though I'm sure I've allocated more memory than I have characters in the string.  What's going on?<BR><BR>A:    One common cause is that strings arriving from a Newton device are in Unicode - which takes two bytes per character.  If you've only allocated one byte per character, you risk memory corruption because the data is converted to the one-byte form only after the whole buffer has arrived. This might be too late to prevent overrunning the buffer bounds.  So, you need to allocate enough space for the Unicode version.<BR><BR>    For example, if you're expecting strings to be up to 50 characters long, you must allocate at least 100 bytes of memory in your buffer.</DL>
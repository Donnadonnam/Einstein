<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Utility Functions</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Utility Functions</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="utilityf.htm">Utility Functions</H2></A><UL><A HREF="#What_Happened_to_FormattedNumberStr"><B> </B>What Happened to FormattedNumberStr  (2/12/96)<BR></A><A HREF="#Backlight_API"><B> </B>Backlight API  (4/19/96)<BR></A><A HREF="#Unusual_Sort_Order/Case_Sensitivity_in_Swedish_Locale_"><B> </B>Unusual Sort Order/Case Sensitivity in Swedish Locale   (1/16/97)<BR></A><A HREF="#Time_Zones,_GMT,_Daylight_Savings,_and_Newton_Time"><B> </B>Time Zones, GMT, Daylight Savings, and Newton Time  (3/4/97)<BR></A><A HREF="#Square_Root_of_Negative_Number_Bug"><B> </B>Square Root of Negative Number Bug  (3/4/97)<BR></A><A HREF="#Making_Use_of_the_Serial_Number_Chip"><B> </B>Making Use of the Serial Number Chip  (4/3/97)<BR></A><A HREF="#Programmatically_Cancelling_a_Confirm_Slip"><B> </B>Programmatically Cancelling a Confirm Slip  (4/3/97)<BR></A></UL><A NAME="What_Happened_to_FormattedNumberStr"><H3><HR><B> </B>What Happened to FormattedNumberStr  (2/12/96)</A></H3><DL><DD>Q:    The Newton 1.x documentation and OS included a <CODE>sprintf</CODE>-like function for formatting numbers called <CODE>FormattedNumberStr</CODE>.  The Newton Programmer's Guide 2.0 First Edition (beta) says this function is no longer supported.  How do I format my numbers?<BR><BR>A:    You may continue to use <CODE>FormattedNumberStr</CODE>.  Here is the <CODE>FormattedNumberStr</CODE>API that is supported.  <CODE>FormattedNumberStr</CODE> should be considered to have undefined results if passed arguments other than those specified here.<BR><BR><CODE><PRE>FormattedNumberStr(number, formatString)</PRE><BR></CODE>    Returns a formatted string representation of a real number. <BR><BR><CODE>    number</CODE>        A real number.<BR><CODE>    formatString</CODE>    A string specifying how the number should be formatted.<BR><BR>    This function works similar to the C function <CODE>sprintf</CODE>. The <CODE>formatString</CODE> specifies how the real number should be formatted; that is, whether to use decimal or exponential notation and how many places to include after the decimal point. It accepts the following format specifiers:<BR><CODE>    %f</CODE>    Use decimal notation (such as "123,456.789000").<BR><CODE>    %e</CODE>    Use exponential notation (such as "1.234568e+05").<BR><CODE>    %E</CODE>    Use exponential notation (such as "1.234568E+05").<BR><BR>    You can also specify a period followed by a number after the % symbol to indicate how many places to show following the decimal point.  (<CODE>"%.3f"</CODE> yields <CODE>"123,456.789"</CODE> for example.)<BR><BR>    Note:<CODE> FormattedNumberStr</CODE> uses the current values of <CODE>GetLocale().numberFormat</CODE> to get the separator and decimal characters and settings.  The example strings above are for the US English locale.<BR><BR><B>    Known Problems<BR></B><I>    Other specifiers<BR></I>    Do <I>not</I> use other <CODE>formatStrings</CODE>.  Previous releases of the documentation listed <CODE>%g</CODE> and <CODE>%G</CODE> as supported specifiers.  The behavior of these specifiers has changed with the Newton 2.0 OS.  Given the similarities to the<CODE> sprintf</CODE> function, it may occur to you to try other sprintf formatting characters.   Specifiers other than above have an undefined result and should be considered undocumented and unsupported.<BR><BR><I>    Large numbers<BR></I><CODE>    FormattedNumberStr</CODE> does not work properly for numbers larger than <CODE>1.0e24</CODE>.  If the number is very large the function can cause the Newton device to hang.<BR><BR><I>    Small numbers or long numbers<BR></I>    If more than 15 characters of output would be generated, for example because you are using <CODE>%f</CODE> with large number or a large number of digits following the decimal, <CODE>FormattedNumberStr</CODE> has undefined results, and can cause the Newton device to hang.<BR><I><BR>    Rounding<BR></I><CODE>    FormattedNumberStr</CODE> does not guarantee which direction it will round.  In the Newton 2.0 OS, it rounds half cases down rather than up or to an even digit.  If you need a precisely rounded number you should use the math functions <CODE>Ceiling</CODE>, <CODE>Floor</CODE>, <CODE>NearbyInt</CODE>, or <CODE>Round</CODE> with suitable math.<BR><BR><I>    Trailing decimals<BR></I>    In early releases of the Newton 1.0 OS, there was a bug in <CODE>FormattedNumberStr</CODE> that caused a trailing decimal character to be added when zero decimal positions was specified.  That is, <CODE>FormattedNumberStr(3.0, "%.0f")</CODE> resulted in  <CODE>"3."</CODE> not <CODE>"3"</CODE>.  To properly test for and remove this unwanted extra character you must be sure to use the character specified in the Locale settings and not assume the decimal character will be a period.</DL><A NAME="Backlight_API"><H3><HR><B> </B>Backlight API  (4/19/96)</A></H3><DL><DD>Q:    What is the API to check for and use the backlight?<BR><BR>A:    There are three relevant pieces of information:<BR><BR>    <B>Checking for the backlight<BR></B><BR>    To check if the backlight is there, use the <CODE>Gestalt</CODE> function as follows:<BR><BR><CODE><PRE>// define this somewhere in your project// until the platform file defines it (not in 1.2d2)constant kGestalt_BackLight := '[0x02000007, [struct, boolean], 1];local isBacklight := Gestalt(kGestalt_BackLight);if isBacklight AND isBacklight[0] then   // has a backlightelse   // has not got one</PRE><BR></CODE>    <B>Status of the backlight<BR></B><BR>    To find the current state of the backlight, use the following function:<BR>    <CODE><PRE>    BackLightStatus()</PRE><BR></CODE>    return value = nil (backlight is off) or non-nil (backlight is on)<BR><BR>    <B>Changing backlight status <BR></B><BR>    To turn the backlight on or off, use:<BR><BR>    <CODE><PRE>    BackLight(state)</PRE><BR></CODE>    return value - unspecified<BR>    state - nil (turn backlight off) or non-nil (turn backlight on)<BR></DL><A NAME="Unusual_Sort_Order/Case_Sensitivity_in_Swedish_Locale_"><H3><HR><B> </B>Unusual Sort Order/Case Sensitivity in Swedish Locale   (1/16/97)</A></H3><DL><DD>Q:    When I set the unit to the Swedish locale and use the <CODE>StrPos</CODE> global function to search for a ':' character, it finds other characters such as '.' or ';'.  Isn't that a bug?  How can I reliably search for these characters in any locale?<BR><BR>A:    The global function <CODE>StrPos</CODE> and many of the other string functions are case insensitive - they treat upper and lowercase letters as being identical.  In other languages, characters such as accented letters may be considered as different cases of the base letter, so they are treated as identical as well.  In the Newton OS model, the concepts  'same case' and 'same position in the sorting order' are not distinguished, so all cases of a letter will sort to the same position.  Going backwards, all characters that sort identically are considered to be different cases of the same letter.  Well, in the Swedish sort order, many punctuation characters are defined to sort to the same place, and so the case insensitive functions in the Newton device treat the characters as identical.   Many special and punctuation characters are grouped this way, but perhaps the most surprising set is  ? Á : , . ; À and !, which all sort to the same position and so are treated as identical in Swedish by <CODE>StrPos</CODE> and other case insensitive functions.<BR><BR>    To search a string for a particular character using a case sensitive search, use the <CODE>CharPos</CODE> function instead of <CODE>StrPos</CODE>.</DL><A NAME="Time_Zones,_GMT,_Daylight_Savings,_and_Newton_Time"><H3><HR><B> </B>Time Zones, GMT, Daylight Savings, and Newton Time  (3/4/97)</A></H3><DL><DD>Q:    There don't seem to be any functions in the Newton OS for converting between standard time values, such as finding the time in a different time zone, or GMT time.  I know it's possible because the built in Time Zones application does it.  How can I do this in my own application?<BR><BR>A:    The Newton OS doesn't actually have the concept of time zones.  Instead, for each city if keeps track of the offset (in seconds) from GMT for that city.  You can find this in the <CODE>'gmt</CODE> slot of a city entry, which can be gotten with the <CODE>GetCityEntry</CODE> global function. See the "Built In Apps and System Data" chapter of the Newton Programmers Guide for details.  Note that the docs incorrectly say the <CODE>gmt</CODE> slot contains the offset in minutes, when it is actually specified in seconds.  The current location is available in the <CODE>'location</CODE> slot of the user configuration frame.  Use <CODE>GetUserConfig('location)</CODE> to access it.  The global function <CODE>LocalTime</CODE> can be used to convert a time to the local time in a distant city.<BR><BR>    A simple way to get the local time from a GMT time would be to create a city entry representing GMT (gmt offset 0, no daylight savings) and then use <CODE>LocalTime</CODE> to compute the delta between the current city and the GMT city, then add the delta to the given GMT time.  <CODE>LocalTime</CODE> can be used directly to go the other way--getting the GMT time from the local time.<BR><BR>    <CODE>LocalTime</CODE>(<I><CODE>time</I></CODE>, <I><CODE>where</I></CODE>)<BR>    <I><CODE>time</I></CODE> - a time in minutes in the local (Newton device) zone, for example as returned from the <CODE>Time</CODE> function<BR>    <I><CODE>where</I></CODE> - a city entry, as returned from <CODE>GetCityEntry</CODE><BR>    <I><CODE>result</I></CODE> - a time in minutes in the <I>where</I> city, adjusted as necessary for time zone and daylight savings.<BR><BR>    <CODE>LocalTime</CODE> tells you the local time for the distant city, given a time in the current city.  For example, to find out the time in Tokyo:<BR><BR><CODE><PRE>    Date(LocalTime(time(), GetCityEntry("Tokyo")[0]))    #C427171  {year: 1997, month: 2, Date: 22, dayOfWeek: 6,           hour: 8, minute: 1, second: 0, daysInMonth: 28}</PRE><BR></CODE><BR><BR>    Because the Newton OS doesn't have time zones, it can't keep track of daylight savings time by changing zones (for example, from Pacific Standard Time to Pacific Daylight Time).  Instead, it uses a bunch of rules that tell it when to set the time ahead or back, and by how much.  The global function <CODE>DSTOffset</CODE> can be used to find out how much these daylight savings time rules have adjusted a given time for a given city.<BR><BR><CODE>    DSTOffset(<I>time</I>, <I>where</I>)</CODE><BR><I><CODE>    time</I></CODE> - a time in minutes in the where city<BR><I><CODE>    where</I></CODE> - a city entry, as returned from <CODE>GetCityEntry</CODE><BR><I><CODE>    result</I></CODE> - an integer, number of minutes that daylight savings adjusted that time in that city.<BR><BR>    <CODE>DSTOffset</CODE> tells you what the daylight savings component is of a given time in a given location.  This component would need to be subtracted from the result of the global function <CODE>Time</CODE> to get a non-daylight-adjusted time for the current location.<BR><CODE><PRE>    // it's currently 2:52 PM on 3/4/97, no DST adjustment    DSTOffset(Time(), GetCityEntry("Cupertino")[0]);    #0        0    // but during the summer, DST causes the clocks to "spring forward" an hour.    DSTOffset(StringToDate("6/6/97 12:34"), GetCityEntry("Cupertino")[0]);    #F0       60</CODE></PRE></DL><A NAME="Square_Root_of_Negative_Number_Bug"><H3><HR><B> </B>Square Root of Negative Number Bug  (3/4/97)</A></H3><DL><DD>Q:    When I call <CODE>Sqrt</CODE> with a negative number on the Newton, or use <CODE>Compile</CODE> in the NTK Inspector, I get a strange result.  However, if I just type <CODE>sqrt(-2)</CODE> into the listener I get a different strange result.  What's going on?<BR><BR><CODE><PRE>    call compile("sqrt(-2)") with ()    #4412F2D  -1.79769e+308    sqrt(-2)    #440DE05  1.00000e+999</PRE><BR></CODE><BR>A:    There is a floating point library bug in <CODE>Sqrt</CODE> on the Newton OS.  When passed a negative number, the large positive value is returned instead of a not-a-number value.  You can work around it using <CODE>Pow(x, 0.5)</CODE> instead of <CODE>Sqrt(x)</CODE> if there is no way to guarantee that the value passed to <CODE>Sqrt</CODE> is non-negative, or simply check and see if the argument is less than 0 and return a not-a-number constant.<BR><BR>    The reason <CODE>sqrt(-2)</CODE> works differently when you type it into the NTK Inspector is because of a compiler process known as constant folding.  <CODE>Sqrt</CODE> can be evaluated at compile time if you pass it a constant argument.  So what's really happening is that NTK is evaluating the <CODE>Sqrt</CODE> function during the compile phase and passing the resulting floating point number (or rather, not-a-number) to the Newton device where it's promptly returned.  An NTK real number formatting limitation displays non-a-number values and infinities as <CODE>1.00000e+999</CODE> rather than as some other string.  You can use <CODE>IsNAN</CODE> to determine if a real number is a not-a-number value.<BR><BR>    You can avoid constant folding and force evaluation on the Newton device by using a variable. For instance:<BR><CODE><PRE>    x := -2;    y := sqrt(x);    #C4335B1  -1.79769e+308</PRE><BR></CODE><BR>    Also, note that <CODE>FormattedNumberStr</CODE> does not properly handle not-a-number values.  (it returns "Number too small.") <BR></DL><A NAME="Making_Use_of_the_Serial_Number_Chip"><H3><HR><B> </B>Making Use of the Serial Number Chip  (4/3/97)</A></H3><DL><DD>Q:    I would like to get the serial number from the units that support it, as either an integer or real number.  How can I do this?<BR><BR>A:    You probably don't really want to do this.  The serial number is an 8-byte binary object, so you could use <CODE>ExtractByte</CODE> or <CODE>ExtractWord</CODE> or possibly <CODE>ExtractLong</CODE> to get the bytes out in integer form, then do something with them.  However, keep in mind that NewtonScript integers are only 30 bits wide, whereas the serial number is 64 bits wide, so you'll never be able to put all the information contained in the serial number into a single integer. (3 integers would be required.)<BR><BR>    That is, let us suppose you added up the value of all the bytes in a serial number.  You would get a single NewtonScript integer, but it would also be possible for a different serial number to produce the same integer.  (Just swap the positions of two of the bytes.)  Same goes for XOR or any checksumming scheme.  There's just no way to reduce 64 bits of information to 30 bits without allowing loss of uniqueness.  (If you come up with a way, let us know, it'd make a great compression algorithm!)<BR><BR>    Real numbers aren't suitable either, for much the same reason.  It's true that in NewtonScript reals are 8 bytes wide, but they use the IEEE 64-bit real number specification, and so not all combinations of 8 bytes are considered unique.  That is, you might think about taking the serial number result and using <CODE>SetClass</CODE> to change it's class to <CODE>'real</CODE>, which would effectively "cast" the 8-byte object to a real number.  This is a bad idea, because real numbers are interpreted using  bitfields with special meanings, and it's possible for two real numbers to have different binary representations and still evaluate as equal using the '=' operator.  (Any two not-a-number values will do this.)<BR><BR>    Serial numbers are best treated as strings or as 8-byte binary objects, so that no data is lost.  <CODE>StrHexDump</CODE> is the best way to format the serial number object for humans to read.  If you want to break it up to make it more easily readable, you could do something like this:<BR><CODE><PRE>    local s := StrHexDump(call ROM_GetSerialNumber with (), 2);    StrReplace(s, " ", "-", 3);</PRE><BR>    </CODE>Which produces this string (on my unit):<BR><CODE><PRE>    "0000-0000-0154-8423 "</PRE><BR>    </CODE>Please note that the serial number provided by the chip does NOT match the serial number that Apple Computer and other Newton device manufacturers may put on the outside of the case.  When supporting a device, Apple and its licensees will most likely request the user-visible serial number, typically found on a sticker on the case.  Please be sure that you present data from the internal chip-based serial number in such a way as to ensure the user will not be confused.  (This is the reason the chip-based serial number is not displayed by any software built into the device.)</DL><A NAME="Programmatically_Cancelling_a_Confirm_Slip"><H3><HR><B> </B>Programmatically Cancelling a Confirm Slip  (4/3/97)</A></H3><DL><DD>Q:    During an operation, I bring up a slip to ask the user if they really want to abort the operation.  Before they answer, the operation may complete or be aborted anyway.  I would like to remove the slip if this happens, much like the "Remount" slip is removed when a gripped card is ejected, reinserted, and then re-ejected.<BR><BR>A:    There's no way to dismiss a <CODE>ModalConfirm</CODE> slip, because your code is paused waiting for the result.   You can, however, remove an <CODE>AsyncConfirm</CODE> slip. The return value from <CODE>AsyncConfirm</CODE> (which is documented in the Newton Programmer's Guide as "unspecified") is actually a reference to the confirm view.  Sending that view a <CODE>Close</CODE> message dismisses the slip.  The callback function will not be called if this slip is removed in this way, so make sure your program handles that case.<BR></DL>
// Text of project NumberPicker written on 5/22/96 at 9:26 PM// Beginning of file AppWithMessage// Before Script for "AppWithMessageBaseView"/***      Newton Developer Technical Support Sample Code****      protoNumberPicker_TDS, a more versatile number picker proto****      by Jeremy Wyld, Newton Toolbox Engineering**		     Maurice Sharp, Newton Developer Technical Support****      Copyright © 1996 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/AppWithMessageBaseView :=    {title: "Application",     viewBounds: {left: 0, top: 18, right: 220, bottom: 318},     viewFormat: 84476241,     SetMessage:       func(pMessage)       	begin       		SetValue(messagePanelView, 'text, pMessage);       	end,     messageText: "Message contents go here",     messageLabel: "Message",     viewChangedScript:       func(slot, view)       	begin       		// Change the appropriate text view based on which slot was changed       		if slot = 'messageText then       			SetValue(messagePanelView, 'text, messageText) ;       		else if slot = 'messageLabel then       			SetValue(messageLabelView, 'text, messageLabel) ;       	end,     debug: "AppWithMessageBaseView",     _proto: @157    };messagePanelView :=    {viewBounds: {left: 11, top: -53, right: -7, bottom: -24},     viewJustify: 176,     viewFont: simpleFont9,     viewFormat: 131376,     viewSetupFormScript:       func()       	begin       		self.text := messageText ;       	end,     debug: "messagePanelView",     _proto: @218    };AddStepForm(AppWithMessageBaseView, messagePanelView);StepDeclare(AppWithMessageBaseView, messagePanelView, 'messagePanelView);messageLabelView :=    {viewBounds: {left: 0, top: -18, right: 60, bottom: -3},     viewJustify: 8407040,     viewSetupFormScript:       func()       	begin       		self.text := messageLabel ;       	end,     debug: "messageLabelView",     _proto: @218    };AddStepForm(AppWithMessageBaseView, messageLabelView);StepDeclare(AppWithMessageBaseView, messageLabelView, 'messageLabelView);Clear :=    {     buttonClickScript:       func()       	begin       		SetValue(self, 'messageText, "") ;       	end,     text: "Clear",     viewBounds: {left: 165, top: 229, right: 210, bottom: 241},     debug: "Clear",     _proto: @226    };AddStepForm(AppWithMessageBaseView, Clear);constant |layout_AppWithMessage| := AppWithMessageBaseView;// End of file AppWithMessage// Beginning of file protoNumberPicker_TDS// Before Script for "_userproto000"/***      Newton Developer Technical Support Sample Code****      protoNumberPicker_TDS, a more versatile number picker proto****      by Jeremy Wyld, Newton Toolbox Engineering**		     Maurice Sharp, Newton Developer Technical Support****      Copyright © 1996 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/DefConst('kPlusMinusWidth, 16);		// \__	These are the values returned by actually measuring theDefConst('kFlapHeight, 28);			// /	flaps' bits.  Developers will need to know these in orderDefConst('kDigitWidth, 23);			//		to leave the proper amount of room for the view./*	Plus/Minus flap that is placed in front of the number if the	developer has set showSign to true or if the minValue is less	than zero.*/DefConst('kPlusMinus, {	_proto:			protoDigit,		viewBounds:		SetBounds(-kPlusMinusWidth, 0, 0, kFlapHeight),    digits:			ROM_plusMinusBitmap,	totalFrames:	2,	Advance: func(inc) inherited:Advance(-2 * value),				// Flip sign	GetIndex: func(value) if value >= 0 then 0 else 1});/*	Single digit view.  A set of these make up the picker and	represent the value.  This particular digit handles displaying	negative numbers and will show the leading zeros (e.g. 007).*/DefConst('kDigitChild, {	_proto:		protoDigit,		icon:		ROM_digitFlapLowOrd,		GetIndex:	func(val) (ABS(val) DIV increment) MOD 10,			// Use absolute value in order to handle negative #'s		Advance:	func(increment) begin			local newValue := value + increment;								// Find the new value.		if (newValue > maxValue) OR (newValue < minValue) then		// \__	Bail if we don't need to do anything.			return nil;																// /	This is the same as the proto.		if (value > 0 AND newValue < 0) OR									// \__	If the value is crossing zero, it needs			(value < 0 AND newValue > 0) then								// /	to be handled special (see below).				value	:= 0 - value - increment;									// Flip the value so only the one digit rolls.																						// e.g.  -086 -> +186 instead of +014																			inherited:Advance(increment);	end});/*	This proto inherits from kDigitChild so it supports all of its	functionality.  This proto will suppress the leading zeros	though (e.g.   7 opposed to 007).*/DefConst('kNoZerosDigitChild, {	_proto:			kDigitChild,									// proto from the above kDigitChild constant		viewDrawScript:	func() begin				local index	:= :GetIndex(value);							// Get the index of the frame we should show.				if index then begin											// If there is an index we will display it.					if NOT currentIndex then								// \__	Make sure the currentIndex is properly				currentIndex := index;								// /	set before trying to draw.							inherited:?viewDrawScript();							// Perform the inherited draw.					end;		else			currentIndex	:= nil;									// There was no index, so don't draw, and set the	end,																	// currentIndex to nil in order to catch later.		GetIndex:	func(val) begin			local result	:= (ABS(val) DIV increment);				// What would the normal index be?				if result > 0 then												// \__	If it is greater than 0, then it is okay to			result MOD 10;													// /	return it.					// The "else nil" is implied and needed.  This sets currentIndex to		// nil in certain places which signals us in the viewDrawScript.	end});_userproto000 :=    {viewJustify: 0,     showLeadingZeros:       // true to show leading zeroes       nil,     showSign:       // true to show the +/- sign in front of the number       nil,     value:       // current value displayed       50,     maxValue:       // maximum value to show, must be no greater than 100000000       100,     minValue:       // smallest value to show. must be no smaller than -100000000       0,     viewSetupChildrenScript:       func()       begin       	:Pin();																// Force the value to edges if out of bounds.       	       	local children := self.viewChildren := [];							// Clear the children and set up an array for them.       	       	local i	:= 0;														// This is the power of the digit we are adding.              	local power		:= RIntToL(Pow(10, i));								// Value of that power.       	local absolute	:= MAX(ABS(maxValue), ABS(minValue));				// Tells us the number of digits we need to create.       																		// maxValue = 0 and minValue = -25 will give 25.       																		// We now know we need 2 digits.       	       	while power <= absolute do begin									// Until our we have all the digits, we create children.       																				// power -> 1, 10 and absolute = 25 for above example.              		AddArraySlot(children, {										// Add this child to the array.       			_proto:       				if NOT showLeadingZeros AND i <> 0 then					// Does the developer want zeros?  First digit will always       																		// show zeros.  This way you get " 0" instead of "  ".       																       					kNoZerosDigitChild									// This is the child WITHOUT leading zeros.       					       				else       					kDigitChild,										// This is the child WITH leading zeros       					       			increment:	power											// Increment by a power of 10.  1, 10, 100, 1000,...       		});       		       		i := i + 1;														// Increment our power.       		       		power	:= RIntToL(Pow(10, i));									// Find value of that power.       		       	end;			// end while power...       	       	if minValue < 0 OR showSign then									// If the plus/minus sign is needed,       		AddArraySlot(children, kPlusMinus);								// add it.       	       end,     viewChangedScript:       func(slot, view)       begin       	if slot = 'value then begin       		:Pin();       		foreach kid in :ChildViewFrames() do       			kid:?Update();								// Yes, it will suck in any child with an Update method.       	end;       		       	else if slot = 'minValue OR       			slot = 'maxValue OR       			slot = 'showLeadingZeros OR       			slot = 'showSign then begin       		:Pin();       		:RedoChildren();								// Sorry, easiest way to do it.  AddView could always be used, but...       	end;       end,     Pin:       func()       begin       	value := MIN(maxValue, MAX(minValue, value));		// Pin the value within the min and max values.       														// Work it out if you need to.       end,     viewClass: 74    };// After Script for "_userproto000"thisView := _userproto000;// actually need to use a protoDigitBase for thisthisView._proto := protoDigitBase;thisView.viewBounds := SetBounds(0, 0, kDigitWidth, kFlapHeight) ;RemoveSlot(thisView, 'viewClass) ;constant |layout_protoNumberPicker_TDS| := _userproto000;// End of file protoNumberPicker_TDS// Beginning of file NumberPicker.t// Before Script for "BaseView"/***      Newton Developer Technical Support Sample Code****      protoNumberPicker_TDS, a more versatile number picker proto****      by Jeremy Wyld, Newton Toolbox Engineering**		     Maurice Sharp, Newton Developer Technical Support****      Copyright © 1996 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/BaseView :=    {     messageText:       "Will display the number generated when randomly changing the number picker value"       // This slot is used in the AppWithMessage proto       ,     debug: "BaseView",     _proto: AppWithMessageBaseView    };NumberPicker :=    {value: 0,     maxValue: 14330,     minValue: 0,     viewBounds: {left: 32, top: 30, right: 192, bottom: 58},     viewSetupFormScript:       func()        	begin       		// Set the maximum possible value for the picker to be a random number        		// between -20000 and 20000.       		local new_value := Random(-20000, 20000);       		self.maxValue	:= new_value;       	       		// Find another random number which is between -20000 and 20000.  This       		// number will become the minimum possible value for the picker.  This       		// loop will execute at least once because new_value and maxValue are       		// initially the same number.       		while new_value >= maxValue do       			new_value := Random(-20000, 20000);       		self.minValue	:= new_value;       	       		inherited:?viewSetupFormScript();       	end,     debug: "NumberPicker",     _proto: _userproto000    };AddStepForm(BaseView, NumberPicker);StepDeclare(BaseView, NumberPicker, 'NumberPicker);minMaxText :=    {text: "(max = 0, min = 0)",     viewBounds: {left: 5, top: 2, right: -5, bottom: 18},     viewSetupFormScript:       func()       	begin       		// Tell the user what the minimum and maximum values for the picker are       		self.text := ParamStr("(max = ^0, min = ^1)",        			[NumberStr(numberPicker.maxValue), NumberStr(numberPicker.minValue)]);       	end,     viewJustify: 8396850,     debug: "minMaxText",     _proto: @218    };AddStepForm(BaseView, minMaxText);StepDeclare(BaseView, minMaxText, 'minMaxText);changeValue :=    {     buttonClickScript:       func()       	begin       		// Choose a new value between -20000 and 20000.  This will become       		// our number if it is between the current minimum and maximum values       		local new_value := Random(-20000, 20000);       		       		// Let the user know what was set, and what the new value is.       		SetValue(self, 'messageText, "SetValue(NumberPicker, 'value, " & new_value & ")") ;       		SetValue(NumberPicker, 'value, new_value);       	end,     text: "randomly change protoNumberPicker viewValue",     viewBounds: {left: 18, top: 10, right: -18, bottom: 46},     viewJustify: 8246,     debug: "changeValue",     _proto: @226    };AddStepForm(BaseView, changeValue);changeMinMax :=    {     buttonClickScript:       func()       	begin       		// Set the maximum possible value for the picker to be a random number        		// between -20000 and 20000.       		local new_value := Random(-20000, 20000);       		SetValue(numberPicker, 'maxValue, new_value);       	       		// Find another random number which is between -20000 and 20000.  This       		// number will become the minimum possible value for the picker.  This       		// loop will execute at least once because new_value and maxValue are       		// initially the same number.       		while new_value >= numberPicker.maxValue do       			new_value := Random(-20000, 20000);       		SetValue(numberPicker, 'minValue, new_value);       		       		SetValue(minMaxText, 'text, ParamStr("(max = ^0, min = ^1)",        			[NumberStr(numberPicker.maxValue), NumberStr(numberPicker.minValue)]));       	end,     text: "randomly change protoNumberPicker min and max values",     viewBounds: {left: 18, top: 10, right: -18, bottom: 46},     viewJustify: 8246,     debug: "changeMinMax",     _proto: @226    };AddStepForm(BaseView, changeMinMax);showZeros :=    {text: "Show leading zeros",     viewBounds: {left: 0, top: 10, right: 0, bottom: 26},     viewJustify: 9732,     viewSetupFormScript:       func()       	begin       		self.viewValue	:= numberPicker.showLeadingZeros;       	       		inherited:?viewSetupFormScript();       	end,     valueChanged:       func()        	begin       		SetValue(numberPicker, 'showLeadingZeros, viewValue);       	end,     debug: "showZeros",     _proto: @164    };AddStepForm(BaseView, showZeros);showSign :=    {text: "Show sign (min must be > 0 to hide sign)",     viewBounds: {left: 0, top: 5, right: 0, bottom: 21},     viewJustify: 9732,     viewSetupFormScript:       func()        	begin       		self.viewValue	:= numberPicker.showSign;       	       		inherited:?viewSetupFormScript();       	end,     valueChanged:       func()       	begin       		SetValue(numberPicker, 'showSign, viewValue);       	end,     debug: "showSign",     _proto: @164    };AddStepForm(BaseView, showSign);constant |layout_NumberPicker.t| := BaseView;// End of file NumberPicker.t
/***      Newton Developer Technical Support Sample Code****      Suite P, code to demonstrate use of the 2.0 DILs and provide basic Windows & Mac UI****      by David Fedor, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple Computer, Inc.-provided sample code, but that you've made changes.*/#include "CSuitePApp.h"#include <string.h>// PowerPlant includes#include <LApplication.h>#include <LGrowZone.h>#include <LWindow.h>#include <LCaption.h>#include <LStdControl.h>#include <LDialogBox.h>#include <UModalDialogs.h>#include <UMemoryMgr.h>#include <UDrawingState.h>#include <URegistrar.h>#include <UReanimator.h>#include <PP_Messages.h>// the definitions for the "real" DIL code in SuiteP#include "SuitePX.h"CSuitePApp *gTheApp;  // used by the cross-platform routines to access the UI objects// identifiers for the window, buttons, captions and radio buttonsconst ResIDT	WIND_Dashboard	= 200;const PaneIDT	btn_1			= 201;	// other button IDs (must) follow sequentiallyconst PaneIDT	capt_Status		= 302;const PaneIDT	capt_Bytes		= 304;const PaneIDT	capt_Log		= 305;const PaneIDT	radio_via1		= 401;	// other radio button IDs (must) follow sequentially// messages that the pushbuttons send when clickedconst MessageT	msg_button1		= 1000;	// buttons 2 through (num_buttons-1) follow sequentially// how many buttons and radio buttons do we have available to use?const long 		num_buttons		= 8;const long		num_radios		= 4;// maximum number of characters that textedit can handleconst long		max_textlength	= 32000;// useful little inline to return the maximum of two values...inline int max(int a, int b)  { return a > b ? a : b; }// ===========================================================================//		¥ Main Program// ===========================================================================void main(void){									// Set Debugging options	SetDebugThrow_(debugAction_Alert);	SetDebugSignal_(debugAction_Alert);	InitializeHeap(3);				// Initialize Memory Manager									// Parameter is number of Master Pointer									//   blocks to allocate										// Initialize standard Toolbox managers	UQDGlobals::InitializeToolbox(&qd);		new LGrowZone(20000);			// Install a GrowZone function to catch									//    low memory situations.									//    Parameter is size of reserve memory									//    block to allocated. The first time									//    the GrowZone function is called,									//    there will be at least this much									//    memory left (so you'll have enough									//    memory to alert the user or finish									//    what you are doing).		CSuitePApp	theApp;			// Create instance of your Application	theApp.Run();					//   class and run it}// ===========================================================================//		¥ CSuitePApp Class// ===========================================================================// ---------------------------------------------------------------------------//		¥ CSuitePApp// ---------------------------------------------------------------------------//	ConstructorCSuitePApp::CSuitePApp(){	// Register classes for objects created from 'PPob' resources		RegisterClass_(LWindow);	RegisterClass_(LTabGroup);	RegisterClass_(LCaption);	RegisterClass_(LStdButton);	RegisterClass_(LDialogBox);	RegisterClass_(LTextEdit);	RegisterClass_(LScroller);	RegisterClass_(LView);	RegisterClass_(LStdRadioButton);	RegisterClass_(LRadioGroup);		// A Dashboard program has a single main Window that is		// displayed on start up. The "Visible on Creation" option		// for the Window (in its PPob resource) should be OFF,		// so that you can adjust the Window's contents before		// displaying it.			mDisplayWindow = LWindow::CreateWindow(WIND_Dashboard, this);	UReanimator::LinkListenerToControls(this, mDisplayWindow, WIND_Dashboard);		// start up the DIL stuff	gTheApp = this;	DoStartupWork();	StartIdling();  // so that SpendTime() gets called when the OS says there's idle time		// open the window and start things going!	mDisplayWindow->Show();}// ---------------------------------------------------------------------------//		¥ ~CSuitePApp// ---------------------------------------------------------------------------//	DestructorCSuitePApp::~CSuitePApp(){	DoShutdownWork();	// shut down the DILs}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCSuitePApp::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean	cmdHandled = true;		switch (inCommand) {			// +++ Add cases here for the commands you handle		//		Remember to add same cases to FindCommandStatus below		//		to enable/disable the menu items for the commands			default:			cmdHandled = LApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	Pass back status of a (menu) commandvoidCSuitePApp::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	outUsesMark = false;		switch (inCommand) {			// +++ Add cases here for the commands you handle.		//		//		Set outEnabled to TRUE for commands that can be executed at		//		this time.		//		//		If the associated menu items can have check marks, set		//		outUsesMark and outMark accordingly.		//		//		Set outName to change the name of the menu item			default:			LApplication::FindCommandStatus(inCommand, outEnabled, outUsesMark,								outMark, outName);			break;	}}// ---------------------------------------------------------------------------voidCSuitePApp::ListenToMessage(	MessageT	inMessage,	void*		/* ioParam */){		if ((inMessage >= msg_button1) && (inMessage < (msg_button1 + num_buttons)))		DoButtonHit(inMessage - msg_button1);}// ---------------------------------------------------------------------------void CSuitePApp::SpendTime(const EventRecord &inMacEvent){	// Let the DIL code do whatever it needs to...	DoIdleWork();}// ---------------------------------------------------------------------------// add the text from the given buffer to the output logvoid CSuitePApp::LogAction(LPSTR theMsg, long msglen, int addCR){	LTextEdit *ctrl = (LTextEdit*) mDisplayWindow->FindPaneByID(capt_Log);	if (!ctrl)		return;		// this shouldn't ever happen, but better not to crash!	ctrl->FocusDraw();			TEHandle hTE = ctrl->GetMacTEH();		long txtlen = (*hTE)->teLength;	// Remove the top of the buffer if we're getting to the maximum size	if (msglen > max_textlength) 		msglen = max_textlength;	if (txtlen + msglen > max_textlength) {		TESetSelect(0, max(msglen+100, 4000), hTE);		// drop the top part		TEDelete(hTE);	}		// Insert the new text and scroll automatically.	// This isn't as efficient as it could be, but it's not too horrible.	TESetSelect(32767, 32767, hTE);		// move the cursor to the end	TEInsert(theMsg, msglen, hTE);		// insert the new text	if (addCR)		TEInsert("\r", 1, hTE);				// and a newline	ctrl->AdjustImageToText();	ctrl->ScrollPinnedImageBy(0, 9999, 1);	// scroll down to the bottom}// ---------------------------------------------------------------------------// add a string to the log window, terminated with a newlinevoid Msg(LPSTR theMsg){	gTheApp->LogAction(theMsg, strlen(theMsg), 1);}// ---------------------------------------------------------------------------// add the text from a buffer to the log window, no newlinevoid Msg2(LPSTR theMsg, long amt){	if (amt < 0)	// the caller is being lazy and wants us to find the length of the string		amt = strlen(theMsg);		gTheApp->LogAction(theMsg, amt, 0);}// ---------------------------------------------------------------------------// shows status of the pipevoid SetStatusText(LPSTR theStatus){	LStr255 oldStat, newStat;	LCaption *theCaption = (LCaption*) gTheApp->mDisplayWindow->FindPaneByID(capt_Status);	// see if this is a new message; if not, don't update and thus cause flashing.	newStat = theStatus;	theCaption->GetDescriptor(oldStat);	if (newStat != oldStat) {		theCaption->SetDescriptor(newStat);		theCaption->Refresh();	}}// ---------------------------------------------------------------------------// show how many bytes are waiting to be readvoid SetBytesAvail(long bytes){	LCaption *theCaption = (LCaption*) gTheApp->mDisplayWindow->FindPaneByID(capt_Bytes);		if (bytes)		theCaption->SetValue(bytes);	else		theCaption->SetDescriptor("\p");	// make the text blank; don't show "0".	theCaption->Refresh();}// ---------------------------------------------------------------------------// general-purpose routine to configure pushbuttons or radio buttonsvoid ConfigBtn(short controlindex, LPSTR text, short enabled){	LStr255 txt;	LStdButton *btn = (LStdButton*) gTheApp->mDisplayWindow->FindPaneByID(controlindex);	if (btn)		if (text) {			txt = text;			btn->SetDescriptor(txt);			btn->Show();			if (enabled)				btn->Enable();			else				btn->Disable();		} else			btn->Hide();}// ---------------------------------------------------------------------------// configure the pushbuttonsvoid ConfigureButton(short index, LPSTR text, short enabled){	if (index < num_buttons)		ConfigBtn(btn_1 + index, text, enabled);}// ---------------------------------------------------------------------------// configure the radio buttonsvoid SetRadioBtnText(short index, LPSTR text){	if (index < num_radios)		ConfigBtn(radio_via1 + index, text, 1);}// ---------------------------------------------------------------------------// which radio button is selected?short GetSelectedRadioBtn(){	int i;		for (i=0; i<num_radios; i++)		if (gTheApp->mDisplayWindow->FindPaneByID(radio_via1 + i)->GetValue() == Button_On)			return i;	return 0;		// none seem to be turned on; default to the first one...}
// Text of project Checkbook written on 4/17/97 at 4:42 PM// Beginning of text file StdAppSize.f/***      Newton Developer Technical Support Sample Code** **      StdAppSize, a hack for normal applications on multiple screens****      by Bob Ebert, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/ // "Standard" function for opening an application's base view to properly show up// on different screen sizes and different orientations.  Call this function from// your base view's viewSetupFormScript before calling the inherited:?viewSetupFormScript// If you use this function, you do not need to provide a viewJustify or viewBounds slot// for your base view.  The function creates one.// WARNING:  There is a pathological case to watch out for.  If the minWidth or minHeigh// happen to exactly match the current screen width or height, and the max height or// width (the opposite one) is less than the current screen height or width, the message// "screen to short/narrow" will appear.  Because you view isn't full screen in one dimension,// the border is required.  Because the border takes away from the useable dimension in the// other direction, the resulting view is too small to open.  If you absolutely require a view// that has borders on only 2 of the 4 sides for some screen size, this can be done, but// it's beyond the scope of this function--write your own viewSetupFormScript!!// Set one of these to TRUE to quickly test your app at minimum or maximum size.// (For max size, you may have to rely on "DV" to check the sizes of subviews,// because they can be off-screen.)  There will be no borders when you are running// your app this way.constant kTestMinAppSize := nil;constant kTestMaxAppSize := nil;DefineGlobalConstant('kStdAppSizeFunc, func(baseView, appName, minWidth, minHeight, maxWidth, maxHeight)	begin		// start by being as big as possible, will shrink later		baseView.viewJustify := vjParentCenterH + vjParentCenterV;		if kTestMinAppSize then			baseView.viewBounds := SetBounds(0,0,minWidth, minHeight);		else if kTestMaxAppSize then			baseView.viewBounds := SetBounds(0,0,maxWidth, maxHeight);		else			baseView.viewBounds := SetBounds(0,0,							GetAppParams().appAreaWidth,							GetAppParams().appAreaHeight);				// shrink if needed for max width/height		local bordersize := BAND(baseView.viewformat, vfPenMask)>>vfPenShift							+BAND(baseView.viewformat, vfInsetMask)>>vfInsetShift;		local fullScreenWidth := baseView.viewBounds.right-2*borderSize;		local fullScreenHeight := baseView.viewBounds.bottom-2*borderSize;		if fullScreenWidth > maxWidth or fullScreenHeight > maxHeight then			begin				// not full screen, so inset remainder and room for border				baseView.viewBounds.right := Min(fullScreenWidth, maxWidth);				baseView.viewBounds.bottom := Min(fullScreenHeight, maxHeight);			end;		else			begin	         // really are full screen, so no border, no clickable (assumes dragger)				baseView.viewFormat := vfNone;				baseView.viewFlags := BAND(baseView.viewFlags, BNOT(vClickable));			end;			// check for screen to small		local message;		if baseView.viewBounds.right < minWidth then			message := "The display is to narrow for " & appName & " to open"		else if baseView.viewBounds.bottom < minHeight then			message := "The display is to short for " & appName & " to open";		if message then			begin				baseView.viewBounds := RelBounds(-999, -999, 0, 0);	// removed in viewQuitScript				GetRoot():Notify(kNotifyAlert, kAppName, message);				AddDelayedCall(func(v)					begin						RemoveSlot(v, 'viewbounds);						v:Close();					end,					[baseview], 1);			end;	end);// End of text file StdAppSize.f// Beginning of text file Constants.f/***      Newton Developer Technical Support Sample Code****      Checkbook, a complete NewtApp sample****      by Neil Rhodes, Calliope &**		  Newton Developer Technical Support****      Copyright © 1994-7 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/OpenResFile(HOME & "Icons.rsrc");DefConst('kReconciledIcon, GetPictAsBits("Reconcile", nil));DefConst('kSmallCheckIcon, GetPictAsBits("SmallCheck", nil));CloseResFile();DefConst( 'kPrefsTemplate, {autoDate: nil,							autoCheckNum: nil});// Modify these numbers to do testingconstant kMaxWidth := 320;constant kMaxHeight := 320;constant kMinWidth := 200;constant kMinHeight := 200;// Define data symbols (used for routing)constant kCheckClassSym 			:= '|Check:Checkbook:PIETraining|;constant kCheckFrameFormatSym 		:= '|FrameFormat:Checkbook:PIETraining|;constant kCheckPrintFormatSym 		:= '|ViewFormat:Checkbook:PIETraining|;// Define a 'routing format' to handle frames (beam, mail, etc)// By default, protoFrameFormat handles text also; override 'dataTypes to change that.// Register a separate protoPrintFormat (see the allViewDefs slot in the base view)// if you want to support print and fax.DefConst('kCheckFrameFormat, {	_proto: protoFrameFormat,	name: "Check frame Format",	symbol: kCheckFrameFormatSym,	TextScript: func(item, target)		begin			// ... export text if possible.			// if format.textScript isn't present but a dataDef is, the datadef's			// textscript will be used to export the text						local string := "Check" & target.number;			if target.date then				string := string && "\nDate" && datentime(target.date);			if target.payee then				string := string && "\nto" && target.payee;			if target.amount then				string := string && "\n$" & formattednumberstr(target.amount, "%.2f");			if target.reconciled then				string := string & "\nReconciled";			else				string := string & "\nUnreconciled";			if target.memo then				string := string && "\nMemo: " && target.memo;			string;		end,			SetupItem: func(item, targetInfo)		begin			// set up the routing item if necessary			inherited:?SetupItem(item, targetInfo);			local string := "Check" && targetInfo.target.number;			if targetInfo.target.payee then				string := string && "to" && targetInfo.target.payee;						item.title := string		end;			});// End of text file Constants.f// Beginning of file protoCheckAllButton// Before Script for protoCheckAllButton// Copyright ©1995-7 Apple Computer, Inc.  All rights reserved.// This file shows how to create a simple button which does a "check all"// for an overview.  It matches the 2.1 OS feature, checking all items// in the current folder.  Most of the work is actually in the CheckAll// method of the newtOverLayoutprotoCheckAllButton :=    {viewBounds: {left: 7, top: 0, right: 33, bottom: 13},     buttonClickScript:       func()       	if newtAppBase.currentLayout = 'overView then       		begin       			if layout.checkAllPrimed then       				layout:UnCheckAll()       			else       				layout:CheckAll();       			layout.checkAllPrimed := NOT layout.checkAllPrimed;       		end;,     icon: GetPictAsBits("checkAll", nil),     debug: "protoCheckAllButton",     _proto: @198 /* protoPictureButton */    };constant |layout_protoCheckAllButton| := protoCheckAllButton;// End of file protoCheckAllButton// Beginning of file New Button.t// Before Script for _v226_0// Copyright ©1995 Apple Computer, Inc.  All rights reserved._v226_0 :=    {     buttonClickScript:       func()       	base:NewCheck();,     text: "New",     viewBounds: {left: 7, top: 0, right: 50, bottom: 13},     _proto: @226 /* protoTextButton */    };constant |layout_New Button.t| := _v226_0;// End of file New Button.t// Beginning of file Default View.t// Before Script for _v402_0// Copyright ©1995 Apple Computer, Inc.  All rights reserved._v402_0 :=    {viewBounds: {left: 0, top: 20, right: 0, bottom: -20},     masterSoupSlot:       // refers to a slot in the allSoups frame       // see newtApplication.allsoups in CheckBase.t       'checkSoup,     name: "Check",     viewJustify: 240,     forceNewEntry: nil,     menuLeftButtons:       // these will replace the menuLeftButtons in the newtStatusBar in the       // base view, because the 'statusBarSet in the base view is set to the       // declared name of the status bar.       // Note that we do not replace the menuRightButtons.       [       	newtInfoButton,       	{	       		_proto: protoRecToggle,       		_recogPopup: ['recogText, 'recogInkText, 'pickseparator, 'recToggleSettings],       	},       	GetLayout("New Button.t"),       ],     _proto: @402 /* newtLayout */    };entryView :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewJustify: 240,     DoInit:       func(symbol, textView)       	begin       		local s := GetUserConfig(symbol);       		       		if not s then       			s := "";       		SetValue(self.(textView), 'text, Clone(s));       	end,     viewSetupDoneScript:       func()       begin       	:DoInit('name, 'theName);       	:DoInit('address, 'theAddress);       	:DoInit('cityZip, 'theCityZip);       	inherited:?viewSetupDoneScript();       end,     viewSetupChildrenScript:       func()       	// don't want anything to show up if the folder is empty       	if not target then       		stepChildren := nil;,     debug: "entryView",     _proto: @406 /* newtEntryView */    };AddStepForm(_v402_0, entryView);theName :=    {text: "",     viewBounds: {left: 0, top: 0, right: 110, bottom: 14},     debug: "theName",     _proto: @218 /* protoStaticText */    };AddStepForm(entryView, theName);StepDeclare(entryView, theName, 'theName);theAddress :=    {text: "",     viewBounds: {left: 0, top: 0, right: 0, bottom: 14},     viewJustify: 8398384,     debug: "theAddress",     _proto: @218 /* protoStaticText */    };AddStepForm(entryView, theAddress);StepDeclare(entryView, theAddress, 'theAddress);theCityZip :=    {text: "",     viewBounds: {left: 0, top: 0, right: 0, bottom: 14},     viewJustify: 8398336,     debug: "theCityZip",     _proto: @218 /* protoStaticText */    };AddStepForm(entryView, theCityZip);StepDeclare(entryView, theCityZip, 'theCityZip);number :=    {viewBounds: {left: -100, top: 27, right: -5, bottom: 53},     path: 'number,     viewJustify: 32,     flavor:       {       	_proto: newtIntegerFilter,       	recConfig: nil,	// prevent ink       },     debug: "number",     _proto: @423 /* newtLabelNumInputLine */    };AddStepForm(entryView, number);amount :=    {viewBounds: {left: 4, top: 0, right: 35, bottom: 26},     path: 'amount,     viewJustify: 134225920,     flavor:       {       	_proto: newtNumberFilter,       	format: kFnBasicCurrency,       	recConfig: nil,	// prevent ink       };,     debug: "amount",     _proto: @423 /* newtLabelNumInputLine */    };AddStepForm(entryView, amount);date :=    {viewBounds: {left: -65, top: 0, right: -5, bottom: 26},     path: 'date,     viewJustify: 67125280,     flavor:       {       	_proto: newtDateFilter,       	recConfig: nil,	// prevent ink       };,     debug: "date",     _proto: @424 /* newtLabelDateInputLine */    };AddStepForm(entryView, date);payee :=    {viewBounds: {left: 5, top: 0, right: -5, bottom: 30},     path: 'payee,     label: "Payee",     viewJustify: 8240,     debug: "payee",     _proto: @422 /* newtLabelInputLine */    };AddStepForm(entryView, payee);memo :=    {viewBounds: {left: 5, top: 0, right: -5, bottom: 30},     path: 'memo,     label: "Memo",     viewJustify: 8240,     debug: "memo",     _proto: @422 /* newtLabelInputLine */    };AddStepForm(entryView, memo);reconciled :=    {path: 'reconciled,     viewJustify: 8246,     viewBounds: {left: 5, top: 0, right: -5, bottom: 30},     TargetData:       func()       	if target and path then       		if target.(path) then       			"Reconciled"       		else       			"Unreconciled",     debug: "reconciled",     _proto: @414 /* newtROTextView */    };AddStepForm(entryView, reconciled);constant |layout_Default View.t| := _v402_0;// End of file Default View.t// Beginning of file Overview.t// Before Script for overview// Copyright ©1995 Apple Computer, Inc.  All rights reserved.overview :=    {viewBounds: {left: 0, top: 20, right: 0, bottom: -20},     masterSoupSlot:       'checkSoup	// which soup to get info from.       ,     name: "Overview",     viewJustify: 240,     forceNewEntry:       nil	// don't create a new item if folder is empty       ,     viewSetupChildrenScript:       func()       	begin       		if not smallCheckShape then       			begin       				// create shapes from bitmaps for the icons in each item       				smallCheckShape := OffsetShape(MakeShape(kSmallCheckIcon), 0, 5);       				reconciledShape := OffsetShape(MakeShape(kReconciledIcon), 0, 3);       			end;       		inherited:?viewSetupChildrenScript();       	end,     lineHeight: 17,     smallCheckShape:       nil	// viewSetupChildrenScript will create the shape from a bitmap (see Constants.f)       ,     reconciledShape:       nil	// viewSetupChildrenScript will create the shape from a bitmap (see Constants.f)       ,     menuLeftButtons:       // these will replace the menuLeftButtons in the newtStatusBar in the       // base view, because the 'statusBarSet in the base view is set to the       // declared name of the status bar.       // Note that we do not replace the menuRightButtons.              [       	newtInfoButton,       	GetLayout("New Button.t"),       ],     OverviewAbstract:       func(item, bBox)       	begin       		// create a string with date, check #, amount, and "to"       		local s := ShortDateStr(item.date, 0);       		s := s && $# & NumberStr(item.number);       		if item.amount then       			s := s && FormattedNumberStr(item.amount, kFnBasicCurrency);       		s := s && "to" && item.payee;              		// build the shape.  Take advantage of an offset transform so we can       		// use the same reconciledShape or smallCheckShape for each item       		// (we need the style frame anyway to set the font for the text shape.)       		[       			{transform: [bbox.left, bbox.top],       			 font: '{family: espy, face: 1, size: 10}},       			if item.reconciled then reconciledShape else smallCheckShape,       			MakeText(s, 20, 0, bbox.right-bbox.left-20, 15),       		];       	end,     UnCheckAll:       func()       	begin             hilitedIndex := nil;             selected := nil;             layout:DoRetarget();       	end,     CheckAll:       func()          begin             local curse := dataCursor:Clone();             curse:Reset();             hilitedIndex := nil;             selected := MapCursor(curse, func(e) MakeEntryAlias(e));             AddUndoSend(layout, 'UnCheckAll, []);             layout:DoRetarget();          end;,     menuRightButtons:       [       	newtActionButton,       	newtFilingButton,       	GetLayout("protoCheckAllButton"),       ];,     debug: "overview",     _proto: @405 /* newtOverLayout */    };constant |layout_Overview.t| := overview;// End of file Overview.t// Beginning of file CheckPrintViewDef.tprint :=    {symbol: kCheckPrintFormatSym,     version: 1,     name: "Single Check",     printNextPageScript:       func()       begin       	return nil;		// always print one page       end,     title: "Single Check",     SetupItem:       func(item, targetInfo)       		begin       			// set up the routing item if necessary       			inherited:?SetupItem(item, targetInfo);              			local string := "Check" && targetInfo.target.number;       			if targetInfo.target.payee then       				string := string && "to" && targetInfo.target.payee;       			       			item.title := string       		end;,     debug: "print",     _proto: @200 /* protoPrintFormat */    };checkNumber :=    {viewBounds: {left: 0, top: 27, right: 0, bottom: 53},     viewJustify: 48,     text: "Static Text",     viewSetupFormScript:       func()       begin       	if target.number then       		text := "Check #" & FormattedNumberStr(target.number, "%0.0f");       	else       		text := "";       end,     debug: "checkNumber",     _proto: @218 /* protoStaticText */    };AddStepForm(print, checkNumber);StepDeclare(print, checkNumber, 'checkNumber);date :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 26},     viewJustify: 8240,     text: "Static Text",     viewSetupFormScript:       func()       begin       	if target.date then       		text := "Date:" && ShortDateStr(target.date, kFormatDefault);       	else       		text := "";       end,     debug: "date",     _proto: @218 /* protoStaticText */    };AddStepForm(print, date);StepDeclare(print, date, 'date);amount :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 26},     viewJustify: 8240,     text: "Static Text",     viewSetupFormScript:       func()       begin       	if target.amount then       		text := "Amount:" & FormattedNumberStr(target.amount, kFnBasicCurrency);       	else       		text := "";       end,     debug: "amount",     _proto: @218 /* protoStaticText */    };AddStepForm(print, amount);payee :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 26},     viewJustify: 8240,     text: "Static Text",     viewSetupFormScript:       func()       begin       	if target.payee then       		text := "Payee:" && target.payee;       	else       		text := "";       end,     debug: "payee",     _proto: @218 /* protoStaticText */    };AddStepForm(print, payee);memo :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 26},     viewJustify: 8240,     text: "Static Text",     viewSetupFormScript:       func()       begin       	if target.memo then       		text := "Memo:" & target.memo;       	else       		text := "";       end,     debug: "memo",     _proto: @218 /* protoStaticText */    };AddStepForm(print, memo);// After Script for printthisView := print;// Copyright ©1995 Apple Computer, Inc. All rights reservedconstant |layout_CheckPrintViewDef.t| := print;// End of file CheckPrintViewDef.t// Beginning of file PrefsView.t// Before Script for prefs// Copyright © 1996 by Apple Computer, Inc.  All rights reserved.prefs :=    {viewBounds: {left: 0, top: 0, right: 200, bottom: 88},     prefs:       // This slot will hold a reference to the application prefs frame       nil,     viewSetupFormScript:       func()       begin       	// get the preferences frame and make sure that our application specific       	// slot exists.  theApp is a reference to the applications base view       	prefs := theApp:GetAppPreferences();       	if NOT HasSlot( prefs, kAppSymbol ) then       		prefs.(kAppSymbol) := Clone( kPrefsTemplate );       end,     declareSelf: 'base,     viewJustify: 80,     viewQuitScript:       // must return the value of inherited:?viewQuitScript();       func()       begin       	// clean up our stuff.  We don't need to write prefs back to the soup because       	// newtApp does all that for us.       	theApp:SaveAppState();       	RemoveSlot(self, 'prefs);       	RemoveSlot(self, 'theApp);       	       	inherited:?viewQuitScript();		// this method is defined internally       end,     ReorientToScreen: ROM_DefRotateFunc ,     debug: "prefs",     _proto: @179 /* protoFloater */    };prefs_v229_0 :=    {title: "Checkbook Preferences",     viewBounds: {left: 0, top: 0, right: 90, bottom: 18},     _proto: @229 /* protoTitle */    };AddStepForm(prefs, prefs_v229_0);pref1 :=    {text: "Pref 1",     viewBounds: {left: 16, top: 22, right: 192, bottom: 36},     valueChanged:       func()       begin       	prefs.(kAppSymbol).pref1 := viewValue;       end,     viewSetupFormScript:       func()       begin       	viewValue := prefs.(kAppSymbol).pref1;       end,     debug: "pref1",     _proto: @164 /* protoCheckBox */    };AddStepForm(prefs, pref1);pref2 :=    {text: "Pref 2",     viewBounds: {left: 16, top: 39, right: 192, bottom: 52},     valueChanged:       func()       begin       	prefs.(kAppSymbol).pref2 := viewValue;       end,     viewSetupFormScript:       func()       begin       	viewValue := prefs.(kAppSymbol).pref2;       end,     debug: "pref2",     _proto: @164 /* protoCheckBox */    };AddStepForm(prefs, pref2);internalStore :=    {text: "Always store new checks internally",     viewBounds: {left: 16, top: 56, right: 192, bottom: 69},     valueChanged:       func()       begin       	prefs.internalStore := viewValue;       end,     viewSetupFormScript:       func()       begin       	viewValue := prefs.internalStore;       end,     debug: "internalStore",     _proto: @164 /* protoCheckBox */    };AddStepForm(prefs, internalStore);prefs_v163_0 := {_proto: @163 /* protoLargeClosebox */};AddStepForm(prefs, prefs_v163_0);constant |layout_PrefsView.t| := prefs;// End of file PrefsView.t// Beginning of file CheckBase.t// Before Script for checkbookApp// Copyright ©1995-7 Apple Computer, Inc.  All rights reserved.checkbookApp :=    {prefsView: GetLayout("PrefsView.t"),     allViewDefs:       /*        * the format of this slot is {datadefSym: {viewDef1Sym: theViewDef1, viewDef2Sym: theViewDef2 ...}        *        * This slot is evaluated at *compile time* and should reference the viewDefs that need to        * be installed when the package is installed (mainly for Routing -- mail, print, fax, etc).        * They need to be installed at part-install time so that printing (or other routing) can        * occur when the application is not open.        */              result := {};       result.(kCheckClassSym) := {};       result.(kCheckClassSym).(kCheckFrameFormatSym) := kCheckFrameFormat;				// for beam, mail, etc       result.(kCheckClassSym).(kCheckPrintFormatSym) := GetLayout("CheckPrintViewDef.t"); // for fax, print, etc...       result;,     viewQuitScript:       func()       begin       	inherited:?viewQuitScript();		// this method is defined internally       	RemoveSlot(self, 'viewBounds);       end,     appAll: "All Checks",     GetRouteScripts:       func(targetInfo)       	begin       		// merge our extraRouteScripts with the system ones       		       		local result := inherited:?GetRouteScripts(targetInfo);	// for future compatibility       		if not result then       			result := routeScripts;       		result := Clone(result); 	// get writeable copy       		ArrayMunger(result, 0, 0, extraRouteScripts, 0, nil);       		result;       	end,     ReorientToScreen: ROM_DefRotateFunc,     appObject: ["Check", "Checks"]     ,     dateFindSlot: 'date,     _proto: @398 /* newtApplication */,     allSoups:       {       	checkSoup: {       		_proto: newtSoup,       		soupName: "Checkbook:PIETraining",       		soupIndices: [       			{structure: 'slot, path: 'date, type: 'int},       			{structure: 'slot, path: 'number, type: 'int},       			{structure: 'multiSlot, path: ['date, 'number], type: ['int, 'int]},       		],       		soupQuery: {indexPath: ['date, 'number]},       		soupDescr: "The Checkbook soup",       		FillNewSoup: func()       			begin       				local store := if GetRoot().(kAppSymbol):GetAppPreferences().internalStore then       					GetStores()[0];       				else       					GetDefaultStore();       	       				:AddEntry(self:CreateBlankEntry(), store);       			end,       		CreateBlankEntry : func()       			begin       				local newNumber := 100;       				local e := theSoup:Query('{indexPath: number}):ResetToEnd();       				if e then       					newNumber := e.number + 1;       				{       					date: Time(),       					payee: nil,       					memo: nil,       					amount: 0.0,       					number: newNumber,       					reconciled: nil,       					class: kCheckClassSym,  // required for routing       				};       			end,       	},       },     ReconcileChecks:       func(target, targetView)       	begin       		local c := GetTargetCursor(target, nil);	// works even if target is a single entry       		local e := c:Entry();       		local newState := NOT e.reconciled;			// go by 1st entry       		while e do       			begin       				e.reconciled := newState;       				EntryChangeXmit(e, kAppSymbol);       				e := c:Next();       			end;       		targetView:RedoChildren();       	end,     appSymbol: kAppSymbol,     extraRouteScripts:       [       	{       		GetTitle: func(target)       			if target then       				if TargetIsCursor(target) then       					if GetTargetCursor(target, nil):Entry().reconciled then       						"Unreconcile"       					else       						"Reconcile"        				else       					if target.reconciled then       						"Unreconcile"       					else       						"Reconcile",       		icon: kReconciledIcon,       		routeScript: 'ReconcileChecks,       	},       ],     title: kAppName,     viewSetupFormScript:       func()       	begin       		call kStdAppSizeFunc with (self, kAppName, kMinWidth, kMinHeight, kMaxWidth, kMaxHeight);       		inherited:?viewSetupFormScript();		// this method is defined internally       	end,     statusBarSlot:       'status		// contains declared name of the status bar so layouts can use status bar.  Optional.       ,     FindSoupExcerpt:       func(item, finder)       begin       	local s := ShortDateStr(item.date, 0);       	s := s && $# & NumberStr(item.number);       	if item.amount then       		s := s && FormattedNumberStr(item.amount, kFnBasicCurrency);       	s := s && "to" && item.payee;       end,     allLayouts:       {       	default: GetLayout("Default View.t"),       	overview: GetLayout("Overview.t"),       },     PutAwayScript:       func(item)       	begin       		local target := item.body;              		// Routing requires you to verify that you can handle this type of       		// data before trying to put away!       		if classof(target) = kCheckClassSym and not TargetIsCursor(target) then       			inherited:PutAwayScript(item);              		// we cannot handle multiple-item targets or non-checks... so return NIL       		// (NIL is the result of an if stmt that has no else clause)       	end,     debug: "checkbookApp",     NewCheck:       func()       	begin       		local newEntry := allSoups.checkSoup:CreateBlankEntry();       		:AddEntry(newEntry);	// this is a newtApplication method that should/will be doc'd.       	end              /*       		// This should work as well, but it has an unusual scrolling       		// problem because ShowLayout currently happens at a deferred time.       		          		:ShowLayout('default);                 		local store := if :GetAppPreferences().internalStore then          				GetStores()[0];          			else          				GetDefaultStore();          		local newEntry := allSoups.checkSoup:CreateBlankEntry();          		          		// if we're in a folder, put the new check in the current folder          		if labelsFilter and labelsFilter <> '_all then          			newEntry.labels := labelsFilter;          		          		allSoups.checkSoup:AddEntry(newEntry, store);          		layout.dataCursor:Goto(newEntry);          		layout:NewTarget();       */    };status :=    {     menuRightButtons:       [       	newtActionButton,       	newtFilingButton,       ],     debug: "status",     _proto: @401 /* newtStatusBar */    };AddStepForm(checkbookApp, status);StepDeclare(checkbookApp, status, 'status);checkbookApp_v162_0 := {_proto: @162 /* newtClockFolderTab */};AddStepForm(checkbookApp, checkbookApp_v162_0);constant |layout_CheckBase.t| := checkbookApp;// End of file CheckBase.t// Beginning of text file Install&Remove Scripts/***      Newton Developer Technical Support Sample Code****      Checkbook, a complete NewtApp sample****      by Neil Rhodes, Calliope &**		  Newton Developer Technical Support****      Copyright © 1994-7 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/InstallScript := func(partFrame)begin	local mainLayout := partFrame.theForm;		// A work around until NewtInstallScript correctly handles Ensuring internal 	// the symbol, see Q&A: How to Avoid NewtApp "Please insert the card" (5/10/96)	// for more details	if mainLayout.allViewDefs then		foreach dataDefSym,viewDefsFrame in mainLayout.allViewDefs do			foreach viewDef in viewDefsFrame do			RegisterViewDef( viewDef, EnsureInternal (dataDefSym) );	partFrame.removeFrame := mainLayout:NewtInstallScript(mainLayout);end;RemoveScript := func(partFrame)begin	(partFrame.removeFrame):NewtRemoveScript(partFrame.removeFrame);end;// End of text file Install&Remove Scripts
<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: NewtApp</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: NewtApp</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="newtapp.htm">NewtApp</H2></A><UL><A HREF="#Creating_Preferences_in_a_NewtApp-based_Application"><B> </B>Creating Preferences in a NewtApp-based Application  (1/31/96)<BR></A><A HREF="#Creating_an_About_Slip_in_a_NewtApp-based_Application"><B> </B>Creating an About Slip in a NewtApp-based Application  (1/31/96)<BR></A><A HREF="#NewtSoup_FillNewSoup_Uses_Only_Internal_Store"><B> </B>NewtSoup FillNewSoup Uses Only Internal Store  (2/5/96)<BR></A><A HREF="#Setting_the_User_Visible_Name_With_NewtSoup"><B> </B>Setting the User Visible Name With NewtSoup  (2/6/96)<BR></A><A HREF="#How_to_Control_Sort_Order_in_NewtApp"><B> </B>How to Control Sort Order in NewtApp  (5/10/96)<BR></A><A HREF="#How_to_Avoid_NewtApp_"Please_Insert_the_Card"_Errors"><B> </B>How to Avoid NewtApp "Please Insert the Card" Errors  (5/10/96)<BR></A><A HREF="#Customizing_Filters_with_Labelled_Input_Lines"><B> </B>Customizing Filters with Labelled Input Lines  (9/4/96)<BR></A><A HREF="#Using_Custom_Help_Books_in_a_NewtApp-based_Application"><B> </B>Using Custom Help Books in a NewtApp-based Application  (12/2/96)<BR></A><A HREF="#Creating_a_Large_newtEditView/newtROEditView"><B> </B>Creating a Large newtEditView/newtROEditView  (12/2/96)<BR></A><A HREF="#How_to_Use_ForceNewEntry_with_NewtApp"><B> </B>How to Use ForceNewEntry with NewtApp  (12/2/96)<BR></A><A HREF="#How_to_Programmatically_Open_the_Header_Slip"><B> </B>How to Programmatically Open the Header Slip  (1/3/97)<BR></A><A HREF="#Programmatically_Changing_the_Default_ViewDef"><B> </B>Programmatically Changing the Default ViewDef  (1/3/97)<BR></A><A HREF="#How_to_Properly_Declare_NewtApp_Views"><B> </B>How to Properly Declare NewtApp Views  (1/6/97)<BR></A><A HREF="#How_to_Create_Custom_Overviews_with_NewtApp"><B> </B>How to Create Custom Overviews with NewtApp  (1/8/97)<BR></A><A HREF="#How_to_Store_Prefs_in_a_NewtApp-based_Application"><B> </B>How to Store Prefs in a NewtApp-based Application  (1/17/97)<BR></A><A HREF="#A_CheckAll_Button_for_NewtApp_Overviews"><B> </B>A CheckAll Button for NewtApp Overviews  (3/4/97)<BR></A><A HREF="#Creating_a_Simple_NewtApp"><B> </B>Creating a Simple NewtApp  (4/7/97)<BR></A><A HREF="#Registering_Soup_Change_Notifications_in_NewtApp"><B>NEW: </B>Registering Soup Change Notifications in NewtApp  (5/15/97)<BR></A></UL><A NAME="Creating_Preferences_in_a_NewtApp-based_Application"><H3><HR><B> </B>Creating Preferences in a NewtApp-based Application  (1/31/96)</A></H3><DL><DD>Q:    How do I create and use my own preferences slip in a NewtApp-based application?<BR><BR>A:    In your application's base view create a slot called <CODE>prefsView</CODE> and place a reference to the template for your preferences slip there (probably using the NTK <CODE>GetLayout</CODE> function.)  When the user selects "Prefs" from the Info button in your application, the NewtApp framework will create and open a view based on the template in the <CODE>prefsView</CODE> slot.<BR><BR>    When your preferences view opens, a reference to your application's base view is stored in a slot called <CODE>theApp </CODE>in the preferences view.  Use this reference to call the application's <CODE>GetAppPreferences</CODE> method.  This method will return a frame containing your application's preferences.  <CODE>GetAppPreferences</CODE> is a method provided by NewtApp and should not be overidden.<BR><BR>    When adding slots to the preferences frame, you must either append your developer signature to the name of the preference (for example, <CODE>'|Pref1:SIG|</CODE>) or create a slot in the preferences frame using your developer signature and save all preferences in that frame.  This will guarantee that you don't overwrite slots used by the NewtApp framework.<BR><BR>    Here is an example of how to get the preferences frame and add your data:<BR>        <CODE><PRE>        preferencesSlip.viewSetupFormScript := func()     begin        prefs := theApp:GetAppPreferences();        if NOT HasSlot(prefs, kAppSymbol) then            prefs.(kAppSymbol) := {myPref1: nil, myPref2: nil};    end;</PRE><BR>    </CODE>    <BR>    <BR>    To save the preferences, call the application's <CODE>SaveAppState</CODE> method:<BR><CODE><PRE>    preferencesSlip.viewQuitScript := func()        theApp:SaveAppState(); // save prefs</PRE><BR></CODE><BR>    NewtApp currently provides one built-in preference for where to save new items.  In the preferences frame there will be a slot called <CODE>internalStore</CODE>.  Setting this slot to <CODE>true </CODE>will force the NewtApp framework to save all new items on the internal store. </DL><A NAME="Creating_an_About_Slip_in_a_NewtApp-based_Application"><H3><HR><B> </B>Creating an About Slip in a NewtApp-based Application  (1/31/96)</A></H3><DL><DD>Q:    How do I create my own About slip in a NewtApp-based application?<BR><BR>A:    Depending on how much control you want, there are two ways to do this.  For the least amount of control, create a slot in your application's base view called <CODE>aboutInfo</CODE>.  Place a frame in that slot with the following slots:<BR><BR>    <CODE><PRE>    {tagLine:  "",        // A tagline for your application version: "",        // The version number for the application copyright: "",    // Copyright information trademarks: "",    // Trademark information}</PRE><BR></CODE><BR>    The information found in this frame will be displayed by the NewtApp framework when the user selects "About" from the Info button's popup.  See the picture below for an example of what the user will see.<BR><BR>    Alternatively, you can create your own About view.  If you do this, create a slot in your application's base view called <CODE>aboutView</CODE> containing a reference to a template for your about view (probably using the NTK <CODE>GetLayout</CODE> function.)   A view will be created from that template and opened when the user selects "About" from the Info button's popup.<BR><BR></DL><CENTER><IMG BORDER="0" SRC="pictures/abotslip.gif" ALT="Q&amp;A Diagram"></CENTER><A NAME="NewtSoup_FillNewSoup_Uses_Only_Internal_Store"><H3><HR><B> </B>NewtSoup FillNewSoup Uses Only Internal Store  (2/5/96)</A></H3><DL><DD>Q:    My <CODE>NewtSoup</CODE> continues to get the <CODE>FillNewSoup</CODE> message, even when the soup already exists. Am I doing something wrong?<BR><BR>A:    The NewtApp framework only checks for entries on the internal store to determine if the <CODE>FillNewSoup </CODE>message needs to be sent.  Check the "Setting the UserVisible Name With NewtSoup" Q&amp;A for more details and a description of how to work around the problem.</DL><A NAME="Setting_the_User_Visible_Name_With_NewtSoup"><H3><HR><B> </B>Setting the User Visible Name With NewtSoup  (2/6/96)</A></H3><DL><DD>Q:    How can I make the user visible name for my NewtApp's soup be something besides the internal soup name, as I can do with <CODE>RegUnionSoup</CODE>?<BR><BR>A:    There is a method of <CODE>newtSoup</CODE> called <CODE>MakeSoup</CODE> which you can override.  The <CODE>MakeSoup</CODE> method is responsible for calling <CODE>RegUnionSoup</CODE> (or otherwise making a soup) and then calling the <CODE>FillNewSoup</CODE> method if the soup is new/empty.<BR><BR><CODE>    MakeSoup</CODE> is called normally as part of initializing the <CODE>newtSoup</CODE> object.  Here is a sample <CODE>MakeSoup</CODE> method that will use a newly defined slot (from the <CODE>newtSoup</CODE> based template) for the user name.<BR><BR>    The current documentation doesn't tell you everything you need to do to properly override the <CODE>MakeSoup</CODE> method.  In particular, <CODE>MakeSoup</CODE> is used by the <CODE>newtSoup</CODE> implementation to initialize the object, so it needs to set up other internal slots.  It's vital that the <CODE>'appSymbol</CODE> slot in the message context be set to the passed argument, and that the <CODE>'theSoup</CODE> slot be set to the soup or unionSoup that <CODE>MakeSoup</CODE> creates or gets.  (Recall that <CODE>RegUnionSoup</CODE> returns the union soup, whether it previously existed or not.)<BR><BR>    The <CODE>GetSoupList</CODE> method of union soups used in this code snippet returns an array with the member soups.  It should be considered documented and supported.  A newly created union will have no members, so <CODE>FillNewSoup</CODE> should be called.  This is an improvement over the default <CODE>MakeSoup</CODE> method, which always calls <CODE>FillNewSoup</CODE> if the soup on the internal store is empty.<BR><BR>    The user visible name is supplied via the newtSoup <CODE>'userName</CODE> slot, which is looked up in the current context.  As with <CODE>soupName</CODE>, <CODE>soupDescr</CODE>, etc, you should set a new <CODE>userName</CODE> slot in the frame in the <CODE>allSoups</CODE> frame in the <CODE>newtApplication </CODE>template.<BR><BR><CODE><PRE>    MakeSoup: func(appSymbol)        begin            self.appSymbol := appSymbol;    // just do it...            self.theSoup := RegUnionSoup(appSymbol, {                name: soupName,                userName: userName,                ownerApp: appSymbol,                userDescr: soupDescr,                indexes: soupIndices,            });            if Length(theSoup:GetSoupList()) = 0 then                :FillNewSoup();        end;</CODE></PRE></DL><A NAME="How_to_Control_Sort_Order_in_NewtApp"><H3><HR><B> </B>How to Control Sort Order in NewtApp  (5/10/96)</A></H3><DL><DD>Q:    While a NewtApp application is running, can I change the order in which soup items appear?<BR><BR>A:    Yes, the key to changing the sort order is to modify the query spec in the <CODE>allSoups</CODE> frame, and then cause the application to refresh.  The cursor that controls the sort order for the layout is built from the <CODE>masterSoupSlot </CODE>slot.  Both the default and the overview layouts have a <CODE>masterSoupSlot </CODE>which points back to the relevant <CODE>allSoups </CODE>slot in the app base view. <BR><BR>     Here are the basic steps:<BR><BR>    1) Ensure <CODE>newtAppBase.allSoups </CODE>& <CODE>newtAppBase.allSoups.mySoup </CODE>are writeable.  (Since the frames reside in the package, they are in protected memory.)<BR>    2) Modify the query spec to the new sort order.<BR>    3) Now send <CODE>newtAppBase.allSoups.mySoup:SetupCursor() </CODE>to create a new cursor using the new query spec.<BR>    4) Then do a <CODE>newtAppBase:RedoChildren()</CODE> to display the items in the new sort order.<BR>        The code would look something like:<BR><CODE><PRE>      if IsReadOnly (newtAppBase.allSoups) then        newtAppBase.allSoups := {_proto: newtAppBase.allSoups};   if IsReadOnly (newtAppBase.allSoups.mySoup) then        newtAppBase.allSoups.mySoup :={            _proto: newtAppBase.allSoups.mySoup};        newtAppBase.allSoups.mySoup.soupQuery :=             {indexpath: newKey};            // new sort order!        newtAppBase.allSoups.mySoup:SetupCursor();        newtAppBase:RedoChildren();</CODE></PRE></DL><A NAME="How_to_Avoid_NewtApp_"Please_Insert_the_Card"_Errors"><H3><HR><B> </B>How to Avoid NewtApp "Please Insert the Card" Errors  (5/10/96)</A></H3><DL><DD>Q:    If a NewtApp-based application is on a PC card and the card is removed, the user gets the following error message:<BR><BR>    "The package &lt;package name&gt; still needs the card you removed.  Please insert it now, or information on the card may be damaged."<BR><BR>    How can I avoid this problem?<BR><BR>A:    While a card is unmounting, if an object on the card is still referenced, then the user will get the above error message asking them to reinsert the  card.  For more information about issues for applications running from a PC card see the article "The Newton Still Needs the Card You Removed"<BR><BR>    The <CODE>newtApplication </CODE>method <CODE>NewtInstallScript </CODE>is normally called in the part's <CODE>InstallScript</CODE> function.  One thing the <CODE>NewtInstallScript </CODE>does is register the viewDefs in the NewtApp base view <CODE>allViewDefs</CODE> slot using the global function <CODE>RegisterViewDef</CODE>.  <BR><BR>    Currently, <CODE>RegisterViewDef </CODE>requires that the data definition symbol be internal.  If the symbol is on the card, then when the <CODE>NewtRemoveScript </CODE>tries to unregister the viewDef a reference to data on the card is encountered and the above error message will be shown.  This bug will be fixed in a future ROM.  <BR><BR>    To work around this bug for any 2.0 based ROM, add the following code to your part's <CODE>InstallScript </CODE>before calling <CODE>NewtInstallScript</CODE>:<BR>        <BR><CODE><PRE>    local mainLayout := partFrame.theForm;    if mainLayout.allViewDefs then        foreach dataDefSym,viewDefsFrame in mainLayout.allViewDefs do            foreach viewDef in viewDefsFrame do                RegisterViewDef (                     viewDef, EnsureInternal (dataDefSym) );    partFrame.removeFrame :=         mainLayout:NewtInstallScript(mainLayout);</PRE><BR></CODE>    Note that it is OK to call <CODE>RegisterViewDef </CODE>more than once with the same view definition.  <CODE>RegisterViewDef </CODE>will do nothing (and return NIL) if the template is already registered.</DL><A NAME="Customizing_Filters_with_Labelled_Input_Lines"><H3><HR><B> </B>Customizing Filters with Labelled Input Lines  (9/4/96)</A></H3><DL><DD>Q:    I need to open a slot view on a slot that isn't a standard data type (int, string, etc). How do I translate the data from the soup format to and from a string?<BR><BR>A:    Here is some interim documentation on the filter objects that <CODE>newtLabelInputLines</CODE> (and their variants) use to accomplish their work.<BR><BR>    A filter is an object, specified in the <CODE>'flavor</CODE> slot of the <CODE>newtLabelInputLine</CODE> set of protos, which acts as a translator between the target data frame (or more typically a slot in that frame) and the text field which is visible to the user.  For example, it's the filter for <CODE>newtDateInputLines</CODE> which translates the time-in-minutes value to a string for display, and translates the string into a time-in-minutes for the target data.<BR><BR>    You can create your own custom filters by protoing to <CODE>newtFilter</CODE> or one of the other specialized filters described in Chapter 4 of the Newton Programmer's Guide.<BR><BR>    When a <CODE>newtLabelInputLine</CODE> is opened, a new filter object is instantiated from the template found in the <CODE>'flavor</CODE> slot for that input line.  The instantiated filter can then be found in the <CODE>filter</CODE> slot of the view itself.  The <CODE>_parent</CODE> slot of the instantiated filter will be set to the input line itself, which allows methods in the filter to get data from the current environment.<BR><BR>    Here are the slots which are of interest.  The first four are simply values that you specify which give you control over the recognition settings of the <CODE>inputLine</CODE> part of the field, and the rest are methods which you can override or call as appropriate.<BR><BR>    Settings:<BR>    <CODE>recFlags</CODE><BR>    Works like entryFlags in <CODE>protoLableInputLine</CODE>.  This provides the <CODE>'viewFlags</CODE> settings for the <CODE>inputLine</CODE> part of the proto -- the field the user interacts with.<BR><BR>    <CODE>recTextFlags</CODE><BR>    Provides the <CODE>'textFlags</CODE> settings for the <CODE>inputLine</CODE> part of the proto.<BR><BR>    <CODE>recConfig</CODE><BR>    Provides the <CODE>'recConfig</CODE> settings for the <CODE>inputLine</CODE> part of the proto.<BR><BR>    <CODE>dictionaries</CODE><BR>    Like the <CODE>'dictionaries</CODE> slot used in recognition,  Provides custom dictionaries if <CODE>vCustomDictionaries</CODE> is on in the <CODE>recFlags</CODE> slot.<BR><BR>    Methods:<BR>    <CODE>PathToText()</CODE><BR>    Called when the <CODE>inputLine</CODE> needs to be updated.  The function should read data out of the appropriate slot in the <CODE>'target</CODE> data frame (usually specified in the '<CODE>path</CODE> slot) and return a user-visible string form of that data.  For example, for numbers the function might look like <CODE>func() NumberStr(target.(path))</CODE><BR><BR>    <CODE>TextToPath(str)</CODE><BR>    Called when the <CODE>inputLine</CODE> value changes.  The result will be written into the appropriate slot in the <CODE>'target</CODE> data frame.  The string argument is the one the user has modified from the <CODE>inputLine</CODE> part of the proto.  For example, for numbers the function might look like <CODE>func(str) if StrFilled(str) then StringToNumber(str)</CODE><BR><BR>    <CODE>Picker()</CODE><BR>    An optional function.  If present, this method is called when the user taps on the label part of the item.  It should create and display an appropriate picker for the data type.  For the pre-defined filters, you may also wish to call this method to open the picker.  You should store a reference to the filter in the picker view.  Then if the user picks an item, send the filter instance a <CODE>PickActionScript</CODE> message.  If the picker is cancelled, send a <CODE>PickCancelledScript</CODE> message.<BR><BR>    Note: If this method is defined, a pick separator line and the text "Other..." will be added to the <CODE>labelCommands</CODE> array.<BR><BR>    <CODE>PickActionScript( newValue )</CODE><BR>    An optional function.  This method should be called when the user selects something from the picker opened through the filter's <CODE>Picker</CODE> method.  If you override this method be sure to call the inherited <CODE>PickActionScript</CODE> method.<BR><BR><CODE>    PickCancelledScript()</CODE><BR>    An optional function.  This method should be called when the user cancels the picker opened through the filter's <CODE>Picker</CODE> method.  If you override this method be sure to call the inherited <CODE>PickCancelledScript</CODE> method.<BR><BR><CODE>    InitFilter()</CODE><BR>    Optional.  This method is called when an <CODE>inputLine</CODE> that uses this filter is first opened.  This method can be used to get data from the current environment (for example, the <CODE>'path</CODE> slot of the <CODE>inputLine</CODE>) and adjust other settings as appropriate.</DL><A NAME="Using_Custom_Help_Books_in_a_NewtApp-based_Application"><H3><HR><B> </B>Using Custom Help Books in a NewtApp-based Application  (12/2/96)</A></H3><DL><DD>Q:    I have created a help book for my NewtApp-based application.  Can I make my application open the help book when the user chooses "Help" from the info button?<BR><BR>A:     Yes, there is a <CODE>newtApplication</CODE> slot called <CODE>helpManual</CODE>.  You should store a reference to your help book in this slot.<BR><BR>    There is also a slot called <CODE>viewHelpTopic</CODE> which you can use to dynamically change the location the help book is opened to.  This slot should store the name of the topic to open to.<BR><BR>    See the DTS Sample Code project "Beyond Help" for an example of a help book.</DL><A NAME="Creating_a_Large_newtEditView/newtROEditView"><H3><HR><B> </B>Creating a Large newtEditView/newtROEditView  (12/2/96)</A></H3><DL><DD>Q:    When I use <CODE>newtEditView</CODE> or <CODE>newtROEditView</CODE>, I cannot scroll through all the text of a large note.  After a few pages it stops scrolling.  What is going wrong?<BR><BR>A:    Both <CODE>newtEditView</CODE> and <CODE>newtROEditView</CODE> have a default scroll height of 2,000 pixels.  To work around this limitation, you will need to add a slot called <CODE>noteSize</CODE> to your <CODE>newt(RO)editView</CODE>.  This slot should hold an array of two elements.  The first element is the scroll width.  If you do not want horizontal scrolling, the scroll width should equal the view width.  The second element is the <CODE>scrollHeight</CODE>.<BR><BR>    Here is an example <CODE>noteSize</CODE> slot that you would use to create a <CODE>newt(RO)EditView</CODE> with a scroll height of 20,000 pixels.<BR><BR>    <CODE><PRE>    {        _proto:        newtEditView,    noteSize:    [viewWidth, 20000],    ...</PRE><BR>    }</CODE><BR></DL><A NAME="How_to_Use_ForceNewEntry_with_NewtApp"><H3><HR><B> </B>How to Use ForceNewEntry with NewtApp  (12/2/96)</A></H3><DL><DD>Q:    I have a <CODE>newtApp</CODE>-based application which does not use stationery.  If I set the <CODE>forceNewEntry</CODE> slot to <CODE>nil</CODE> in my layout and open the application with a <CODE>nil</CODE> target, I can still see the entry view.  How can I avoid this?<BR><BR>A:    You will need to check for the existence of a target frame.  If one does not exist then close the entry view.<BR><BR>    You will not have this problem if you use stationery because the <CODE>newtApp</CODE> framework will not open the stationery if a target does not exist.</DL><A NAME="How_to_Programmatically_Open_the_Header_Slip"><H3><HR><B> </B>How to Programmatically Open the Header Slip  (1/3/97)</A></H3><DL><DD>Q:    I like the way the Newton Works application (for Newton 2.1 OS) automatically opens the header slip each time a new entry is created.  Can I make my newtApp-based application do this?<BR><BR>A:    Yes!  The <CODE>newtEntry(Roll/Page)Header</CODE> proto has a <CODE>PopIt</CODE> method which opens the header.  You will need to override the <CODE>StatScript</CODE> of your <CODE>newtNewStationeryButton</CODE> and send the header a <CODE>PopIt</CODE> message.  Because <CODE>PopIt</CODE> is not defined prior to Newton 2.1 OS, you will need to check for its existence before calling it.  Here is a code example:<BR><BR>    <CODE><PRE>    newtNewStationeryButton.    StatScript: func( theStat )        begin            // Keep a copy of the inherited return value for use below            local result := inherited:?StatScript( theStat );            // Pass self as a parameter for the closure.  This gives us a reference            // to the application so we can get the entry view.            AddDeferredCall( func( context )                                 begin                                    local entryView := context:GetTargetView();                                    // This code assumes that your header is declared to the entry                                    // view with the name theHeaderView                                    if entryView.theHeaderView.popIt then                                        entryView.theHeaderView:Popit( true );                                end,                             [self] );            result;        end;</CODE></PRE></DL><A NAME="Programmatically_Changing_the_Default_ViewDef"><H3><HR><B> </B>Programmatically Changing the Default ViewDef  (1/3/97)</A></H3><DL><DD>Q:    I want to be able to programmatically change which viewDef is shown when I tap the "New" button in my newtApp-based application.  How can I do this?<BR><BR>A:    By default, the viewDef which is shown when you create a new entry is the one with the value <CODE>'default</CODE> in its <CODE>symbol</CODE> slot.  To change this behavior at run-time, you will need to override the <CODE>StatScript</CODE> method of your <CODE>newtNewStationeryButton</CODE>.<BR><BR>    In the <CODE>StatScript</CODE> method, you will set two slots in your application.  The first slot is the <CODE>preferredViewDef</CODE> slot in your application's base view.  The second is the <CODE>viewDef</CODE> slot of the current layout.  Both of these slots should be set to the symbol of the viewDef that you want displayed.  For instance, you might have the following <CODE>StatScript</CODE>:<BR><BR><CODE><PRE>StatScript := func( theStat )begin    preferredViewDef := 'myNewDefaultStationery;    layout.viewDef:= 'myNewDefaultStationery;        // Make sure we call the inherited method    inherited:?StatScript( theStat );</PRE><BR>    end;</CODE><BR><BR>    Note: you must not modify either the application's <CODE>preferredViewDef</CODE> slot or the layout's <CODE>viewDef</CODE> slot at any other time.  Doing so could cause your application to not work on future versions of the Newton OS.</DL><A NAME="How_to_Properly_Declare_NewtApp_Views"><H3><HR><B> </B>How to Properly Declare NewtApp Views  (1/6/97)</A></H3><DL><DD>Q:    I have a <CODE>newtEntryPageHeader</CODE> which is declared to my <CODE>newtLayout</CODE> view. Each time I change entries in my application, the header does not get properly updated.  What's going wrong?<BR><BR>A:    If you declare your <CODE>newtApplication</CODE> views, they need to be declared to their parent.  Declaring <CODE>newtApplication</CODE> views to a grandparent can cause undefined behavior.<BR><BR>    Because of how the declare mechanism works, you must be careful when you declare a view to a grandparent view.  In some circumstances, you could try to access a view which has been closed.<BR><BR>    As an example, pretend you have three views called viewA, viewB, and viewC.  They have the following heirarchy.:<BR> <BR>    ViewA                    (grandparent)<BR>        ViewB                (parent)<BR>            ViewC            (child)<BR><BR>    ViewC is a child of viewB and viewB is a child of viewA; ViewC is declared to viewA.  If you close viewB, viewC will also be closed because it is a child of viewB.  Since ViewC was declared to ViewA, ViewA will still have a reference to viewC which has been closed.  Sending view messages to viewC will throw.<BR><BR>    For more information on the Newton OS declare mechanism, see the "Declaring Multiple Levels" Q&amp;A, and the "The Inside Story on Declare" appendix in the Newton Programmer's Guide.</DL><A NAME="How_to_Create_Custom_Overviews_with_NewtApp"><H3><HR><B> </B>How to Create Custom Overviews with NewtApp  (1/8/97)</A></H3><DL><DD>Q:    My NewtApp-based application can print successfully, but I want a custom format that can print multiple items on one page or handle different transports than the default overview supports. How do I do this?<BR><BR>A:    Add an <CODE>overviewTargetClass</CODE> slot to your application (or any other layout that is a descendent of your <CODE>newtOverLayout</CODE>). Set this slot's value to be the symbol that represents your data class (for example, <CODE>'|myData:SIG|</CODE>), which must match the data class you use when registering your print format. The NewtApp overview will use <CODE>overviewTargetClass</CODE> instead of the default overview class (<CODE>'newtOverview</CODE>) supplied by <CODE>newtOverLayout</CODE>. <BR><BR>    You must still register your print format, but you must set its <CODE>usesCursors</CODE> slot to <CODE>true</CODE> indicating that it will use the value target as a multiple item target and it will iterate over it using <CODE>GetTargetCursor(target)</CODE>. For an example of a print format that can handle multiple items, see the MultiRoute DTS sample.<BR><BR>    For more information about the default overview class  (<CODE>'newtOverview</CODE>) , see the Q&amp;A "Limitations with NewtOverview Data Class".<BR><BR></DL><A NAME="How_to_Store_Prefs_in_a_NewtApp-based_Application"><H3><HR><B> </B>How to Store Prefs in a NewtApp-based Application  (1/17/97)</A></H3><DL><DD>Q:    I want to save application-specific preferences and state information before my application is closed.  What is the best way to do this?<BR><BR>A:    You can save application-specific information in the frame in the <CODE>prefsCache</CODE> slot of your NewtApp-based application.  This slot is defined in your application's base view by the NewtApp framework.  This frame will be saved to the system soup when the application closes.  <BR><BR>    When you add to the <CODE>prefsCache</CODE> frame, you must use your registered signature to avoid conflicting with slots that the framework may use.  You can name each of your preferences with your signature, or we recommend adding a subframe in a slot named with your signature.  For instance, you might have the following code:<BR><BR>        <CODE>prefsCache.('|MyPrefs:MySIG|) := {pref1: 1, pref2: 2};</CODE><BR></DL><A NAME="A_CheckAll_Button_for_NewtApp_Overviews"><H3><HR><B> </B>A CheckAll Button for NewtApp Overviews  (3/4/97)</A></H3><DL><DD>Q:    What do I have to do to get the Check All button to appear in my overview? What's the compatible way to do this so that the application works on Newton 2.0 OS  as well?<BR><BR>A:    In Newton  2.1 OS, there is a proto called <CODE>newtCheckAllButton</CODE> (<CODE>@872</CODE>) which you can use.  This proto sends the <CODE>CheckAll</CODE> method to the layout.  In Newton 2.1  OS, <CODE>newtOverLayouts</CODE> have two new methods, <CODE>CheckAll</CODE> and <CODE>UncheckAll,</CODE> which implement this behavior.  However, none of this is present in Newton 2.0 OS .<BR><BR>    To create a check all button that works on the Newton 2.0 OS, you will need to create the button yourself and implement the <CODE>CheckAll</CODE> and <CODE>UncheckAll</CODE> methods for your overview layout (or any other layout you wish to implement check all for.)<BR><BR>    Older versions of the DTS sample code (either "Checkbook-7" or "WhoOwesWhom-3") do have a <CODE>protoCheckAllButton</CODE>.  These samples implement an earlier (and less useful) flavor of Check All.  The old samples check all the items which are currently visible in the overview, while the Newton 2.1 OS checks all the items that are present in the currently selected folder/card filter.  "Checkbook" (version 8 or later) or "WhoOwesWhom" (version 3 or later) will reflect the Newton 2.1 behavior.<BR><BR>    Until the updated samples are available, start with the <CODE>protoCheckAllButton</CODE> from the older sample code, since that gives the correct look and button bounds, and modify it as follows:<BR><BR>    The check all button's <CODE>buttonClickScript</CODE> should look something like this:<BR><CODE><PRE>   func()        if newtAppBase.currentLayout = 'overView then            begin                if layout.checkAllPrimed then                    layout:UnCheckAll()                else                    layout:CheckAll();                layout.checkAllPrimed := NOT layout.checkAllPrimed;            end;</PRE><BR></CODE><BR>    The overview layout's CheckAll and UncheckAll methods should look something like this:<BR><BR><CODE><PRE>    CheckAll:        func()            begin                local curse := dataCursor:Clone();                curse:Reset();                hilitedIndex := nil;                selected := MapCursor(curse, func(e) MakeEntryAlias(e));                AddUndoSend(layout, 'UnCheckAll, []);                layout:DoRetarget();            end;    UncheckAll:        func()            begin                hilitedIndex := nil;                selected := nil;                layout:DoRetarget();            end</PRE><BR></CODE><BR>    Note that these methods make use of two undocumented slots: <CODE>hilitedIndex</CODE> and <CODE>selected</CODE>.  <CODE>hilitedIndex</CODE> is used internally by <CODE>newtOverLayout</CODE> to track the tapped item.  You may set it to <CODE>NIL</CODE> (as above) to clear the value, but do not set it to some other value or rely on its current value.  <CODE>selected</CODE> contains an array of aliases to soup entries representing the currently selected items, and will be used by the routing and filing buttons for processing entries.  It is important to clear <CODE>hilitedIndex</CODE> when modifying the <CODE>selected</CODE> array in any way.<BR><BR>    The resulting CheckAll button should be included in the <CODE>menuRightButtons</CODE> array for the status bar.  The older sample code puts it on the left, however  user interface discussions as part of the Newton 2.1 OS effort resulted in the decision to place the button on the right.<BR></DL><A NAME="Creating_a_Simple_NewtApp"><H3><HR><B> </B>Creating a Simple NewtApp  (4/7/97)</A></H3><DL><DD>Q:    What are the basic steps to create a simple NewtApp-based application?<BR><BR>A:    The following steps will create a basic NewtApp-based application:<BR><BR>    <B>Basic Setup</B><BR>    1)    Create a project.<BR>    2)    In NTK's Project Settings dialog, set Platform to "Newton 2.0" or "Newton 2.1".<BR><BR>    <B>Create the NewtApp base view<BR>    </B>1)    Create a layout file.<BR>    2)    Drag out a <CODE>newtApplication</CODE>.<BR>    3)    Set the following slots to the following values:<BR>        <CODE><PRE>        allLayouts:    {</PRE><BR>                default:    GetLayout("default.t"),    </CODE>// see step 9 in the next section<CODE><BR>                overview:    GetLayout("Overview.t"),    </CODE>// set step 4, overview section<CODE><BR>            }</CODE><BR><CODE><PRE>    allSoups:       {        mySoup: {            _proto: newtSoup,            soupName: "SoupName:SIG",            soupIndices: [],            soupQuery: {}  } }    title: kAppName</PRE><BR></CODE>    4)    Draw a <CODE>newtClockFolderTab </CODE>or <CODE>newtFolderTab </CODE>as a child of the <CODE>newtApp</CODE>.<BR>    5)    Draw a <CODE>newtStatusBar </CODE>as a child of the <CODE>newtApp</CODE>.<BR>    6)    For the <CODE>newtStatusBar </CODE>set the following slots:<BR><CODE><PRE>    menuLeftButtons:  [newtInfoButton]    menuRightButtons: [newtActionButton, newtFilingButton]</PRE><BR></CODE>    7)     Save the layout file as <CODE>"main.t" </CODE>and add it to the project.<BR><BR><B>    Create the default view</B>:<BR>    1)    Create another layout file.<BR>    2)    Draw a <CODE>newtLayout </CODE>in the new layout file.<BR>    3)   Add a <CODE>viewJustify </CODE>slot to the <CODE>newtLayout </CODE>and set it to <CODE>parentRelativeFull </CODE>horizontal and vertical.<BR>    4)    Set the <CODE>viewBounds </CODE>of the <CODE>newtLayout </CODE>to:  <BR>        <CODE><PRE>        {top: 20, // leave room for the folder tab    bottom: -25,  // leave room for the status bar    left: 0,     right: 0}</PRE><BR></CODE>    5)    Draw a <CODE>newtEntryView </CODE>as a child of the <CODE>newtLayout</CODE>.<BR>    6)    Add a <CODE>viewJustify </CODE>slot and set it to <CODE>parentRelativeFull </CODE>horizontal and vertical (necessary only until platform file is updated).<BR>    7)    Set the <CODE>viewBounds </CODE>of the newtEntryView to: <BR>        <CODE><PRE>        {top: 0, bottom: 0, right: 0, left: 0};</PRE><BR></CODE>    8)    Draw slot views as children of the entry view to display slots from the soup entry.          <BR>        For example:<BR>        a)      Draw a <CODE>newtLabelInputLine </CODE>as a child of the <CODE>newtEntryView</CODE>.<BR>        b)      Set the following slots:<BR><CODE><PRE>        label:  "My Label"        path:   'myTextSlot</PRE><BR></CODE>        c)      Draw a <CODE>newtLabelNumInputLine </CODE>as a child of the <CODE>newtEntryView</CODE>.<BR>        d)      Set the following slots:<BR><CODE><PRE>        label:  "Number"        path:   'myNumberSlot</PRE><BR></CODE>    9)    Save the layout file as <CODE>"default.t"</CODE> and add it to the project. Move it so that it is compiled before the main layout (use the Process Earlier menu item).<BR><BR><B>    Add Overview support<BR></B>    1)    Create another layout file.<BR>    2)    Draw a <CODE>newtOverLayout </CODE>in the new layout file.<BR>    3)    Add the <CODE>Abstract </CODE>slot to the <CODE>newtOverLayout</CODE>, for example:<BR>            <CODE><PRE>            Abstract := func(item, bbox )        begin            local t := item.myTextSlot & ",";            if item.myNumberSlot then                t := t && NumberStr(item.myNumberSlot);            MakeText(t, bbox.left+18, bbox.top,                bbox.right, bbox.bottom - 18);        end;</PRE><BR></CODE>    4)    Save the layout file as "overview.t" and add it to the project. Move it so that it is compiled before the main layout (use the Process Earlier menu item).<BR><BR><B>    Add InstallScript and RemoveScript<BR></B>    1)    Create a text file and add the following to it:<BR><CODE><PRE>    InstallScript := func(partFrame) begin    partFrame.removeFrame :=        (partFrame.theForm):NewtInstallScript(partFrame.theForm);    end;    RemoveScript := func(partFrame) begin         (partFrame.removeFrame):      NewtRemoveScript(partFrame.removeFrame);    end;</PRE><BR></CODE>    2)    Save the text file and add it to the project.</DL><A NAME="Registering_Soup_Change_Notifications_in_NewtApp"><H3><HR><B>NEW: </B>Registering Soup Change Notifications in NewtApp  (5/15/97)</A></H3><DL><DD>Q:    I have an application based on the NewtApp framework.  When I register to receive soup change notifications, things start to behave strangely.  What's going wrong?<BR><BR>A:    This problem is caused because of a naming conflict.  When your application is opened, the NewtApp framework registers to receive soup change notifications using your application's symbol as the <CODE>callbackID</CODE> parameter to the <CODE>RegSoupChange</CODE> global function.  If you also use your application's symbol as the <CODE>callbackID</CODE> parameter, you will overwrite the NewtApp framework's registration.  There are two ways to work around this problem.<BR><BR>    1) Use a different <CODE>callbackID</CODE> symbol in your call to <CODE>RegSoupChange</CODE>.<BR>    2) Use the NewtApp framework's registration callback method.  When your soup has changed, the NewtApplication's <CODE>NewtSoupChangedNotify</CODE> method is called.  It is passed the same four parameters as the callback function parameter of <CODE>RegSoupChange</CODE>.<BR><BR>    If you do override the <CODE>NewtSoupChangedNotify</CODE> method, be sure to call the inherited method.<BR><BR>    Here is an example:<BR><BR>    <CODE><PRE>    application:NewtSoupChangedNotify(theName, appSym, changeType, changeData)begin    // Do your stuff here        inherited:?NewtSoupChangedNotify( theName, appSym, changeType, changeData );end;</CODE></PRE></DL>
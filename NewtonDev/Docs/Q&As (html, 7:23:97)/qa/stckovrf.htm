<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: NTK Stack Overflow During Compilation</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>NTK Stack Overflow During Compilation</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>NTK Stack Overflow During Compilation  (11/24/95)</H3><DL><DD>Q:    When I build my project that has very deeply nested statements, NTK runs out of memory and quits.  What's going wrong?<BR><BR>A:    The deep nesting in your project is causing the compiler to overflow the stack space available in NTK.  NTK 1.6 is more likely than than NTK 1.5 to suffer this problem due to new compiler code which nests deeper while parsing if-then-else statements, causing the stack to overflow into the application heap.  <BR><BR>    If you see an inadvertent crash in NTK during a save operation or a package build:<BR><BR>    1)  If you are familiar with MacsBug, examine the stack.  This particular case will show up in the stack as several calls to the same function before the actual crash.<BR>    2) Otherwise, temporarily reduce the number of "else" branches and rebuild the package. If the problem disappears, stack overflow is the prime suspect.<BR><BR>    There are at least three ways to avoid this problem and possibly improve performance at the same time:<BR>    1)    Re-arrange the 'else' statements to resemble a balanced tree<BR>    2)    Instead of If-then-else statements use:<BR>         An array of functions (with integers as selectors)<BR>         A frame of functions (with symbols as selectors)<BR>    3)    Finally, as a temporary work around, you can increase the stack size using the ResEdit application.<BR><BR><B>    Re-arrange the 'else' statements to resemble a balanced tree<BR></B>    <BR>    This solution is the simplest to implement if you need to change existing code. It accommodates non-contiguous integer selectors, and in most cases is faster.<BR><BR>    For example, the following code:<BR><CODE> <PRE>   if x = 1 then        dosomething    else        if x = 2 then            doSomethingElse        else            if x = 3 then                doYetAnotherThing            else                if x = 4 then                    doOneMoreThing                else                    if x = 5 then                        doSomethingSimple                    else                        if x = 6 then                            doThatThing                        else                            if x = 7 then                                doThisThing                            else // x = 8                                doTheOtherThing</PRE><BR></CODE>    ...can be rewritten like this:<BR><BR><CODE> <PRE>   if x &lt;= 4 then        if x &lt;= 2 then            if x = 1 then                doSomething            else // x = 2                doSomethingElse        else            if x = 3 then                doYetAnotherThing            else // x = 4                doOneMoreThing    else        if x &lt;= 6 then            if x = 5 then                doSomethingSimple            else // x = 6                doThatThing        else           if x = 7 then                doThisThing           else // x = 8                doTheOtherThing;</PRE><BR></CODE>    Note that the if/then/else statement nesting is "unusual" to illustrate the nesting that the compiler must make each statement is nested as the compiler would process it.<BR><CODE><BR></CODE><BR><B>    Use an array of functions with integer selectors<BR><BR></B>    Replace a long if-then-else statement with an array of functions. The code is more compact and readable. For a large set of alternatives, the faster direct lookup should compensate for the extra function call. This approach is most useful for a contiguous range of selector values (e.g., 11 to 65). It can accommodate a few "holes" (for example, 11 to 32, 34 to 56, 58 to 65). It is not practical for non-contiguous selectors (e.g., 31, 77, 256, 1038...)<BR><BR>    For example, the following code:<BR><BR><CODE><PRE>    if x = 1 then        dosuchandsuch;    else        if x = 2 then            dosomethingelse;        else            if x = 3 then                andsoon;</PRE><BR></CODE>       ...can be rewritten like this:<BR><BR><CODE>        <PRE>        cmdArray := [func() dosuchandsuch,        func() dosomethingelse,            func() andsoon];        call cmdArray[x] with ();</PRE><BR></CODE><BR><B>    Use a frame of functions with symbols for selectors<BR></B><BR>    This alternative provides the flexibility of using symbols for selecting the outcome.<BR><BR>     For example, the following code:<BR><BR><CODE><PRE>    if x = 'foo then        dosuchandsuch;    else        if x = 'bar then            dosomethingelse;        else            if x = 'baz then                andsoon;</PRE><BR></CODE><BR>    ...can be rewritten like this:<BR><CODE><PRE>    cmdFrame := {foo: func() dosuchandsuch,                    bar: func() dosomethingelse,                    baz: func() andsoon};      call cmdFrame.(x) with ();</PRE><BR><B></CODE>    Increase NTK's stack size using the ResEdit application<BR><BR></B>    Open the Newton Toolkit application with ResEdit.<BR><BR>    Double-click on the "<CODE>mem!</CODE>" resource icon<BR><BR>    Double-click on resource ID <CODE>1000 </CODE>named "Additional NTK Memory Requirements"<BR><BR>    Change the fifth (and last) value. This is an hexadecimal number. In NTK 1.6, you should see "<CODE>0001 8000</CODE>" which is <CODE>98304</CODE> bytes (or <CODE>96k</CODE>) to add to the total stack size. For example, to increase this value to <CODE>128k</CODE> = <CODE>131072</CODE> bytes change the hexadecimal value to "<CODE>0002 0000</CODE>".<BR></DL>
// Text of project True Grid written on 4/17/97 at 2:43 PM// Beginning of text file Project Data// Copyright й 1994-1995 Apple Computer, Inc. All rights reserved.constant kAppObject := '["Record", "Records"];constant kSoupName := kAppString; 					// "TrueGrid:PIEDTS";DefConst('kSoupIndexes, '[{structure: slot, path: aString, type: string}]);constant kSoupPad := 256;	// bytes of "undisplayed" data in the soup.constant kNumbersList := '["1", "5", "10", "25", "50", "100"];constant kNumbersArray := '[1, 5, 10, 25, 50, 100];// for tracking hilite in drawn rowsDefConst('kXORstyle, {penPattern: vfNone, transferMode: modeXor, fillPattern: vfBlack});// for drawn row.DefConst('kLeftTextStyle, {font: ROM_fontSystem9, penSize: 1, penPattern: vfBlack, justification: 'left});DefConst('kCenterTextStyle, {font: ROM_fontSystem9, penSize: 1, penPattern: vfBlack, justification: 'center});DefConst('kRightTextStyle, {font: ROM_fontSystem9, penSize: 1, penPattern: vfBlack, justification: 'right});DefConst('kBorderStyle, {penPattern: vfGray});// еее This is used to create our union soups with RegUnionSoup(...).DefConst('kMySoupDef, {	name:			kSoupName,	userName:		"TrueGrid Data",	ownerApp:		kAppSymbol,	ownerAppName: 	"True Grid",	userDescr:		"Data for the True Grid DTS Sample",	indexes:		kSoupIndexes,});// End of text file Project Data// Beginning of file protoDrawnRow// Before Script for "protoDrawnRow"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.protoDrawnRow :=    {viewFlags: 515,     viewFormat: 305,     viewBounds: {left: 0, top: 0, right: 220, bottom: 13},     UpdateFromSoup:       func(entry)       begin          myEntryKey := if entry then entry.aString else nil;       	shapes := if entry then       	   [          	   kLeftTextStyle,            	   MakeText(entry.aString, 0,0,160,10),          	   kRightTextStyle,             	MakeText(SPrintObject(entry.anInteger), 120,0,160,10),          	   kCenterTextStyle,             	MakeText(ShortDateStr(entry.aDate, kIncludeAllElements), 160,0,220,10),             	kBorderStyle,             	MakeLine(120,0,120,13),             	MakeLine(160,0,160,13),          	]       	else       		[             	kBorderStyle,             	MakeLine(120,0,120,13),             	MakeLine(160,0,160,13),       		];       end,     ViewDrawScript:       func()       begin          :DrawShape(shapes, nil);       end,     shapes: nil,     viewJustify: 8192,     ViewClickScript:       func(unit)       begin       	if :TrackHilite(unit) then       		:EntrySelected(if myEntryKey then myCursor:GotoKey(myEntryKey) else nil);       	:Hilite(nil);       end,     myEntryKey: nil,     debug: "protoDrawnRow",     viewClass: 74    };constant |layout_protoDrawnRow| := protoDrawnRow;// End of file protoDrawnRow// Beginning of file protoSimpleRow// Before Script for "protoSimpleRow"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.protoSimpleRow :=    {viewFlags: 515,     viewFormat: 0,     viewBounds: {left: 0, top: 0, right: 220, bottom: 13},     UpdateFromSoup:       func(entry)       begin       	if entry then begin       	   myEntryKey := entry.aString;       		SetValue(stringView, 'text, entry.aString);       		SetValue(integerView, 'text, SPrintObject(entry.anInteger));       		SetValue(dateView, 'text, ShortDateStr(entry.aDate, kIncludeAllElements));       	end;       	else begin       		myEntryKey := nil;       		SetValue(stringView, 'text, nil);       		SetValue(integerView, 'text, nil);       		SetValue(dateView, 'text, nil);       	end;       end,     viewJustify: 8192,     ViewClickScript:       func(unit)       begin       	if :TrackHilite(unit) then       		:EntrySelected(if myEntryKey then myCursor:GotoKey(myEntryKey) else nil);       	:Hilite(nil);       end,     myEntryKey: nil,     debug: "protoSimpleRow",     viewClass: 74    };stringView :=    {viewFlags: 134217731,     viewFormat: 305,     viewFont: ROM_fontSystem9,     viewBounds: {left: 0, top: 0, right: 120, bottom: 13},     viewJustify: 8388612     ,     debug: "stringView",     viewClass: 81    };AddStepForm(protoSimpleRow, stringView);StepDeclare(protoSimpleRow, stringView, 'stringView);integerView :=    {viewFlags: 134217731,     viewFormat: 305,     viewFont: ROM_fontSystem9,     viewBounds: {left: 120, top: 0, right: 160, bottom: 13},     viewJustify: 8388613,     debug: "integerView",     viewClass: 81    };AddStepForm(protoSimpleRow, integerView);StepDeclare(protoSimpleRow, integerView, 'integerView);dateView :=    {viewFlags: 134217731,     viewFormat: 305,     viewFont: ROM_fontSystem9,     viewBounds: {left: 160, top: 0, right: 220, bottom: 13},     viewJustify: 8388614,     debug: "dateView",     viewClass: 81    };AddStepForm(protoSimpleRow, dateView);StepDeclare(protoSimpleRow, dateView, 'dateView);constant |layout_protoSimpleRow| := protoSimpleRow;// End of file protoSimpleRow// Beginning of file Columns.t// Before Script for "columns"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.columns :=    {myCursor: nil,     ViewSetupDoneScript:       func()       begin       	visibleRows := :LocalBox().bottom DIV viewLineSpacing + 1;       	myCursor := theCursor:Clone();       	myCursor:Reset();       	topEntry := myCursor:Entry();          :FillCache();       end,     viewFormat: 337,     viewLineSpacing: 13,     ViewQuitScript:       func()       begin          keyArray := nil;          stringCache := nil;          dateCache := nil;          integerCache := nil;          myCursor := nil;       end,     integerCache: nil,     stringCache: nil,     viewFlags: 544,     viewBounds: {top: 60, left: 0, right: 220, bottom: -22},     fillCache:       func()       begin       	local stringArray;       	local integerArray;       	local dateArray;       	local entry := topEntry;              	// Note that this isn't as memory-efficient as it could be, but it       	// is the fastest way to load the cache with a page-full of information.       	// See the method used in "Cached Columns.t" for a more memory-efficient solution.              	keyArray := Array(visibleRows, nil);       	stringArray := Array(2*visibleRows-1, $\n);       	integerArray := Array(2*visibleRows-1, $\n);       	dateArray := Array(2*visibleRows-1, $\n);       	       	if entry then begin       		myCursor:Goto(topEntry);       		for i := 0 to visibleRows-1 do begin       			stringArray[i*2] := entry.aString;       			integerArray[i*2] := entry.anInteger;       			dateArray[i*2] := ShortDateStr(entry.aDate, kIncludeAllElements);       			keyArray[i] := entry.aString;       			if not entry := myCursor:Next() then begin       				SetLength(keyArray, i+1);       				break;       			end;       		end;       	end;       	else       		SetLength(keyArray, 0) ;       		          SetValue(stringCol, 'text, Stringer(stringArray));          SetValue(integerCol, 'text, Stringer(integerArray));          SetValue(dateCol, 'text, Stringer(dateArray));       end,     viewOriginY: 0,     ViewScrollDownScript:       func()       begin       	myCursor:Goto(topEntry);       	if not topEntry := myCursor:Move(visibleRows - 2) then       		if not topEntry := myCursor:Move(2 - visibleRows) then       			topEntry := myCursor:Next();       	:fillCache();       end,     viewJustify: 208,     topEntry: nil,     visibleRows: nil,     ViewScrollUpScript:       func()       begin       	myCursor:Goto(topEntry);       	if not topEntry := myCursor:Move(2 - visibleRows) then       		topEntry := myCursor:Next();       	:fillCache();       end,     keyArray: nil,     ViewClickScript:       func(unit)       begin          InkOff(unit);          Clicker();          local box := :LocalBox();          local row := (GetPoint(finalY, unit) - :GlobalBox().top) div viewLineSpacing;          local theRow := row;          local inside := true;          local t := MakeRect(0, row * viewLineSpacing, box.right, (row+1) * viewLineSpacing);          :DoDrawing('DrawShape, [t, kXORstyle]);          repeat             row := (GetPoint(finalY, unit) - :GlobalBox().top) div viewLineSpacing;             if inside and row <> theRow then begin                :DoDrawing('DrawShape, [t, kXORstyle]);                inside := nil;             end;       		else if not inside and row = theRow then begin       			:DoDrawing('DrawShape, [t, kXORstyle]);       			inside := true;       		end;	             sleep(1);          until StrokeDone(unit);                  row := (GetPoint(finalY, unit) - :GlobalBox().top) div viewLineSpacing;          if row = theRow and row < length(keyArray) then              :EntrySelected(myCursor:GotoKey(keyArray[row]));          else             :EntrySelected(nil);          if inside then          	begin	// simply XOring the rectangle again won't work, :EntrySelected() changes drawing.          		:Dirty();          		RefreshViews();          	end       end;,     viewClass: 74,     debug: "columns",     dateCache: nil,     SoupChanged:       func(theSoupName)       	if StrEqual(theSoupName, kSoupName) then begin       		topEntry := myCursor:Reset();       	   :FillCache();       end    };stringCol :=    {viewFormat: 12593,     viewFont: ROM_fontSystem9;,     viewBounds: {left: 0, top: 0, right: 300, bottom: 1000},     viewFlags: 134217731,     viewLineSpacing: 13,     debug: "stringCol",     viewClass: 81    };AddStepForm(columns, stringCol);StepDeclare(columns, stringCol, 'stringCol);dateCol :=    {viewFlags: 134217731,     viewFormat: 12593,     viewBounds: {top: 0, left: -60, right: 0, bottom: 1000},     viewFont: ROM_fontSystem9;,     viewLineSpacing: 13,     viewJustify: 34,     debug: "dateCol",     viewClass: 81    };AddStepForm(columns, dateCol);StepDeclare(columns, dateCol, 'dateCol);integerCol :=    {viewFlags: 134217731,     viewFormat: 12593,     viewFont: ROM_fontSystem9;,     viewBounds: {top: 0, left: -40, right: 0, bottom: 1000},     viewLineSpacing: 13,     viewJustify: 2049,     debug: "integerCol",     viewClass: 81    };AddStepForm(columns, integerCol);StepDeclare(columns, integerCol, 'integerCol);constant |layout_Columns.t| := columns;// End of file Columns.t// Beginning of file Cached Columns.t// Before Script for "cachedColumns"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.cachedColumns :=    {viewFlags: 544,     viewFormat: 337,     viewBounds: {top: 60, left: 0, right: 220, bottom: -22},     fillCache:       func()       begin       	local stringCache := clone("");       	local integerCache := clone("");       	local dateCache := clone("");              	// Note that this isn't as fast as it could be, but it takes the least amount       	// of memory... important when we're trying to load the entire soup into the cache.       	// See the method used in "Columns.t" for a faster way to fill the cache.       	local f := func(entry)       		begin       			StrMunger(stringCache, StrLen(stringCache), 0, entry.aString & $\n, 0, nil);       			StrMunger(integerCache, StrLen(integerCache), 0, SPrintObject(entry.anInteger) & $\n, 0, nil);       			StrMunger(dateCache, StrLen(dateCache), 0, ShortDateStr(entry.aDate, kIncludeAllElements) & $\n, 0, nil);       			entry.aString;       		end;                 myCursor:Reset();          keyArray := MapCursor(myCursor, f);          SetValue(stringCol, 'text, stringCache);          SetValue(integerCol, 'text, integerCache);          SetValue(dateCol, 'text, dateCache);       end,     keyArray: nil,     viewOriginY: 0,     ViewScrollUpScript:       func()       begin          :SetOrigin(0, MAX(viewOriginY - scrollIncrement, 0));       end,     ViewScrollDownScript:       func()       begin          :SetOrigin(0, viewOriginY + scrollIncrement);       end,     viewLineSpacing: 13,     ViewSetupDoneScript:       func()       begin       	scrollIncrement := (:LocalBox().bottom DIV viewLineSpacing - 1) * viewLineSpacing;          :SetOrigin(0,0);          myCursor := theCursor:Clone();          myCursor:Reset();          :FillCache();       end,     SoupChanged:       func(theSoupName)       if StrEqual(theSoupName, kSoupName) then begin          :SetOrigin(0,0);          :FillCache();       end,     ViewClickScript:       func(unit)       begin          InkOff(unit);          Clicker();          local box := :LocalBox();          local row := (GetPoint(finalY, unit) - :GlobalBox().top) div viewLineSpacing;          local oldRow := row;          local t := MakeRect(0, row * viewLineSpacing, box.right, (row+1) * viewLineSpacing);          :DoDrawing('DrawShape, [t, kXORstyle]);          repeat             row := (GetPoint(finalY, unit) - :GlobalBox().top) div viewLineSpacing;             if row <> oldRow then begin       		 Clicker();                :DoDrawing('DrawShape, [t, kXORstyle]);                t := MakeRect(0, row * viewLineSpacing, box.right, (row+1) * viewLineSpacing);                :DoDrawing('DrawShape, [t, kXORstyle]);                oldRow := row;             end;             sleep(1);          until StrokeDone(unit);                  row := (GetPoint(finalY, unit) - :GlobalBox().top + viewOriginY) div viewLineSpacing;          if row < length(keyArray) then              :EntrySelected(myCursor:GotoKey(keyArray[row]));          else             :EntrySelected(nil);          :DoDrawing('DrawShape, [t, kXORstyle]);       end;,     ViewQuitScript:       func()       begin          keyArray := nil;          stringCache := nil;          dateCache := nil;          integerCache := nil;          myCursor := nil;       end,     myCursor: nil,     scrollIncrement: nil,     viewJustify: 208,     debug: "cachedColumns",     viewClass: 74    };stringCol :=    {viewFormat: 12593,     viewFont: ROM_fontSystem9;,     viewBounds: {left: 0, top: 0, right: 300, bottom: 1000},     viewFlags: 134217731,     viewLineSpacing: 13,     debug: "stringCol",     viewClass: 81    };AddStepForm(cachedColumns, stringCol);StepDeclare(cachedColumns, stringCol, 'stringCol);dateCol :=    {viewFlags: 134217731,     viewFormat: 12593,     viewBounds: {top: 0, left: -60, right: 0, bottom: 1000},     viewFont: ROM_fontSystem9;,     viewLineSpacing: 13,     viewJustify: 34,     debug: "dateCol",     viewClass: 81    };AddStepForm(cachedColumns, dateCol);StepDeclare(cachedColumns, dateCol, 'dateCol);integerCol :=    {viewFlags: 134217731,     viewFormat: 12593,     viewFont: ROM_fontSystem9;,     viewBounds: {top: 0, left: -40, right: 0, bottom: 1000},     viewLineSpacing: 13,     viewJustify: 2049,     debug: "integerCol",     viewClass: 81    };AddStepForm(cachedColumns, integerCol);StepDeclare(cachedColumns, integerCol, 'integerCol);constant |layout_Cached Columns.t| := cachedColumns;// End of file Cached Columns.t// Beginning of file Draw Rows.t// Before Script for "drawRows"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.drawRows :=    {viewFlags: 32,     viewFormat: 337,     viewBounds: {top: 60, left: 0, right: 220, bottom: -22},     fillCache:       func()       begin          local fillCursor := myCursor:Clone();          for i := 0 to numChildren-1 do begin             :ChildViewFrames()[i]:UpdateFromSoup(fillCursor:Entry());             fillCursor:Next();          end;       	:Dirty();       end,     ViewScrollUpScript:       func()       begin       	myCursor:Move(2 - numChildren);       	if not myCursor:Entry() then myCursor:Next();       	:FillCache();       end,     ViewScrollDownScript:       func()       begin       	myCursor:Move(numChildren-2);       	:FillCache();       end,     ViewSetupDoneScript:       func()       begin          myCursor := theCursor:Clone();          myCursor:Reset();          :FillCache();       end,     SoupChanged:       func(theSoupName)       if StrEqual(theSoupName, kSoupName) then begin          myCursor:Reset();          :FillCache();       end,     ViewClickScript:              func(unit)       begin              end;,     ViewQuitScript:       func()       begin          keyArray := nil;          stringCache := nil;          dateCache := nil;          integerCache := nil;          myCursor := nil;       end,     ViewSetupChildrenScript:       func()       begin          numChildren := :LocalBox().bottom DIV 13 + 1;          self.stepChildren := Array(numChildren, GetLayout("protoDrawnRow"));       end,     numChildren: nil,     myCursor: nil,     viewJustify: 208,     debug: "drawRows"     ,     viewClass: 74    };constant |layout_Draw Rows.t| := drawRows;// End of file Draw Rows.t// Beginning of file Cached Draw Rows.t// Before Script for "cachedDrawRows"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.cachedDrawRows :=    {viewFlags: 32,     viewFormat: 337,     viewBounds: {top: 60, left: 0, right: 220, bottom: -22},     fillCache:       func()       begin       	local childTemplate;       	local visibleChildren := :LocalBox().bottom DIV viewLineSpacing + 1;       	          local f := func(entry)             begin             	childTemplate := {_proto: GetLayout("protoDrawnRow")};             	childTemplate:UpdateFromSoup(entry);             	AddArraySlot(stepChildren, childTemplate);        			entry.aString;             end;       	       	stepChildren := [];       	myCursor:Reset();       	keyArray := MapCursor(myCursor, f);       	numChildren := length(keyArray);       	maxScrollHeight := MAX(0, numChildren - visibleChildren + 2) * viewLineSpacing;       	for i := 0 to MAX(2, visibleChildren - numChildren + 2) do begin       		childTemplate := {_proto: GetLayout("protoDrawnRow")};       		childTemplate:UpdateFromSoup(nil);       		AddArraySlot(stepChildren, childTemplate);       	end;       end,     ViewScrollUpScript:       func()       begin          :SetOrigin(0, MAX(viewOriginY - scrollIncrement, 0));       end,     ViewScrollDownScript:       func()       begin          :SetOrigin(0, MIN(viewOriginY + scrollIncrement, maxScrollHeight));       end,     SoupChanged:       func(theSoupName)       if StrEqual(theSoupName, kSoupName) then begin          myCursor:Reset();          :FillCache();          :RedoChildren();       end,     ViewQuitScript:       func()       begin          keyArray := nil;          stringCache := nil;          dateCache := nil;          integerCache := nil;          myCursor := nil;       end,     ViewSetupChildrenScript:       func()       begin       	self.stepChildren := nil;          myCursor := theCursor:Clone();          :FillCache();       end,     numChildren: nil,     myCursor: nil,     viewJustify: 208,     ViewSetupDoneScript:       func()       begin       	scrollIncrement := (:LocalBox().bottom DIV viewLineSpacing - 1) * viewLineSpacing;       end,     scrollIncrement: nil,     viewOriginX: 0,     viewOriginY: 0,     viewLineSpacing: 13,     maxScrollHeight: nil,     debug: "cachedDrawRows",     viewClass: 74    };constant |layout_Cached Draw Rows.t| := cachedDrawRows;// End of file Cached Draw Rows.t// Beginning of file SimpleRows.t// Before Script for "simpleRows"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.simpleRows :=    {viewFlags: 32,     viewFormat: 337,     viewBounds: {top: 60, left: 0, right: 220, bottom: -22},     fillCache:       func()       begin          local fillCursor := myCursor:Clone();          for i := 0 to numChildren-1 do begin             :ChildViewFrames()[i]:UpdateFromSoup(fillCursor:Entry());             fillCursor:Next();          end;       	:Dirty();       end,     ViewScrollUpScript:       func()       begin       	myCursor:Move(2 - numChildren);       	if not myCursor:Entry() then myCursor:Next();       	:FillCache();       end,     ViewScrollDownScript:       func()       begin       	myCursor:Move(numChildren-2);       	:FillCache();       end,     ViewSetupDoneScript:       func()       begin          myCursor := theCursor:Clone();          myCursor:Reset();          :FillCache();       end,     SoupChanged:       func(theSoupName)       if StrEqual(theSoupName, kSoupName) then begin          myCursor:Reset();          :FillCache();       end,     ViewClickScript:              func(unit)       begin              end;,     ViewQuitScript:       func()       begin          keyArray := nil;          stringCache := nil;          dateCache := nil;          integerCache := nil;          myCursor := nil;       end,     ViewSetupChildrenScript:       func()       begin          numChildren := :LocalBox().bottom DIV 13 + 1;          self.stepChildren := Array(numChildren, GetLayout("protoSimpleRow"));       end,     numChildren: nil,     myCursor: nil,     viewJustify: 208,     debug: "simpleRows",     viewClass: 74    };constant |layout_SimpleRows.t| := simpleRows;// End of file SimpleRows.t// Beginning of file TappedOn.t// Before Script for "tappedOn"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.tappedOn :=    {text: "",     viewBounds: {left: 0, top: 0, right: 160, bottom: 80},     viewFormat: 83886673     ,     viewJustify: 86,     viewFlags: 2,     viewEffect: 236577,     debug: "tappedOn",     _proto: @218    };constant |layout_TappedOn.t| := tappedOn;// End of file TappedOn.t// Beginning of file True Grid.t// Before Script for "TrueGrid"// Copyright й 1994-1995 by Apple Computer, Inc.  All rights reserved.TrueGrid :=    {     gridList:       [       "None",       "Columns",       "Cached Columns",       "Draw Rows",       "Cached Draw Rows",       "Simple Rows",       ],     ViewSetupDoneScript:       func()       begin          // еее theSoup :=  call kRegisterCardSoupFunc with (kSoupName, kSoupIndexes, kAppSymbol, kAppObject);          // theCursor := Query(theSoup, {type: 'index, indexPath: 'aString});          theSoup := RegUnionSoup(kAppSymbol, kMySoupDef); // еее          theCursor := theSoup:Query({type: 'index, indexPath: 'aString});                 viewsList := [columns, cachedColumns, drawRows, cachedDrawRows, simpleRows];              	// еее╩WHY gc() and stats()???          gc();          baseMemory := stats();          :SoupChanged(kSoupName);       end,     viewFormat: nil,     theSoup: nil,     ViewQuitScript:       func()       begin       	UnRegUnionSoup(kSoupName, kAppSymbol); // еее       	theCursor := nil;       	theSoup := nil;       	viewsList := nil;       	theGrid := nil;       end,     baseMemory: nil,     viewFlags: 7,     viewsLIst: nil,     ReorientToScreen: ROM_defRotateFunc,     viewBounds: {left: 0, top: 0, right: 240, bottom: 336},     FillSoup:       func(theSoup, items)       begin          local i;          for i := 1 to items do             theSoup:AddToDefaultStore({                aString: GetRandomWord(5,20) & $- & GetRandomWord(5,20),                anInteger: Random(0,10000),                aDate: Time() + Random(-14400,14400),                pad: SetLength(SetClass(Clone(""), 'binary), kSoupPad),             });       end,     theCursor: nil,     DestroySoup:       func()       begin          local store, mySoup;                 // remove the soup from each store currently installed          foreach store in GetStores() do             if mySoup := store:GetSoup(soupName) then                mySoup:RemoveFromStore();       end,     ViewScrollDownScript:       func()       begin          if theGrid then begin       		local t1 := ticks();       		theGrid:viewScrollDownScript();       		local t2 := ticks();        		RefreshViews();       		local t3 := ticks();       		SetValue(theTimeDisplay, 'text, "Scrolling took " & t2-t1 & "+" & t3-t2 & "=" & t3-t1 & " ticks.");       		gc();       		SetValue(theMemoryDisplay, 'text, "Using " & baseMemory-stats() & " bytes.");       	end;       	else       		:SysBeep();       end ,     title: "True Grid",     ViewScrollUpScript:       func()       begin          if theGrid then begin       		local t1 := ticks();       		theGrid:viewScrollUpScript();       		local t2 := ticks();        		RefreshViews();       		local t3 := ticks();       		SetValue(theTimeDisplay, 'text, "Scrolling took " & t2-t1 & "+" & t3-t2 & "=" & t3-t1 & " ticks.");       		gc();       		SetValue(theMemoryDisplay, 'text, "Using " & baseMemory-stats() & " bytes.");       	end       	else       		:SysBeep();       end,     EmptySoup:       func(theSoup, items)       begin          local c := theSoup:Query({type: 'index}); // еее          for i := 1 to items do begin             if c:Entry() then EntryRemoveFromSoup(c:Entry());       	    	c:Next();       	  end;       end,     declareSelf: 'base,     ViewSetupFormScript:       func()       begin       	viewBounds := GetAppParams().appAreaBounds; // еее╩fill full scren now       end,     theGrid: nil,     viewClass: 74,     debug: "TrueGrid",     SoupChanged:       func(theSoupName)       begin       	theCursor:Reset();       	local l := Length(MapCursor(theCursor, func(x) true));       	SetValue(theCountDisplay, 'text, l && "soup entries");       	RefreshViews();       	local t1 := ticks();       	theGrid:?soupChanged(theSoupName);       	RefreshViews();       	local t2 := ticks();        	RefreshViews();       	local t3 := ticks();       	SetValue(theTimeDisplay, 'text, "Updating took " & t2-t1 & "+" & t3-t2 & "=" & t3-t1 & " ticks.");       	gc();       	SetValue(theMemoryDisplay, 'text, "Using " & baseMemory-stats() & " bytes.");       end,     EntrySelected:       func(entry)       begin          SetValue(tappedOn, 'text, "Tapped On: " & if entry then entry.aString else "<none>");          tappedOn:Open();          RefreshViews();          sleep(60);          tappedOn:Close();       end    };theTitle := {title: "True Grid", debug: "theTitle", _proto: @229};AddStepForm(TrueGrid, theTitle);StepDeclare(TrueGrid, theTitle, 'theTitle);_view000 :=    {     menuLeftButtons:       // еее new...       [{_proto: protoPopupButton,        text: "  Choose",        popup: nil,        selected: 0, // initially select the first item        buttonClickScript: func()        	begin       		popup := Clone(gridList);       		popup[selected] := {item: popup[selected], mark: kCheckMarkChar}; 	       		inherited:?buttonClickScript(); // set up the picker and display it        	end,        pickActionScript: func(item)       	begin       		// maintain state for the checkmark in the pick list       		selected := item ;       		       		if item = 0 then begin       			theTitle:Close();       			SetValue(theTitle, 'title, kAppName); // еее uses constant now...       			theTitle:Open();       			theGrid:?Close();       		end;       		else if item <= length(viewsList) then begin       			theGrid:?Close();       			theTitle:Close();       			SetValue(theTitle, 'title, kAppName & "-" & gridList[item]); // еее name before it...       			theTitle:Open();       			RefreshViews();       	       			gc();       			baseMemory := stats();       			theGrid := viewsList[item-1];       			       			local t1 := ticks();       			theGrid:Open();       			local t2 := ticks();       			RefreshViews();       			local t3 := ticks();       			SetValue(theTimeDisplay, 'text, "Opening took " & t2-t1 & "+" & t3-t2 & "=" & t3-t1 & " ticks.");       			       			gc();       			SetValue(theMemoryDisplay, 'text, "Using " & baseMemory-stats() & " bytes.");       		end;       	       	inherited:?pickActionScript(item);       	end,       }],     menuRightButtons:       //еее new...       [{       	_proto: protoPopupButton,       	text: "  Add",       	popup: kNumbersList,       	pickActionScript: func(item)       		begin       			:FillSoup(theSoup, kNumbersArray[item]);       			:SoupChanged(kSoupName);       			inherited:?pickActionScript(item);       		end       },       {       	_proto: protoPopupButton,       	text: "  Remove",       	popup: kNumbersList,       	pickActionScript: func(item)       		begin       			:EmptySoup(theSoup, kNumbersArray[item]);       			:SoupChanged(kSoupName);       			inherited:?pickActionScript(item);       		end       }],     _proto: @401    };AddStepForm(TrueGrid, _view000);theTimeDisplay :=    {text: "timing",     viewBounds: {left: 0, top: 18, right: 186, bottom: 30},     viewJustify: 8388626,     debug: "theTimeDisplay",     _proto: @218    };AddStepForm(TrueGrid, theTimeDisplay);StepDeclare(TrueGrid, theTimeDisplay, 'theTimeDisplay);theMemoryDisplay :=    {text: "Tapped On: <none>",     viewBounds: {left: 0, top: 0, right: 186, bottom: 12},     viewJustify: 8396818     ,     debug: "theMemoryDisplay",     _proto: @218    };AddStepForm(TrueGrid, theMemoryDisplay);StepDeclare(TrueGrid, theMemoryDisplay, 'theMemoryDisplay);theCountDisplay :=    {text: "Static Text",     viewBounds: {left: 0, top: 0, right: 186, bottom: 12},     viewJustify: 8396818     ,     debug: "theCountDisplay",     _proto: @218    };AddStepForm(TrueGrid, theCountDisplay);StepDeclare(TrueGrid, theCountDisplay, 'theCountDisplay);columns := LinkedSubview(columns,    {viewBounds: {left: 8, top: 64, right: 224, bottom: 96}, debug: "columns"})    ;AddStepForm(TrueGrid, columns);StepDeclare(TrueGrid, columns, 'columns);cachedColumns := LinkedSubview(cachedColumns,    {viewBounds: {left: 8, top: 96, right: 224, bottom: 128},     debug: "cachedColumns"    });AddStepForm(TrueGrid, cachedColumns);StepDeclare(TrueGrid, cachedColumns, 'cachedColumns);drawRows := LinkedSubview(drawRows,    {viewBounds: {left: 8, top: 128, right: 224, bottom: 160}, debug: "drawRows"    });AddStepForm(TrueGrid, drawRows);StepDeclare(TrueGrid, drawRows, 'drawRows);cachedDrawRows := LinkedSubview(cachedDrawRows,    {viewBounds: {left: 8, top: 160, right: 224, bottom: 192},     debug: "cachedDrawRows"    });AddStepForm(TrueGrid, cachedDrawRows);StepDeclare(TrueGrid, cachedDrawRows, 'cachedDrawRows);simpleRows := LinkedSubview(simpleRows,    {viewBounds: {left: 8, top: 192, right: 224, bottom: 224},     debug: "simpleRows"    });AddStepForm(TrueGrid, simpleRows);StepDeclare(TrueGrid, simpleRows, 'simpleRows);tappedOn := LinkedSubview(tappedOn,    {viewBounds: {left: 8, top: 256, right: 224, bottom: 288}, debug: "tappedOn"    });AddStepForm(TrueGrid, tappedOn);StepDeclare(TrueGrid, tappedOn, 'tappedOn);constant |layout_True Grid.t| := TrueGrid;// End of file True Grid.t
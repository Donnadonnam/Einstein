<HTML><HEAD><TITLE>Newton 2.x Q&amp;A Category: Newton ToolKit</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><img src="pictures/newtninc.gif" HEIGHT=42 WIDTH=187 BORDER=0><H2>Newton 2.x Q&amp;A Category: Newton ToolKit</H2><H4>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H2><A HREF="newtonto.htm">Newton ToolKit</H2></A><UL><A HREF="#NTK,_Picture_Slots_and_ROM_PICTs"><B> </B>NTK, Picture Slots and ROM PICTs  (12/19/93)<BR></A><A HREF="#Recognition_Problems_with_the_Inspector_Window_Open"><B> </B>Recognition Problems with the Inspector Window Open  (3/8/94)<BR></A><A HREF="#Accessing_Views_Between_Layout_Windows"><B> </B>Accessing Views Between Layout Windows  (6/7/94)<BR></A><A HREF="#Dangers_of_StrCompare,_StrEqual_at_Compile_Time"><B> </B>Dangers of StrCompare, StrEqual at Compile Time  (6/9/94)<BR></A><A HREF="#Profiler_and_Frames_of_Functions"><B> </B>Profiler and Frames of Functions  (7/10/95)<BR></A><A HREF="#NTK_1_6_Heap/Partition_Memory_Issues"><B> </B>NTK 1.6 Heap/Partition Memory Issues  (11/24/95)<BR></A><A HREF="#NTK_Search_and_Memory_Hoarding"><B> </B>NTK Search and Memory Hoarding  (11/24/95)<BR></A><A HREF="#NTK_Stack_Overflow_During_Compilation"><B> </B>NTK Stack Overflow During Compilation  (11/24/95)<BR></A><A HREF="#Unit_Import/Export_and_Interpackage_References"><B> </B>Unit Import/Export and Interpackage References  (11/25/95)<BR></A><A HREF="#Store_parts_and_PowerPC-native_NTK"><B> </B>Store parts and PowerPC-native NTK  (5/15/96)<BR></A><A HREF="#Using_Strings_as_Hex_Data_and_Windows_NTK"><B>CHANGED: </B>Using Strings as Hex Data and Windows NTK  (7/18/97)<BR></A></UL><A NAME="NTK,_Picture_Slots_and_ROM_PICTs"><H3><HR><B> </B>NTK, Picture Slots and ROM PICTs  (12/19/93)</A></H3><DL><DD>Q:    How can I use a PICT in ROM from a picture slot editor in NTK?<BR><BR>A:    You must use an NTK <CODE>AfterScript </CODE>to set the appropriate slot in the view to point to the ROM based PICT (assuming that the constant for the PICT is defined in the NTK definitions file AND documented in the Newton Programmers Guide). Use something like this in the <CODE>AfterScript</CODE>:<BR><CODE><PRE>thisView.icon := ROM_RouteDeleteIcon;</CODE></PRE></DL><A NAME="Recognition_Problems_with_the_Inspector_Window_Open"><H3><HR><B> </B>Recognition Problems with the Inspector Window Open  (3/8/94)</A></H3><DL><DD>Q:    When I have the Inspector window open in NTK and I debug my application, recognition does not work properly and the Newton complains about lack of memory. However, when I disconnect the Inspector, recognition works fine. What is going on?<BR><BR>A:    The NTK inspector window uses system memory on the Newton side; the Toolkit App itself makes use of MNP (a compression and error correction protocol) in the Newton, which uses a buffer shared with the recognition working memory.  <BR><BR>    Different releases of the Newton OS have different amounts of memory allocated for this shared area, so the problem may not be apparent on some units.  However, if this happens you have several options:<BR>    &#149; Disconnect the Inspector when testing the recognition side.<BR>    &#149; Use the keyboard for text input while testing the code.<BR>    &#149; Write shorter text items.<BR></DL><A NAME="Accessing_Views_Between_Layout_Windows"><H3><HR><B> </B>Accessing Views Between Layout Windows  (6/7/94)</A></H3><DL><DD>Q:    I have problems setting a <CODE>protoStaticText </CODE>text slot that is in one linked layout window from a button that is in another linked layout window. I tried to allow access to the base view from both linked layouts, but this didn't help. I even tried to allow access from the base view to both layouts, but this didn't help, either. What should I do?<BR><BR>A:    There is no way to declare views across the artifical boundary imposed by the linked layouts.  Until this feature of NTK is implemented, you must either create the link yourself at run time, or declare the button to the top level of the linked layout, and then declare the link.<BR><BR>    For example, consider a view called <CODE>textThatChanges</CODE> which a child of a view called <CODE>changingContainer</CODE> and is declared to <CODE>changingContainer</CODE> with the name <CODE>textThatChanges</CODE>. <CODE>ChangingContainer</CODE> is the base view for a layout which is linked into the main layout, and the link (in the main layout) is declared as <CODE>changingContainerLink</CODE>.  Code in the main layout can change the text of the <CODE>textThatChange</CODE> view like so:<BR><CODE><PRE>    SetValue(containerLink.whatToDo, 'text, "Turn and face the...")</PRE><BR></CODE><BR>    To do the equivalent of the declare yourself:<BR><BR>    1)      In the <CODE>viewSetupFormScript </CODE>script of the <CODE>'buttonThatChanges </CODE>button, set the value of the base view's slot <CODE>'theTextView </CODE>to <CODE>self</CODE>, as in the following code fragment:<BR><CODE><PRE>    func()    begin           base.theTextView := self;    end</PRE><BR></CODE>    2)     In the <CODE>buttonClickScript </CODE>script of the <CODE>'buttonThatSetsText </CODE>button, use the global function <CODE>SetValue </CODE>to store new text in the text slot of the <CODE>'buttonThatChanges </CODE>button, as in the following code fragment:<BR><BR><CODE><PRE>    func()    begin       SetValue(base.theTextView, 'text, "Now something happened!");    end</PRE><BR></CODE>    Note that this example assumes the self-declared view called <CODE>base</CODE>. In your application, you may access your base view in a different way.</DL><A NAME="Dangers_of_StrCompare,_StrEqual_at_Compile_Time"><H3><HR><B> </B>Dangers of StrCompare, StrEqual at Compile Time  (6/9/94)</A></H3><DL><DD>Q:    I've noticed that <CODE>StrCompare </CODE>can return different results at compile time than it does at run time.  What gives?<BR><BR>A:    While most functions documented in the NewtonScript Reference are available at run time and at compile time (within the NTK environment), some functions have different behaviors.<BR><BR>    In this case, the sort order for strings within the NTK NewtonScript environment is different from the ordering used on the Newton (and different from other commonly used desktop machine sort orders.)  The differences are only apparent if you use characters outside the ASCII range, for instance, accented characters.<BR><BR>    If it is necessary to pre-sort accented strings at compile time, you can write your own function that will return the same results as <CODE>StrCompare </CODE>on an given Newton unit.  Here is one such function for English releases of the Newton OS (which assumes strings using only page 0 of the unicode table):<BR><BR><CODE><PRE>constant kNSortTable := '[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24, 25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46, 47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68, 69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90, 91,92,93,94,95,96,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80, 81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106, 107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122, 123,124,125,126,127,128,129,130,131,132,133,161,157,135,136,165, 149,138,137,143,141,152,159,158,144,140,170,134,146,147,148,142, 150,138,168,171,151,153,160,153,154,155,156,174,174,174,174,65, 65,145,67,175,69,175,175,176,176,176,176,162,78,177,177,177,79, 79,164,79,178,178,178,85,166,167,139,65,65,65,65,65,65,145,67,69, 69,69,69,73,73,73,73,169,78,79,79,79,79,79,163,79,85,85,85,85,172, 173,89];// function to compare strings (only page 0 characters)// with the same order as the Newton ROM does.DefConst('kNewtonStrCompare, func(s1, s2)    begin        local l1 := StrLen(s1);        local l2 := StrLen(s2);        local l := Min(l1, l2);        local i := 0;        while i &lt; l and            (r := kNSortTable[ord(s1[i])] - kNSortTable[ord(s2[i])]) = 0  do                i := i + 1;        if i = l then            l1-l2        else            r;    end); </PRE><BR></CODE>    Note that just because you might find a particular function to be defined at compile time, do not assume that it behaves in exactly the same way as the like-named run-time function, unless the documentation explicitly says it does.  (And, of course, it might not always be defined in the compile-time environment of future NTK products if it isn't documented that way.)</DL><A NAME="Profiler_and_Frames_of_Functions"><H3><HR><B> </B>Profiler and Frames of Functions  (7/10/95)</A></H3><DL><DD>Q:    Using the profiler with a large frame of functions gives confusing results.  The profiler labels each function by the name of the frame and a number, but the numbers don't seem to correspond to the order in which I defined the functions.  Moving the functions around doesn't change the profiler labels.  How can I figure out which function is which?<BR><BR>A:    If frames have less than than a certain number of slots (20 in the current release), the slots are kept in the order they were defined or added.  If there are more than 20 slots in the frame, the slots are reordered.  (This improves slot lookup operations.)  The profiler in NTK 1.5 and NTK 1.6labels the functions by their position in the final, possibly reordered, frame.<BR><BR>    To determine which function is in which position, you need to look at the frame after the reordering has occurred.  You can do this by printing the frame after it's been defined.  At compile time you can use a print statement in the slot editor or afterScript.  After the package has been downloaded you can use the inspector.  Then count (starting from one) through the slots to find your function.<BR><BR>    Here's a little inspector snippet that will print the slots in a frame in order with their numbers:<BR><CODE><PRE>    call func(theFrame) begin        local i := 0;        foreach slot, value in theFrame do begin            print(i && ': && slot);            i := i + 1;        end    end with (&lt;the reordered frame&gt;)</PRE><BR></CODE><BR></DL><A NAME="NTK_1_6_Heap/Partition_Memory_Issues"><H3><HR><B> </B>NTK 1.6 Heap/Partition Memory Issues  (11/24/95)</A></H3><DL><DD>Q:    How do I set the build heap, main heap, and MacOS multifinder partition sizes in NTK 1.6 so I can build my package without running out of memory?<BR><BR>A:    Here is an explanation of how Mac NTK makes uses of the various heaps.  Understanding this will allow you to set your sizes for optimal performance.  The same concepts apply to the Windows NTK, except for the sections talking about MacOS multifinder partitions.<BR><BR><B>    Main Heap<BR><BR></B>    The Main heap holds your frame data while you're working in NTK.  Its size is set through the Toolkit Preference dialog. You must quit and restart NTK for changes to take effect.<BR><BR>    The Main heap is allocated when NTK starts up.  It is not disposed off until you quit NTK. If NTK can't allocate the Main heap it reports the problem and quits. As a result, if you can start NTK, Main heap allocation has completed.<BR><BR>    We have no rule of thumb for setting the Main heap size. You need to experiment keeping the following in mind: <BR><BR>    1) If the Main heap is insufficient, NTK will tell you so. <BR>    2) Reducing the Main heap size reduces overall RAM requirements.<BR>    3) The Main heap is garbage collected (GC).  Increasing its size may improve performance by reducing GC activity.   This will affect build time, and to a lesser degree the time it takes to open a project.  Please note that the gains in build time are nonlinear and quickly reach a plateau, as shown in the following example:<BR>    <BR>            <CODE><PRE>            Main        Build time    heap size        (+/- 0.5 sec)        1250K            Main heap ran out of memory...        1275K            32.7 sec        1300K            26.4 sec        1400K            22.3 sec        1500K            19.2 sec        1600K            17.5 sec        2000K            16.0 sec        3000K            15.2 sec</PRE><BR></CODE><BR>    Experiment with Main heap size by measuring build time until you find a reasonable compromise between build time and memory requirements for your particular project.<BR><BR>    If you are curious about GC activity, do the following:<BR><BR>    1) Add the following line to your <CODE>GlobalData </CODE>file (in the NTK folder) and restart NTK:<BR><CODE><PRE>    protoEditor:DefineKey({key: 65}, 'EvaluateSelection);</PRE><BR></CODE>    This allows you to use the period key on the numeric keypad to evaluate selected text in the Inspector window or any text file in the NTK build-time environment.  (Normally the text is compiled by NTK and then evaluated by the Newton device when you hit the Enter key.)  See the NTK User's Guide for details on the <CODE>GlobalData</CODE> file.<BR><BR>    2) Type <CODE>VerboseGC(TRUE)</CODE> in the Inspector window, select, and hit the keypad-period key.  Each time the GC kicks in, a line will be displayed in the Inspector window.  By watching the frequency of GCs, you can get some idea of how your main heap is being used.<BR><BR>    3) Use <CODE>VerboseGC(FALSE)</CODE> to turn this feature off.   Please note that <CODE>VerboseGC </CODE>is available only in the NTK build-time environment.  The function does not exist on the Newton device itself.  It should be used only for debugging and optimization.<BR><BR><B>    Build Heap<BR><BR></B>    The Build heap holds your package frame data during the last part of the build. Its size is set through the Toolkit Preference dialog. Changes take effect immediately.<BR><BR>    The Build heap is allocated only when the Build Package command is issued. It is released as soon as the resulting file is written to disk. As a result Build heap allocation is a recurring issue.<BR><BR>    The rule of thumb is to set the Build heap to the size of your package (on the MacOS computer hard disk, not on the Newton device). If the Build heap is insufficient, NTK will tell you so. <BR><BR>    There is nothing to be gained by setting the Build heap larger than necessary. <BR><BR>    NTK first attempts to allocate the Build heap from MultiFinder memory. If that fails, NTK tries to allocate the Build heap from NTK's partition. <BR><BR>    To verify that you have enough memory for the Build heap you need to look at the "About This Macintosh" dialog in the Finder application just prior to issuing the build command. <BR><BR>    1) If the "Largest Unused Block" exceeds the Build heap requested size, the Build heap will be allocated from MultiFinder memory. <BR><BR>    2) If 1 failed and NTK's partition bar shows enough free memory to accommodate the request, the Build heap will be allocated in NTK's partition.<BR><BR>    3) If both 1 and 2 failed, the build will fail.  Try to increase MultiFinder free memory by quitting any other open application, or increase the free memory in NTK's partition by closing some or all of NTK's open windows. Then try building again.<BR><BR>    To prevent fragmentation of MultiFinder memory launch NTK first, and DocViewer, ResEdit, etc. afterwards. Whenever possible, quit those other applications in the reverse order .<BR><BR>    Note: You can use Balloon help to see how much memory an application is actually using. Simply select the Show Balloons menu item and position the cursor on the application partition bar in the About Macintosh dialog. This feature is missing from PowerPC-based MacOS computers. <BR><BR><B>    NTK Partition Size<BR><BR></B>    For NTK 1.6 the rule of thumb for the "smallest useful" partition size for small projects is:<BR>        (3500K + Main heap size) for a 680x0 MacOS computer<BR>        (5500K + Main heap size) for a PowerPC MacOS computer with Virtual Memory off.<BR><BR>    These rules do not include space for the Build heap. <BR><BR>    The "smallest useful" partition size is defined by the following example: Using NTK default Main and Build heaps, open the Checkbook sample. Open one browser and one layout window for each file in the project, connect the Inspector, build and download. Perform a global search on "Check" (case insensitive) producing slightly more than 200 matches. Double click on several of these matches displayed in the search results window. Build and download again.<BR><BR>    For serious work, increase the partition size by at least 256K for small projects, more for large ones.  If you routinely perform global searches that produces many matches, see the next section.<BR><BR>    On a PowerPC-based MacOS computer with Virtual Memory on, NTK's 2.7 Meg of code (the exact number is shown in the Finder Info dialog) stays on the hard disk, reducing memory requirements at the expense of performance.</DL><A NAME="NTK_Search_and_Memory_Hoarding"><H3><HR><B> </B>NTK Search and Memory Hoarding  (11/24/95)</A></H3><DL><DD>Q:    I sometimes run out space after working with a project for a while.  How can I avoid this?<BR><BR>A:    NTK 1.6 is built with the MacApp application framework, which brings with it certain memory requirements.  Understanding the way NTK uses memory can help avoid running out of memory.<BR><B><BR></B>    Most of user interface elements you see when using NTK are pointer-based MacApp objects. Allocating a large number of pointers in the application heap causes fragmentation. To prevent that, MacApp has its own private heap where it manages all these pointers. <BR><BR>    This heap expands when necessary, but in the current implementation it never shrinks. This memory is not lost, but it may be wasted, effectively reducing free memory in the application partition. <BR><BR>    During a single NTK session, build requirements are relatively constant. Partition size requirements will thus be mostly affected by the maximum number of NTK windows open at the same time. If you keep this number reasonable, relative to the partition size you can afford, there should be no problem.<BR><BR>    The fact that MacApp's objects heap never shrinks can, however, become an issue when performing searches. The problem is not the search itself, but the number of matches. Each line you see in the Search Results window is a MacApp object occupying 500 to  800 bytes. If your search results in a large number of matches, you may run out of memory.<BR><BR>    To reduce such occurrences:<BR>    1)    Perform more focused searches to keep the number of matches per search reasonable.<BR>    2)    Close the Search Results window as soon as you are done with it, preferably before doing another search.<BR></DL><A NAME="NTK_Stack_Overflow_During_Compilation"><H3><HR><B> </B>NTK Stack Overflow During Compilation  (11/24/95)</A></H3><DL><DD>Q:    When I build my project that has very deeply nested statements, NTK runs out of memory and quits.  What's going wrong?<BR><BR>A:    The deep nesting in your project is causing the compiler to overflow the stack space available in NTK.  NTK 1.6 is more likely than than NTK 1.5 to suffer this problem due to new compiler code which nests deeper while parsing if-then-else statements, causing the stack to overflow into the application heap.  <BR><BR>    If you see an inadvertent crash in NTK during a save operation or a package build:<BR><BR>    1)  If you are familiar with MacsBug, examine the stack.  This particular case will show up in the stack as several calls to the same function before the actual crash.<BR>    2) Otherwise, temporarily reduce the number of "else" branches and rebuild the package. If the problem disappears, stack overflow is the prime suspect.<BR><BR>    There are at least three ways to avoid this problem and possibly improve performance at the same time:<BR>    1)    Re-arrange the 'else' statements to resemble a balanced tree<BR>    2)    Instead of If-then-else statements use:<BR>         An array of functions (with integers as selectors)<BR>         A frame of functions (with symbols as selectors)<BR>    3)    Finally, as a temporary work around, you can increase the stack size using the ResEdit application.<BR><BR><B>    Re-arrange the 'else' statements to resemble a balanced tree<BR></B>    <BR>    This solution is the simplest to implement if you need to change existing code. It accommodates non-contiguous integer selectors, and in most cases is faster.<BR><BR>    For example, the following code:<BR><CODE> <PRE>   if x = 1 then        dosomething    else        if x = 2 then            doSomethingElse        else            if x = 3 then                doYetAnotherThing            else                if x = 4 then                    doOneMoreThing                else                    if x = 5 then                        doSomethingSimple                    else                        if x = 6 then                            doThatThing                        else                            if x = 7 then                                doThisThing                            else // x = 8                                doTheOtherThing</PRE><BR></CODE>    ...can be rewritten like this:<BR><BR><CODE> <PRE>   if x &lt;= 4 then        if x &lt;= 2 then            if x = 1 then                doSomething            else // x = 2                doSomethingElse        else            if x = 3 then                doYetAnotherThing            else // x = 4                doOneMoreThing    else        if x &lt;= 6 then            if x = 5 then                doSomethingSimple            else // x = 6                doThatThing        else           if x = 7 then                doThisThing           else // x = 8                doTheOtherThing;</PRE><BR></CODE>    Note that the if/then/else statement nesting is "unusual" to illustrate the nesting that the compiler must make each statement is nested as the compiler would process it.<BR><CODE><BR></CODE><BR><B>    Use an array of functions with integer selectors<BR><BR></B>    Replace a long if-then-else statement with an array of functions. The code is more compact and readable. For a large set of alternatives, the faster direct lookup should compensate for the extra function call. This approach is most useful for a contiguous range of selector values (e.g., 11 to 65). It can accommodate a few "holes" (for example, 11 to 32, 34 to 56, 58 to 65). It is not practical for non-contiguous selectors (e.g., 31, 77, 256, 1038...)<BR><BR>    For example, the following code:<BR><BR><CODE><PRE>    if x = 1 then        dosuchandsuch;    else        if x = 2 then            dosomethingelse;        else            if x = 3 then                andsoon;</PRE><BR></CODE>       ...can be rewritten like this:<BR><BR><CODE>        <PRE>        cmdArray := [func() dosuchandsuch,        func() dosomethingelse,            func() andsoon];        call cmdArray[x] with ();</PRE><BR></CODE><BR><B>    Use a frame of functions with symbols for selectors<BR></B><BR>    This alternative provides the flexibility of using symbols for selecting the outcome.<BR><BR>     For example, the following code:<BR><BR><CODE><PRE>    if x = 'foo then        dosuchandsuch;    else        if x = 'bar then            dosomethingelse;        else            if x = 'baz then                andsoon;</PRE><BR></CODE><BR>    ...can be rewritten like this:<BR><CODE><PRE>    cmdFrame := {foo: func() dosuchandsuch,                    bar: func() dosomethingelse,                    baz: func() andsoon};      call cmdFrame.(x) with ();</PRE><BR><B></CODE>    Increase NTK's stack size using the ResEdit application<BR><BR></B>    Open the Newton Toolkit application with ResEdit.<BR><BR>    Double-click on the "<CODE>mem!</CODE>" resource icon<BR><BR>    Double-click on resource ID <CODE>1000 </CODE>named "Additional NTK Memory Requirements"<BR><BR>    Change the fifth (and last) value. This is an hexadecimal number. In NTK 1.6, you should see "<CODE>0001 8000</CODE>" which is <CODE>98304</CODE> bytes (or <CODE>96k</CODE>) to add to the total stack size. For example, to increase this value to <CODE>128k</CODE> = <CODE>131072</CODE> bytes change the hexadecimal value to "<CODE>0002 0000</CODE>".<BR></DL><A NAME="Unit_Import/Export_and_Interpackage_References"><H3><HR><B> </B>Unit Import/Export and Interpackage References  (11/25/95)</A></H3><DL><DD>Q:    How can I reference information in one part or package from another (different) part or package?<BR><BR>A:    Newton 2.0 OS provides the ability for packages to share informations by exporting or importing units. Units are similar to shared libraries in other systems.<BR><BR>    A unit provides a collection of NS objects (unit members.)  Units are identified by a name, major version number, and minor version number. Any frame part can export or import zero or more units.<BR><BR>    A unit must be declared, using <CODE>DeclareUnit</CODE>, before it's used (imported or exported.) See the docs on <CODE>DeclareUnit </CODE>below for details.<BR><BR>    To export a unit, call <CODE>DefineUnit </CODE>and specify the NS objects that are exported.<BR><BR>    To import from a unit, simply reference its members using <CODE>UnitReference </CODE>(or UR for short.)<BR><BR><BR><B>    Unit Usage Notes<BR></B><BR>    &#149;    Units can also be used to share objects among parts within a single package.  This avoids the need to resort to global variables or similar undesirable techniques.<BR><BR>    &#149;    A part can export multiple units.  To achieve some degree of privacy, you can partition your objects into private and public units.  Privacy is achieved by not providing the declaration for a unit.<BR><BR>    &#149;    References to units are resolved dynamically whenever a package is activated or deactivated.  For example, a package can be loaded before the package providing the units it imports is loaded.  There will be no problem as long as the provider is loaded prior to actually using the imported members.<BR><BR>    Conversely, it's possible for the provider to be deactived while its units are in use.  The part frame methods, RemovalApproval and ImportDisabled, provide a way to deal with this situation.<BR><BR>    Robust code should ensure that the units it imports are available before attempting to use their members.  It should also gracefully handle the situation of units being removed while in use.  See the DTS sample "MooUnit" for an example.<BR><B><BR>    Unit Build-Time Functions<BR></B><BR>    These functions are available in NTK at build-time only:<BR><BR><CODE><PRE>DeclareUnit(unitName, majorVersion, minorVersion, memberIndexes)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>majorVersion </CODE>- integer - major version number of the unit<BR>        <CODE>minorVersion </CODE>- integer - minor version number of the unit<BR>        <CODE>memberIndexes </CODE>- frame - unit member name/index pairs (slot/value) <BR>        return value - unspecified<BR><CODE><BR></CODE>    A unit must be declared by <CODE>DeclareUnit </CODE>before it's used (imported or exported.) The declaration maps the member names to their indexes. A typical declaration looks like:<BR><BR><CODE><PRE>    DeclareUnit('|FastFourierTransforms:MathMagiks|, 1, 0, {        ProtoGraph:     0,        ProtoDataSet:   1,    });</PRE><BR></CODE><BR>    Typically, the declarations for a unit are provided in a file, such as "FastFourierTransforms.unit", that is added to an NTK project (similar to <CODE>.h</CODE> files in C.)<BR><BR>    When resolving imports, the name and major version specified by the importer and exporter must match exactly. The minor version does not have to match exactly. If there are units differing only in minor version, the one with the largest minor version is used.<BR><BR>    Typically, the first version of a unit will have major version 1 and minor version 0. As bug fixes releases are made, the minor version is incremented. If a major (incompatible) change is made, then the major version number is incremented.<BR><BR>    Note: When a unit is modified, the indexes of the existing members must remain the same. In other words, adding new members is safe as long as the indexes of the existing members don't change. If you change a member's index it will be incompatible with any existing clients (until they're recompiled with the new declaration.)<BR><BR><CODE><PRE>DefineUnit(unitName, members)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>members </CODE>- frame - unit member name/value pairs (slot/value)<BR>        return value - unspecified<BR>    <BR><CODE>    DefineUnit </CODE>exports a unit and specifies the value of each member. Immediates and symbols are not allowed as member values. A typical definition looks like:<BR><BR>    <CODE><PRE>    DefineUnit('|FastFourierTransforms:MathMagiks|, {    ProtoGraph:     GetLayout("foo.layout"),    ProtoDataSet:   { ... },});</PRE><BR></CODE><BR>    A unit must be declared before it's defined. The declaration used when exporting a unit with <CODE>n</CODE> members must contain <CODE>n</CODE> slots with indexes <CODE>0..n-1</CODE>. The definition must specify a value for every declared member (this is important.)<BR><BR><CODE><PRE>UnitReference(unitName, memberName)</PRE><BR></CODE>        or<BR><CODE><PRE>UR(unitName, memberName)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of a unit<BR>        <CODE>memberName </CODE>- symbol - name of a member of unit<BR>        return value - a reference to the specified member<BR><BR>    To use a unit member call <CODE>UnitReference </CODE>(<CODE>UR </CODE>for short) with the unit and member name.<BR><BR>    The unit name <CODE>'ROM</CODE> can be used to refer to obects in the base ROM. For example:<BR>    <CODE>UR('ROM, 'ProtoLabelInputLine)</CODE>.<BR><BR>    Note: references to objects in the base ROM are sometimes called "magic pointers" and have traditionally been provided in NTK by constants like <CODE>ProtoLabelInputLine </CODE>or <CODE>ROM_SystemSoupName</CODE>.<BR><BR>    In Newton 2.0 OS, there may also be packages in the ROM. These ROM packages may provide units. Their members are referenced just like any other unit, using <CODE>UR</CODE>, the unitName, and the memberName. This is the mechanism by which licensees can provide product-specific functionality.<BR><CODE><PRE>AliasUnit(alias, unitName)</PRE><BR></CODE>        <CODE>alias </CODE>- symbol - alternate name for unit<BR>        <CODE>unitName </CODE>- symbol - name of a unit<BR>        return value - unspecified<BR>    <BR><CODE>    AliasUnit </CODE>provides a way to specify an alternate name for a unit. Since unit names must be unique, they tend to be long and cumbersome. For example:<BR><CODE><PRE>    AliasUnit('FFT, '|FastFourierTransforms:MathMagiks|);</PRE><BR></CODE><BR>    ...so that you could write:<BR><CODE><PRE>    local data := UR('FFT, 'ProtoDataSet):New(points);</PRE><BR></CODE><BR>    ...instead of:<BR><CODE><PRE>    local data := UR('|FastFourierTransforms:MathMagiks|,     'ProtoDataSet):New(points);AliasUnitSubset(alias, unitName, memberNames)</PRE><BR></CODE>        <CODE>alias </CODE>- symbol - alternate name for unit<BR>        <CODE>unitName </CODE>- symbol - name of a unit<BR>        <CODE>memberNames </CODE>- array of symbols - list of unit member names<BR>        return value - unspecified<BR><BR><CODE>    AliasUnitSubset </CODE>is similar to <CODE>AliasUnit</CODE>, except that it additionally specifies a subset of the units members which can be used. This helps restrict code to using only certain members of a unit.<BR><BR><BR><B>    Unit Part Frame Methods<BR></B><BR>    These methods can optionally be defined in a part frame to handle units becoming unavailable.<BR><CODE><PRE>RemovalApproval(unitName, majorVersion, minorVersion)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>majorVersion </CODE>- integer - major version number of the unit<BR>        <CODE>minorVersion </CODE>- integer - minor version number of the unit<BR>        return value - <CODE>nil </CODE>or string<BR><BR>    This message is sent to a part frame when an imported unit is about to be deactivated. It may a return a string to be shown to the user as a warning about the consequences of deactivating the package in use. For example:<BR><BR><CODE><PRE>"This operation will cause your connection to fooWorld to be dropped."</PRE><BR></CODE><BR>    Note: do not assume that the user is removing the package. Other operations such as moving a package between stores also cause package deactivation.<BR><BR>    This message is only a warning. The user may decide to proceed and suffer the consequences. If the user proceeds, the <CODE>ImportDisabled </CODE>message (see below) will be sent.<BR><BR>    If the removing the unit is not a problem (for example, your application is closed), then<CODE> RemovalApproval </CODE>can return <CODE>nil </CODE>and the user will not be bothered.<BR><BR><CODE><PRE>ImportDisabled(unitName, majorVersion, minorVersion)</PRE><BR></CODE>        <CODE>unitName </CODE>- symbol - name of the unit<BR>        <CODE>majorVersion </CODE>- integer - major version number of the unit<BR>        <CODE>minorVersion </CODE>- integer - minor version number of the unit<BR>        return value - unspecified<BR><BR>    This message is sent to a part frame after an imported unit has been deactivated. The part should deal with the situation as gracefully as possible. For example, use alternative data or put up a Notify and/or close your application.<BR><BR><B>    Unit-Related Glue Functions<BR></B>    <BR>    These functions are available in the Newton 2.0 Platform file.<BR>                <BR><CODE><PRE>MissingImports(pkgRef)</PRE><BR></CODE>        return value - <CODE>nil </CODE>or an array of frames (see below)<BR>        glue name - <CODE>kMissingImportsFunc<BR></CODE>    <BR><CODE>    MissingImports </CODE>lists the units used by the specified package that are not currently available. <CODE>  MissingImports </CODE>returns either nil, indicating there are no missing units, or an an array of frames of the form:<BR><CODE><PRE>    {        name: symbol  - name of unit desired        major: integer - major version number        minor: integer - minor version number        &lt;other slots undocumented&gt;    }</CODE></PRE></DL><A NAME="Store_parts_and_PowerPC-native_NTK"><H3><HR><B> </B>Store parts and PowerPC-native NTK  (5/15/96)</A></H3><DL><DD>Q:    When I build a store part with NTK 1.6 or 1.6.2 on my PowerPC MacOS computer, text searches (for example<CODE> mySoup:Query({words: "pizza"}</CODE>) don't sucessfully find the entries.  Why?<BR><BR>A:    On PowerPC MacOS computers only, there is a bug in 1.6 and 1.6.2 wherein building store parts will cause this behavior.  The workaround is building the store part on a 680x0-based MacOS computer.<BR><BR>    If you don't have a 680x0 machine available, you might try any of various third-party applications which remove the PowerPC-native code from an application which contains 680x0 code and PowerPC code, thus forcing it to run the 680x0 code instead.  Before doing this, be sure to backup your copy of NTK!</DL><A NAME="Using_Strings_as_Hex_Data_and_Windows_NTK"><H3><HR><B>CHANGED: </B>Using Strings as Hex Data and Windows NTK  (7/18/97)</A></H3><DL><DD>Q:    When I use <CODE>SetClass(SetLength("\u&lt;hex data&gt;"), theLength), theClass)</CODE> in Windows NTK , the binary object is not what I expect.  It seems to be byte-swapped.  How can I create binary objects with data in them in Windows NTK?<BR><BR>A:    In Windows NTK (and other Windows NS environments), strings are stored in byte swapped order, that is, low byte first.  This is because strings are basically arrays of 16-bit Unicode characters, and on the Intel platform 16-bit values are most usefully stored low byte first.  Technically, changing the class and length of a string relies on the internal representation of strings, which isn't documented or supported, though it works fine on Newton OS and Mac OS platforms.<BR><BR>    The correct way to create binary objects is to use the new <CODE>MakeBinaryFromHex()</CODE> function; it handles the byte-swapping issues properly.  This function is defined by the platform file, and only runs at build-time -- it doesn't exist on the Newton device.  You may need to get a newer platform file because this function was added after Windows NTK 1.6 shipped.</DL>
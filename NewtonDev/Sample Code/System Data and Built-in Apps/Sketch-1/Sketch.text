// Text of project Sketch written on 9/24/97 at 1:37 PM// Beginning of text file Project Constants/***      Newton Developer Technical Support Sample Code****      Sketch, A Newton Works stationery sample****      by Henry Cate and Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/// ----------------------------------------------//           	Project Symbols// ----------------------------------------------constant kDefSymbol 					:= '|Sketch:DTS|;constant kSuperSymbol				:= 'newtWorks;constant kStationerySymbol			:= 'default;constant kFrameFormatSymbol		:= 'SketchFrameFormat;constant kPrintFormatSymbol		:= 'SketchPrintFormat;constant kSampleToolSymbol			:= '|SketchBeepTool:DTS|;// ----------------------------------------------//           	Soup Entry Contants// ----------------------------------------------constant kEntryContentsSymbol		:= 'contents;constant kEntryTitleSymbol			:= 'title;DefineGlobalConstant( 'kEntryTemplate,		{		class: 		kDefSymbol,		contents: 	[],	} );// ----------------------------------------------//           		Preference Contants// ----------------------------------------------constant kGenericPrefSymbol		:= 'enableSomething;constant kPrefsTemplate 			:= '{enableSomething: nil};// ----------------------------------------------//           	Project Strings// ----------------------------------------------constant kViewDefName				:= "Full Sketch";constant kStationeryName			:= "Sketch";constant kDataDescription 			:= "Sketch Data Description";constant kPrefsString				:= "Sketch Prefs";constant kToolsButtonText			:= "Tools";constant kUntitledItemString		:= "Untitled Sketch";constant kGenericPrefString		:= "Enable something";constant kFrameFormatString		:= "Sketch Frame Format";constant kPrintFormatString		:= "Sketch Print Format";// ----------------------------------------------//           	Other Constants// ----------------------------------------------constant kToolsButtonItems	:= '[{keyMessage: NewtWorksFind},								 			{keyMessage: NewtWorksFindAgain}];								 			DefineGlobalConstant( 'kSketchFrameFormat, 	{		_proto: 		protoFrameFormat,		symbol: 		kFrameFormatSymbol,		title: 		kFrameFormatString,	});// End of text file Project Constants// Beginning of file Sketch Prefs.lyt// Before Script for "_view000"/***      Newton Developer Technical Support Sample Code****      Sketch, A Newton Works stationery sample****      by Henry Cate and Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/_view000 :=    {viewBounds: {left: 0, top: 0, right: 180, bottom: 68},     viewJustify: 80,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	// Grab the Newton Works preferences frame.       	prefsFrame := newtAppBase:GetAppPreferences();       	       	// This slot is set in the SetPreferenceItem method and is used       	// in the viewQuitScript.       	prefsChanged := nil;       	        	// Our preferences are stored  in a sub-frame so we don't step        	// on any of Newton Works prefs.       	if NOT HasSlot( prefsFrame, kDefSymbol ) then       		prefsFrame.(kDefSymbol) := Clone( kPrefsTemplate );              	inherited:?ViewSetupFormScript();       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	// Be sure to change the preferences if they have changed       	if prefsChanged then       		EntryChangeXmit( prefsFrame, kAppSymbol );       	       	inherited:?ViewQuitScript();       end,     prefsFrame: nil,     declareSelf: 'base,     GetPreferenceItem:       func( slotSymbol )       begin       	// Return the appropriate slot from the sub-frame       	prefsFrame.(kDefSymbol).(slotSymbol);       end,     SetPreferenceItem:       func( slotSymbol, value )       begin       	// Set the appropriate slot in the application sub-frame       	prefsFrame.(kDefSymbol).(slotSymbol) := value;       	       	// Set the prefsChanged flag       	prefsChanged := true;       end,     PrefsChanged: nil,     _proto: @179    };_view001 :=    {title: kPrefsString,     viewBounds: {left: 0, top: 0, right: 78, bottom: 16},     _proto: @229    };AddStepForm(_view000, _view001);_view002 :=    {text: kGenericPrefString,     viewBounds: {left: 10, top: 10, right: -10, bottom: 26},     viewJustify: 8244,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	// Set the initial value based on the saved preference       	self.viewValue := :GetPreferenceItem( kGenericPrefSymbol );       	       	inherited:?ViewSetupFormScript();       end,     valueChanged:       func()       begin       	// Store the new value       	:SetPreferenceItem( kGenericPrefSymbol, self.viewValue );       end,     _proto: @164    };AddStepForm(_view000, _view002);_view003 :=    {     buttonClickScript:       func()       begin       	// This is necessary for Newton Works to function properly.       	newtAppBase:RememberedClose( base );       end,     _proto: @166    };AddStepForm(_view000, _view003);constant |layout_Sketch Prefs.lyt| := _view000;// End of file Sketch Prefs.lyt// Beginning of file Sketch DataDef// Before Script for "_view004"/***      Newton Developer Technical Support Sample Code****      Sketch, A Newton Works stationery sample****      by Henry Cate and Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/_view004 :=    {symbol: kDefSymbol,     name:       kStationeryName	// Shows up in "New" button.       ,     description:       kDataDescription	// shows up in "info" slip when you tap in entry header       ,     icon: GetPictAsBits("SmallIcon", 1),     superSymbol: kSuperSymbol,     StringExtract:       // Called by overview to get a text description of the data.       func(item, numLines)       begin       	// return the title of the item.       	item.(kEntryTitleSymbol);       end,     TextScript:       // used by text transports (for example, email) to get a text version of the entire entry       // differs from StringExtract in that this returns the whole thing as text.       func(item, target)       begin       	// print the title, a return, then the text of the item       	target.(kEntryTitleSymbol) & "\n" & NotesText( target.(kDefSymbol).(kEntryContentsSymbol) );       end,     version: 1,     FillNewEntry:       // takes a new entry "shell" and fills it with class-specific data       // We recommend that the data-def specific data be kept in a sub-frame in the       // entry.  (This provides a nice abstraction layer which may come in handy when       // using the dataDef with other applications, or updating generic data.)       func(theNewEntry)       begin       	// Fill in the data frame and tht title       	theNewEntry.(kDefSymbol) := Clone( kEntryTemplate );       	theNewEntry.(kEntryTitleSymbol) := kUntitledItemString;       	       	// return the new entry       	theNewEntry;       end,     MakeNewEntry:       // If the newtApp opening this has no CreateBlankEntry method for the newtSoup,       // then this method will be called.  So create a "minimal" soup entry for the       // otherwise-generic application.  (Just use FillNewEntry on an empty frame...)       func()        begin       	:FillNewEntry({});       end;,     FindFn:       // Called by Newton Works when a global (Newton-wide) Find is        // performed, and a search using the function FindStringInFrame        // finds nothing in a Newton Works soup entry.       func(entry, what, offset)       begin       	if kDebugOn then       		print("In the dataDef's FindFn method");              	// We don't need to do anything here because       	// FindStringInFrame will find all text within       	// the edit view's viewChildren.       	       	nil;       end,     FindSoupExcerpt:       // This method is used by the Newton's global find mechanism.       func( entry, finder )       begin       	// return the title       	entry.(kEntryTitleSymbol);       end,     InfoBoxExtract:       func( target, boxInfo, viewDefView )       begin       	if kDebugOn then       		print("In the dataDef's InfoBoxExtract method");       		       	// InfoBoxExtract must return an array of shapes.  For our sample we just       	// return a text shape indicating the number of children in the viewDef's       	// edit view.       	local numChildren := Length( target.(kDefSymbol).(kEntryContentsSymbol) );       	local numChildrenString := ParamStr( "This edit view has ^0 ^?1^2|^3|.", [numChildren, numChildren=1, "Child", "Children"] );       		       	[MakeText( numChildrenString, boxInfo.left, boxinfo.top, boxinfo.right, boxInfo.bottom )];       end,     prefs:       {       	item:					kPrefsString,       	prefsTemplate:		GetLayout("Sketch Prefs.lyt"),       },     _proto: @451    };constant |layout_Sketch DataDef| := _view004;// End of file Sketch DataDef// Beginning of file Sketch ViewDef.lyt// Before Script for "sketchBaseView"/***      Newton Developer Technical Support Sample Code****      Sketch, A Newton Works stationery sample****      by Henry Cate and Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/sketchBaseView :=    {viewWidth: nil,     type:       'editor		// 'viewer and 'editor are standards, but you can extend the types       ,     viewSetupDoneScript:       func()       begin       	// Initialize the toolKeyCommands array.  This array is       	// manipulated in the AddToolKeyCommand and RemoveToolKeyCommand       	// methods.       	self.toolKeyCommands := [];       	       	// Add all the key commands for the registered tools       	local theTools := :GetNewtWorksTools( kDefSymbol );       	foreach tool in theTools do       		:AddToolKeyCommand( tool );       	       	// We must call UpdateAllScrollers from here.  This       	// lets Newton Works update the scrollers appropriately.       	:UpdateAllScrollers(self, true, nil, true, nil);       	       	SetKeyView( self, nil );       end,     viewFormat: 1,     Scroll:       func( scrollInfo )       begin       	if kDebugOn then       		print("In the viewDef's Scroll method");              	// calculate the proper x and y origin coordinates       	local newX := Min( sketchEditView.viewWidth - self.viewWidth,       						Max(0, viewOriginX + scrollInfo.x));       	local newY := Min( sketchEditView.viewHeight - self.viewHeight,       						Max( 0, viewOriginY + scrollInfo.y ));       	       	// Set the origin to the new x and y       	:SetOrigin( newX, newY );       	       	// Make it "live".  If this is too much of a performance hit then       	// remove the call to RefreshViews       	RefreshViews();       	       	// Be sure that we let the scrollers update themselves.  Since the height       	// and width of our sketch view doesn't change, we only need to pass in       	// the vChanged and hChanged parameters.       	:UpdateAllScrollers( self, nil, scrollInfo.y <> 0, nil, scrollInfo.x <> 0 );       end,     PrefsChanged:       // Called conditionally when the global preferences for Newton Works are changed.       // We don't do anything here because we don't care about the global prefs       func(prefsFrame)       begin       	if kDebugOn then       		print("In the viewDef's PrefsChanged method");       		       	// 'metricUnits: true for metric, nil for sae       	// 'internalStore: true for internal only, nil for default store       end,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin       	// Remove all the key commands for the registered tools       	local theTools := :GetNewtWorksTools( kDefSymbol );       	foreach tool in theTools do       		:RemoveToolKeyCommand( tool.symbol );       		       	// Remove all the key commands that were registered       	:ClearKeyCommands();       	       	inherited:?ViewQuitScript();       end,     viewHeight: nil,     viewFlags: 33,     GetScrollValues:       // This method returns the current scroll       // offsets.  It is used by the scroll bars.       func()       begin       	if kDebugOn then       		print("In the viewDef's GetTotalHeight method");       	       	// Return the current scroll offsets       	{x: viewOriginX, y: viewOriginY};       end;,     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     statusLeftButtons:       [       	{       		_proto: protoRecToggle,       		_recogSettings: nil,       		RecogSettingsChanged: func( theFlags )       			begin       				// Since we do not own the Newton Works base view, we must       				// hand set the _recogSettings slot in the viewDefView.       				// We must do this from a deferred call because of a bug in       				// protoRecToggle.  Unfortunately, protoRecToggle does not update       				// the _recogSettings slot until _after_ the call to       				// RecogSettingsChanged.       				AddDeferredCall( 	func(theRecToggle, viewDefView)       										begin       											viewDefView._recogSettings := theRecToggle._recogSettings;       										end, [self, viewDefView] );       				       				// Be sure to let protoRecToggle do its own processing       				inherited:?RecogSettingsChanged( theFlags );       			end,       	},       	{       		_proto:	protoPopupButton,       		popup:	kToolsButtonItems,       		text:	kToolsButtonText,       		alwaysCallPickActionScript:	nil,       		buttonClickScript: func()       			begin       				self.popup := Clone( kToolsButtonItems );       				       				// Get the tools that have been registered for this stationery       				local theTools := :GetNewtWorksTools( kDefSymbol );       				       				if Length( theTools ) > 0 then       					begin       						// Add the separator       						AddArraySlot( self.popup, 'pickSeparator );       												       						// Add a popup frame for each of the tools.  If       						// the tool has a key command, then just add the       						// keyMessage slot and let the OS do the rest.       						// If the tool does not have a key command, then just       						// add the tool frame to the popup list.       						foreach tool in theTools do       							begin       								if tool.keyCommand then       									AddArraySlot( self.popup, {keyMessage: tool.keyCommand.keyMessage} );       								else       									AddArraySlot( self.popup, tool );       							end;										       					end;              				inherited:?buttonClickScript();       			end,       		pickActionScript: func( index )       			begin       				// Note that the pickActionScript will only be called for tools       				// without key commands.  If a tool has a key command, the KeyFn       				// method will be called instead.  This behavior is defined because       				// the alwaysCallPickActionScript flag is not set.       				       				// Grab the tool that we are manipulating       				local theTool := popup[index];              				// Make sure there is a viewDefView before trying to execute the       				// command.       				if viewDefView AND theTool.cmdFunc then       					theTool:CmdFunc( viewDefView, newtAppBase );       					       				inherited:?pickActionScript( index );       			end,       	},       ],     _recogSettings: nil,     FindChange:       // Called when the user performs a Find operation from Newton Works Find/ Change slip.       // Only change all is implemented below.  In a real application you would want to       // implement find, change, and change all.       func(action, data)       begin       	if kDebugOn then       		print("In the viewDef's FindChange method");              	if action = 'find then       		begin       			// Perform a find from here       		end;       	else if action = 'change then       		begin       			// Perform a change from here       		end       	else if action = 'changeAll then       		begin       			local count := 0;              			// Iterate over the view children template to perform the change operation       			foreach child in sketchEditView.viewChildren do       				begin       					if HasSlot( child, 'text ) then       						begin       							// Make sure that changeStr is a valid string.  It could be nil if       							// the user didn't fill in the "Change To" field.       							local newData := if data.changeStr then data.changeStr else "";       							count := count + StrReplace( child.text, data.findStr, newData, nil );       						end;              				end;              			// Update the view to reflect the changes.       			viewDefView:RedoChildren();              			return count;       		end;       end,     symbol:       kStationerySymbol		// one viewDef *must* be the 'default       ,     UpdateStatusBar:       // This method is called if Newton Works updates the status bar.  This       // typically happens if someone registers an auxillary button.  From here       // we have an opportunity to add or remove our buttons from the status bar.       func()       begin       	if kDebugOn then       		print("In the viewDef's UpdateStatusBar method");              	nil;       end,     ShowFoundItem:       // Used for a global Newton find operation       func( entry, finder )       begin       	if kDebugOn then       		print("In the viewDef's ShowFoundItem method");              	// You should hilite the found text here.       end,     viewOriginY: 0,     viewJustify: 240,     SaveData:       func( entry )       begin       	if kDebugOn then       		print("In the viewDef's SaveData method");       		       	// This method is called periodically.  From here       	// you should add any modifications to the target entry       	// that the user has made.              	// Normally you would not need to do anything here because the newtXXX protos       	// handle saving the data.       	       	// Save the viewChildren of the sketchEditView       	target.(kDefSymbol).(kEntryContentsSymbol) := sketchEditView.viewChildren;       	       	// return true so that the entry is saved.       	true;       end,     GetTotalWidth:       // This method returns the total width of the       // scrollable view       func()       begin       	if kDebugOn then       		print("In the viewDef's GetTotalWidth method");              	// Return the local right coordinate of the sketchEditView as the total width       	sketchEditView:LocalBox().right;       end;,     AddToolKeyCommand:       // This method is called when the sketch view is opened and when new tools are installed.       // The format for tools of Sketch is a frame with the the following slots:       //			Item					The string that appears in the popup       //			dataTypeSymbol		This slot must be set to '|Sketch:DTS|       //			symbol				The symbol for this particular tool       //			keyCommand			A key command frame with an additional KeyFn slot.  The       //									KeyFn slot holds the method that is called when the key       //									command is pressed.  See the Newton 2.1 OS documentation       //									on registering key commands for more information.       //			CmdFunc				This slot holds the method that is called when       //									the user selects this item from the tools popup.  It       //									is passed a NewtonScript reference to the view definition       //									view and a NewtonScript reference to the Newton Works base       //									view.       func( theTool )       begin       	// Make sure the tool has a key command frame before trying to register       	// the key command.       	if theTool.keyCommand then       		begin       			// We create a frame here with two slots.  The first slot is the symbol of the tool       			// and the second slot is the key command frame for the tool.  We then add this       			// frame to the toolKeyCommands array in the sketch base view.       			//       			// This is necessary in order to remove the key command information for a tool if       			// the tool is unregistered while Newton Works is open and the current stationery is       			// Sketch.  If Newton Works is opened, we don't receive the ToolsChanged message until        			// _after_ the tool has been removed so there is no way to get the appropriate        			// information to remove the registered key command.       			//       			// Note that the keyCommand slots holds a clone of the tool's keyCommand slot so       			// that things still work correctly if the tool was registered from a package on       			// a card.  In this case, the card could be removed, so we clone that particular       			// frame to avoid getting the "Newton still needs this card" error slip.       			//       			// Note that the keyMessage slot is EnsureInternal'd to handle the case where       			// the tool was registered from a package. In this case, the card could be        			// removed, so we clone that particular frame to avoid getting the "Newton still        			// needs this card" error dialog.       			local theToolFrame := {toolSymbol: EnsureInternal(theTool.symbol), keyCommand: Clone(theTool.keyCommand)};       			AddArraySlot( toolKeyCommands, theToolFrame );       			       			// Finally, add the key command and the keyFn method to the Newton Works base view.       			// They must be added to the Newton Works base view because the status bar is       			// a sibling of the view definition view, and not a descendant of the view        			// definition view.       			newtAppBase:AddKeyCommand( theToolFrame.keyCommand );       			newtAppBase.(theToolFrame.keyCommand.keyMessage) := theToolFrame.keyCommand.keyFn;       		end;       end,     name:       kViewDefName			// String for show button       ,     toolKeyCommands:       // This slot holds an array of key commands that were registered for the tools.       // The array is manipulated in the AddToolKeyCommand and RemoveToolKeyCommand       // methods.       nil,     ToolsChanged:       func( actionSymbol, toolSymbol )       begin       	// If a tool has been installed, then add the key command       	// if one has been defined.       	// If a tool has been removed, then be sure to remove the       	// key command if one was defined.       	if actionSymbol = 'install then       		begin       			// Grab the tool frame for the tool that was installed.       			local theTool := :GetNewtWorksTool( toolSymbol );       			:AddToolKeyCommand( theTool );       		end;       	else if actionSymbol = 'remove then       		:RemoveToolKeyCommand( toolSymbol );       end,     statusRightButtons:       [       ];,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local box := :LocalBox();       	       	// Cache the width and height of the view.  These values       	// are used in the Scroll method.       	self.viewWidth := box.right;       	self.viewHeight := box.bottom;       	       	inherited:?ViewSetupFormScript();       end,     GetTotalHeight:       // This method returns the total height of the       // scrollable view       func()       begin       	if kDebugOn then       		print("In the viewDef's GetTotalHeight method");              	// Return the local bottom coordinate of the sketchEditView is the total height       	sketchEditView:LocalBox().bottom;       end;,     GetScrollableRect:       // This method returns a bounds frame describing the       // visible region of the view       func()       begin       	if kDebugOn then       		print("In the viewDef's GetScrollableRect method");              	// Return the visible region of the scrollable view       	:LocalBox();       end;,     viewClass: 74,     debug: "sketchBaseView",     RemoveToolKeyCommand:       func( toolSymbol )       begin       	// Check and see whether this tool had a key command associated with it       	local pos := LSearch( toolKeyCommands, toolSymbol, 0, '|=|, 'toolSymbol );              	// If it did, then remove the key command, the key function, and       	// remove the tool information from the toolKeyCommands array.       	if pos then       		begin       			newtAppBase:RemoveKeyCommandFrame( toolKeyCommands[pos].keyCommand );       			RemoveSlot( newtAppBase, toolKeyCommands[pos].keyCommand.keyMessage );       			       			RemoveSlot( toolKeyCommands, pos );       		end;       end,     viewOriginX: 0,     protection:       'private // show this only in this app. For instance, DONT show it in IOBox           };sketchEditView :=    {viewFlags: 33553921,     viewFormat: 12289,     viewBounds: {left: 0, top: 0, right: 500, bottom: 300},     viewJustify: 0,     viewSetupFormScript:       // be sure to call inherited:?ViewSetupFormScript()       func()       begin       	local box := :LocalBox();       	       	// Cache the width and height of the view.  These values       	// are used in the sketchBaseView's Scroll method.       	self.viewWidth := box.right;       	self.viewHeight := box.bottom;       	       	inherited:?ViewSetupFormScript();       end,     viewHeight: nil,     viewWidth: nil,     viewSetupChildrenScript:       func()       begin       	// Setup the contents from the target       	self.viewChildren := target.(kDefSymbol).(kEntryContentsSymbol);       	       	inherited:?viewSetupChildrenScript();       end,     debug: "sketchEditView",     viewClass: 77    };AddStepForm(sketchBaseView, sketchEditView);StepDeclare(sketchBaseView, sketchEditView, 'sketchEditView);constant |layout_Sketch ViewDef.lyt| := sketchBaseView;// End of file Sketch ViewDef.lyt// Beginning of file Sketch PrintFormat.lyt// Before Script for "_view005"/***      Newton Developer Technical Support Sample Code****      Sketch, A Newton Works stationery sample****      by Henry Cate and Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/_view005 :=    {     printNextPageScript:       func()       begin       	// Retrun nil to indicate 'only print one page'       	nil;       end,     title: kPrintFormatString,     symbol: kPrintFormatSymbol,     _proto: @200    };_view006 :=    {viewBounds: {top: 30, left: 30, right: -30, bottom: -30},     viewFlags: 1,     viewFont: tsFancy + tsSize(18) + tsBold,     viewJustify: 8434,     viewSetupChildrenScript:       func()       begin       	// Setup the contents from the target. See the Q&As for more info on restoring children of edit views       	self.viewChildren := target.(kDefSymbol).(kEntryContentsSymbol);       	       	inherited:?viewSetupChildrenScript();       end,     viewClass: 77    };AddStepForm(_view005, _view006);constant |layout_Sketch PrintFormat.lyt| := _view005;// End of file Sketch PrintFormat.lyt// Beginning of text file Part Methods/***      Newton Developer Technical Support Sample Code****      Sketch, A Newton Works stationery sample****      by Henry Cate and Ryan Robertson, Newton Developer Technical Support****      Copyright © 1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/InstallScript := func( partFrame, removeFrame )begin	local defSymbol := EnsureInternal( kDefSymbol );		// Install the dataDef and the viewDef.	RegDataDef( defSymbol, GetLayout("Sketch DataDef") );	RegisterViewDef( GetLayout("Sketch ViewDef.lyt"), defSymbol );		// Register the print format (for fax and print) and	// the frame format (for beam and mail)	RegisterViewDef( GetLayout("Sketch PrintFormat.lyt"), defSymbol );	RegisterViewDef( kSketchFrameFormat, defSymbol );		// Register a sample tool for Sketch.  First make sure that	// Newton Works is installed on the Newton device./*	if GetRoot().newtWorks then		GetRoot().newtWorks:RegNewtWorksTool( kSampleToolSymbol, 				{					item:					"My Tool",					dataTypeSymbol:	kDefSymbol,					symbol:				kSampleToolSymbol,					keyCommand:						{							char:			$b,							modifiers:	kCommandModifier,							keyMessage:	'|DoBeepKeyCommand:DTS|,							name:			"Beep",							KeyFn:		func( keyView )								begin									:SysBeep();								end,						},				}); */end;RemoveScript := func( removeFrame )begin	// Remove the dataDef and the viewDef	UnregDataDef( kDefSymbol );	UnregisterViewDef( kStationerySymbol, kDefSymbol );		// Remove the print format and the frame format	UnregisterViewDef( kPrintFormatSymbol, kDefSymbol );	UnregisterViewDef( kFrameFormatSymbol, kDefSymbol );		// Unregister the sample tool for Sketch.  First make sure	// that Newton Works is installed on the Newton device.//	if GetRoot().newtWorks then//		GetRoot().newtWorks:UnregNewtWorksTool( kSampleToolSymbol );end;// End of text file Part Methods
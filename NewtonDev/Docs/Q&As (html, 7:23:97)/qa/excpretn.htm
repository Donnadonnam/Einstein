<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Performance of Exceptions vs Return Codes</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Performance of Exceptions vs Return Codes</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Performance of Exceptions vs Return Codes  (6/9/94)</H3><DL><DD>Q:    What are the performance tradeoffs in writing code that uses try/onexception vs returning and checking error results?<BR><BR>A:    We did a few trials to weight the relative performance.  Consider the following two functions:<BR> <BR><CODE><PRE>    thrower: func(x) begin        if x then            throw('|evt.ex.msg;my.exception|, "Some error occurred");        end;     returner: func(x) begin        if x then            return -1;    // some random error code,        0; // nil, true, whatever.        end; </PRE><BR></CODE>    Code to throw and and handle an exception:<BR><CODE><PRE>    local s;    for i := 1 to kIterations do        try            call thrower with (nil);        onexception |evt.ex.msg;my.exception| do            s := CurrentException().data.message;</PRE><BR></CODE> <BR>    Code to check the return value and handle an error:<BR><CODE><PRE>    local result;    local s;    for i := 1 to kIterations do        if (result := call returner with (nil)) &lt; 0 then            s := ErrorMessageTable[-result];</PRE><BR></CODE> <BR> <BR>    Running the above loops 1000 times took about 45 ticks for the exception loop, and about 15 ticks for the check the return value loop.  From this you might conclude that exception handling is a waste of time.  However, you can often write better code if you use exceptions.  A large part of the time spent in the loop is setting up the exception handler.  Since we commonly want to stop processing when exceptions occur, we can rewrite the function to set up the exception handler once, like this:<BR> <BR><CODE><PRE>local s;try    for i := 1 to kIterations do        call thrower with (nil);    onexception |evt.ex.msg;my.exception| do        s := CurrentException().data.message;</PRE><BR></CODE><BR>    This code takes only 11 ticks for 1000 iterations, an improvement over the return value case, where we'd have to check the result after each call to the function and stop the loop if an error occurred.<BR><BR>    Running the same loops, but passing <CODE>TRUE </CODE>instead of <CODE>NIL </CODE>so the "error" occurs every time was interesting.  The return value loop takes about 60 ticks, mostly due to the time needed to look up the error message.  The exception loop takes a whopping 850 ticks, mostly because of the overhead in the <CODE>CurrentException</CODE>() call.<BR><BR>    With exceptions, you can handle the error at any level up the call chain, without having to worry about each function checking for and returning error results for every sub-function it uses.  This will produce code that performs much better, and will be easier to maintain as well.<BR><BR>    With exceptions, you do not have to worry about the return value for successful function completion.  It is occasionally very difficult to write functions that both have a return value and generate an error code.  The C/C++ solution is to pass a pointer to a variable that is modified with what should otherwise be the return value of the function, which is a technique best avoided.<BR><BR>    As in the above example, you can attach data to exceptions, so there's no need to maintain an error code to string (or whatever) mapping table, which is another boon to maintainability.  (You can still use string constants and so on to aid localization efforts.  Just put the constant in the throw call.)<BR><BR>    Finally, every time an exception occurs you have an opportunity to intercept it with the NTK inspector.   This is also a boon to debugging, because you know something about what's going wrong, and you can set the <CODE>breakOnThrows</CODE> global to stop your code and look at why there's a problem.  With result codes you have a tougher time setting break points. With a good debugger it could be argued that you can set conditional break points on the "check the return value" code, but even when you do this you'll have lost the stack frame of the function that actually had the problem.  With exceptions and <CODE>breakOnThrows</CODE>, all the local context at the time the exception occurred is still available for you to look at, which is an immense aid.<BR> <BR>    Conclusion:  Use exceptions.  The only good reason not to would be if your error handler is very local and if you expect it to be used a lot, and if that's true you should consider rewriting the function.</DL>
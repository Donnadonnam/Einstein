// Text of project StatusReport written on 11/20/95 at 5:07 PM// Beginning of text file MyStatusTemplate.f/***      Newton Developer Technical Support Sample Code****      Status Report, a protoStatusTemplate and DoProgress example****      by J. Christopher Bell and Bob Ebert, Newton Developer Technical Support****      Copyright © 1995 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/constant kActionInProgressString := "An action is already in progress";rf := OpenResFileX(home & "resources");DefConst('kDummyActionIcon, GetPictAsBits("ActionIcon", nil));CloseResFileX(rf);myStatusTemplate := {	_proto: protoStatusTemplate,		vMyInitialGaugeSetup:	// This initial set up is just a convention done by the sample, not required by proto.	// This is a setup frame as passed to protoStatusTemplate:ViewSet(...)		{		name: 'vGauge, 		appSymbol: kAppSymbol, // optional, but we use for cancelRequest...		values: 			{ 			icon: kDummyActionIcon,			statusText: "Saving world…",			closeBox: func() 				begin					// since we show our "in progress view" only when the status view is hidden...					// (note that in our application, the application is always open right now...)					getroot().(kAppSymbol).InProgressView:Show();					base:Hide();				end,			gauge: 0,			},						},			// We could define cancelRequest here. If we don't, the protoStatusButton	// will send the message to the view specified by the appSymbol slot in the	// values frame used by protoStatusTemplate:ViewSet(...)	// CancelRequest: func(reason) ...    		// This slot will provide a self-animating barber pole as an example of 	// custom status template. The name 'vMyBarber should be used with statusView:ViewSet(...).	vMyBarber: 		{		height:	105,		name:	'vMyBarber,		kids: 				[				protoStatusText,				{	_proto: protoStatusBarber,					viewIdleScript: func() 						begin							if Visible(self) then	// if hidden, don't bother with updating barber								base:UpdateIndicator({name: 'vMyBarber, values: {barber: nil}}); // animate barber pole							300; // return number of ticks until returning to viewIdleScript						end,					viewSetupDoneScript: func() 						begin							inherited:?viewSetupDoneScript();							:SetupIdle(1);	// kick off idle script						end,				},				{	_proto: protoStatusButton,					text: "Stop",					// buttonClickScript: func() ... // default is template:CancelRequest()...				},			],					// This initial set up is just a convention done by the sample, not required by proto.		// This is a setup frame as passed to protoStatusTemplate:ViewSet(...)		myInitialSetup: 				{					name: 'vMyBarber, 				appSymbol: kAppSymbol, 				values: 					{ 					icon: kDummyActionIcon,					statusText: "Computing IsHalting…",					closeBox: func() 						begin							// since we show our "in progress view" only when the status view is hidden...							// (note that in our application, the application is always open right now...)							getroot().(kAppSymbol).InProgressView:Show();							base:Hide();						end,					},								},		},};if kDebugOn then	myStatusTemplate.debug := "mystatus";		// for debugging...DefConst('kMyStatusTemplate, myStatusTemplate);// End of text file MyStatusTemplate.f// Beginning of file BaseView.t// Before Script for "baseView"/***      Newton Developer Technical Support Sample Code****      Status Report, a protoStatusTemplate and DoProgress example****      by J. Christopher Bell and Bob Ebert, Newton Developer Technical Support****      Copyright © 1995 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*/baseView :=    {title: kAppName,     viewBounds: {left: 2, top: 2, right: 230, bottom: 302},     viewFormat: 83951953,     statusView:       nil /* holds a reference to the current status view or nil if no current status view       	 * status view may exist but be hidden (note that protoStatusCloseBox defaults to       	 * hiding the status view rather closing it). Our three text button which open the       	 * status view are responsible for setting this slot. Whoever closes the statusView       	 * must be responsible for clearing this slot.       	 */,     ComputeHalting:       func(count)       begin       	if not abortProgress then       		begin       			Sleep(10);	// simulate important thoughts in sleep       			       			       			// We are doing these actions in deferred actions in order to        			// allow the barber pole to update in its viewIdleScript       			AddDelayedSend(base, 'ComputeHalting, [count + 1], 60);       		end       	else       		:CancelRequest('completed);       end,     viewQuitScript:       func()       begin       	// May need to terminate 'actions' in progress here...       	abortProgress := true;	// checked in next pass of ComputeHalting/SaveWorld               	if statusView then       		begin        			// don't leave status view open (or hidden) when app is closed       			statusView:Close();        			statusView := nil;       		end;       end,     viewFlags: 1,     declareSelf: 'base,     CancelRequest:       func(reason)		// 'userCancel (from protoStatusTemplate) or 'completed (from our code)       	begin       		if reason = 'userCancel then       			abortProgress := true; 	// ComputeHalting and SaveWorld will check this and act accordingly...              		InProgressView:Hide();       		if statusView then       			statusView:Close();       		statusView := nil;       		SetValue(InProgressView, 'text, "<String not appearing in this app.>");	// should never appear       	end,     SaveWorld:       func(count)       begin       	// if the user cancelled or we are done       	if not abortProgress and count < 100 then       		begin       			Sleep(10);	// no time to implement actual saving of world...       			       			statusView:UpdateIndicator(       				{       				name: 'vGauge,        				values: {gauge: count }			// change the value for the gauge...       				});       			       			// We are doing these actions in deferred actions in order to        			// return to the event loop to allow the user to hit stop/cancel       			AddDelayedSend(base, 'SaveWorld, [count + 3], 60);       		end       	else       		:CancelRequest('completed);       end,     viewSetupFormScript:       func()       begin       	local b := GetAppParams();       	viewBounds := RelBounds(b.appAreaLeft, b.appAreaTop, b.appAreaWidth,  b.appAreaHeight);       end,     ReOrientToScreen: ROM_DefRotateFunc,     abortProgress: nil,     debug: "baseView",     viewClass: 74    };_view000 := {_proto: @229};AddStepForm(baseView, _view000);_view001 :=    {     menuRightButtons:       [        {	_proto:	protoLargeCloseBox,        	buttonClickScript: func()        		if statusView then        			begin       		 		// Don't let the user close without stopping the actions in progress...        				statusView:Show();        				:Notify(kNotifyAlert, kAppName, "Actions are in progress. You need to cancel those actions first.");        			end;       		else       			base:Close()        }] 		         ,     _proto: @401    };AddStepForm(baseView, _view001);// After Script for "_view001"thisView := _view001;thisview._proto := newtStatusBarNoClose;	// •• latest platform file?StartGauge :=    {     buttonClickScript:       func()       begin       	if statusView then       		begin       			statusView:Show();       			InProgressView:Hide();       			:Notify(kNotifyAlert,kAppName, kActionInProgressString);       		end;       	else       		begin       			statusView := BuildContext(kMyStatusTemplate);       			statusView.initialSetup := kMyStatusTemplate.vMyInitialGaugeSetup;       			statusView:Open();       			abortProgress := nil;		// clear the abort flag (in base view)       			AddDeferredSend(base, 'SaveWorld, [0]); 	// kick off long task	       			SetValue(InProgressView, 'text, "Saving world...");       		end;       		       end,     text: "Save",     viewBounds: {left: -55, top: 50, right: 15, bottom: 63},     viewJustify: 8388630,     debug: "StartGauge",     _proto: @226    };AddStepForm(baseView, StartGauge);gaugetext :=    {text: "An example of a vGauge template.",     viewBounds: {left: 49, top: 45, right: 174, bottom: 70},     viewJustify: 18,     debug: "gaugetext",     _proto: @218    };AddStepForm(baseView, gaugetext);StartBarber :=    {     buttonClickScript:       func()       begin       	if statusView then       		begin       			statusView:Show();       			InProgressView:Hide();       			:Notify(kNotifyAlert, kAppName, kActionInProgressString);       		end;       	else       		begin       			statusView := BuildContext(kMyStatusTemplate);       			statusView.initialSetup := kMyStatusTemplate.vMyBarber.myInitialSetup;       			statusView:Open();       			abortProgress := nil;		// clear the abort flag (in base view)       			AddDeferredSend(base, 'ComputeHalting, [0]); 	// kick off long task	       			SetValue(InProgressView, 'text, "Computing IsHalting...");       		end;       		       end,     text: "Compute",     viewBounds: {left: -55, top: 95, right: 15, bottom: 108},     viewJustify: 8388630,     debug: "StartBarber",     _proto: @226    };AddStepForm(baseView, StartBarber);barbertext :=    {text: "An example of a barber pole (custom) template.",     viewBounds: {left: 50, top: 90, right: 175, bottom: 125},     viewJustify: 18,     debug: "barbertext",     _proto: @218    };AddStepForm(baseView, barbertext);StartDoProgress :=    {     buttonClickScript:       func()       begin       	if statusView then       		begin       			statusView:Show();       			InProgressView:Hide();       			:Notify(kNotifyAlert,kAppName, kActionInProgressString);       		end;       	else       		begin       			local progress;       			local options := {       				icon: kDummyActionIcon,       				statusText: "Preparing Everything",        				titleText: "Preparing stuff",        				gauge: 0,       				closebox: nil,  // !! This is required for DoProgress. If you do not set options.closebox       								// !! to nil, serious errors or data loss could result.       				};       		       			// this is accessible from the workFunc since the workFunc "closes over" this function's context       			dataToPassToWorkFunc := "Preparing";       		       			workFunc := func (contextView) begin        			 for x := 1 to 10 do begin       			   	Sleep(20);		// simulate important work in sleep...       			          			   	local busyStr := dataToPassToWorkFunc && GetRandomWord(1,10);       		       			   	// user may cancel "within" :SetStatus()  (it uses exceptions...)       				contextView:SetStatus('vGauge, { titleText:busyStr, gauge: 10*x});       			 	end;        			 end;       			       			progress := DoProgress('vGauge, options, workFunc);       			if progress = 'cancelled then       				begin       				// do something special if cancelled...       				end;       		end;       	end,     text: "Prepare",     viewBounds: {left: -55, top: 145, right: 15, bottom: 158},     viewJustify: 8388630,     debug: "StartDoProgress",     _proto: @226    };AddStepForm(baseView, StartDoProgress);doprogresstext :=    {text: "An example of DoProgress(…).",     viewBounds: {left: 50, top: 140, right: 175, bottom: 175},     viewJustify: 18,     debug: "doprogresstext",     _proto: @218    };AddStepForm(baseView, doprogresstext);InProgressView :=    {text: "",     viewBounds: {left: 0, top: -60, right: 120, bottom: -44},     viewJustify: 8388754,     viewSetupDoneScript:       func()       begin       	:Hide();       end,     debug: "InProgressView",     _proto: @218    };AddStepForm(baseView, InProgressView);StepDeclare(baseView, InProgressView, 'InProgressView);constant |layout_BaseView.t| := baseView;// End of file BaseView.t
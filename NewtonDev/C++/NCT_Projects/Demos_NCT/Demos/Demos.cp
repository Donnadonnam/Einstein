/***      Newton Developer Technical Support Sample Code****      Demos, very simple C++ demonstration code****      by David Fedor, Newton Developer Technical Support****      Copyright © 1996-1997 by Apple Computer, Inc.  All rights reserved.****      You may incorporate this sample code into your applications without**      restriction.  This sample code has been provided "AS IS" and the**      responsibility for its operation is 100% yours.  You are not**      permitted to modify and redistribute the source as "DTS Sample Code."**      If you are going to re-distribute the source, we require that you**      make it clear in the source that the code was descended from**      Apple-provided sample code, but that you've made changes.*//*Things to remember:  All functions have rcvr argument, even if it is a fn and not a method.  Always return something from every function!  (NILREF is fine)  EQ is almost same as NS = but is different for floats*/#include "NewtonScript.h"#ifdef __cplusplus#define EXTERNC extern "C"#else#define EXTERNC#endifEXTERNC Ref DemonstrateRefs(RefArg rcvr, RefArg x, RefArg y){	// Just the basics here - two arguments, if they're integers	// then their sum is returned, otherwise NIL is returned.	 	RefVar z;		if (IsInt(x) && IsInt(y))		z = MakeInt(RefToInt(x) + RefToInt(y));	else		z = NILREF;	return z;}EXTERNC Ref DemonstrateTypes(RefArg rcvr, RefArg theInt, RefArg theSym,                             RefArg theStr, RefArg theBool, RefArg theFrame){	// This function demonstrates how to check that argument types	// are correct, create a frame and a string on the fly, and	// compare symbols for equality.  Not complex, but important!	 	RefVar res = AllocateFrame();   // create an empty frame		if (IsInt(theInt))		SetFrameSlot(res, SYM(gotTheInt), MakeInt(1+RefToInt(theInt)));	if (IsSymbol(theSym))		if (!EQ(theSym, SYM(skipThisSlot)))			SetFrameSlot(res, SYM(gotTheSymbol), theSym);	if (IsString(theStr))		SetFrameSlot(res, SYM(gotTheString), MakeString("Hello there"));	if ((theBool == TRUEREF) || (theBool == FALSEREF))		SetFrameSlot(res, SYM(gotTheBool), theBool);	if (IsFrame(theFrame))		SetFrameSlot(res, SYM(gotTheFrame), theFrame);	return res;}EXTERNC Ref DemonstrateReals(RefArg rcvr, RefArg r1, RefArg r2){	//  This is a perfect example of how some things are easier to do	//  in NewtonScript than C... reals are stored in binary objects,	//  so you have to lock it and copy the data out and unlock it	//  again.	//	//  All this function does is add together the two real values	//  which are passed in, and returns the result (as a new object).	double d1, d2;	RefVar result;		// make sure they're the right types	if (!IsReal(r1))		ThrowBadTypeWithFrameData(-48405, r1);	if (!IsReal(r2))		ThrowBadTypeWithFrameData(-48405, r2);		// grab the data out of the binary object	WITH_LOCKED_BINARY(r1, r1Ptr) {		d1 = *(double*)r1Ptr;	} END_WITH_LOCKED_BINARY(r1);	WITH_LOCKED_BINARY(r2, r2Ptr) {		d2 = *(double*)r2Ptr;	} END_WITH_LOCKED_BINARY(r2);		// allocate the object which will be our result	result = AllocateBinary(SYM(real), sizeof(double));		// perform the addition and stuff it in our result object	WITH_LOCKED_BINARY(result, resPtr) {		*(double*)resPtr = d1+d2;	} END_WITH_LOCKED_BINARY(result);		return result;}EXTERNC Ref DemonstrateNSCalls(RefArg rcvr){	// This demonstrates calling back into the NewtonScript world.	// It just calls the global function GetRandomWord(8,16) and	// then makes a beep by sending the SysBeep message to the root view.		RefVar theWord;	RefVar rootView;		// Get a random word.	// This is equivalent to the NewtonScript   theWord := GetRandomWord(8,16);	theWord = NSCallGlobalFn(SYM(GetRandomWord), MakeInt(8), MakeInt(16));	// Now beep... 	// This is equivalent to the NewtonScript   GetRoot():SysBeep();	rootView = NSCallGlobalFn(SYM(GetRoot));	NSSend(rootView, SYM(SysBeep));	// (It would have been ok to combine these two lines of code and	//  eliminate the local variable - though it would be slightly less	//  time-efficient because a temporary, invisible RefVar would have	//  been allocated automatically.)		// and return the random word	return theWord;}
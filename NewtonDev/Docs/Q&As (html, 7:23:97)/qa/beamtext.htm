<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Beam is Partially Available for Text Routing</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Beam is Partially Available for Text Routing</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B>NEW: </B>Beam is Partially Available for Text Routing  (5/22/97)</H3><DL><DD>Q:    My application doesn't support <CODE>'frame</CODE> dataTypes. Why is Beam available in my Action picker in Newton 2.1 OS? <BR><BR>A:    The Beam transport in Newton 2.1 OS supports the <CODE>'text</CODE> dataType. If any routing formats for your data supports text export (a <CODE>format.dataTypes</CODE> array  includes <CODE>'text</CODE>), Beam will be available. Unfortunately, there is a bug in current Newton 2.1 OS devices such that Beam does not convert the target to text before sending it. Transports that support sending text should use the <CODE>kItemToTextFunc</CODE>  function (in the Newton 2.x platform files), and that function calls the format's <CODE>TextScript</CODE> to convert the item to text. Since Beam does not do this, this gives the appearance that the item is being sent as <CODE>'frame</CODE>, a dataType that may not be supported by your application's routing formats. <BR><BR>    There are several workarounds (with the first choice recommended):<BR>    #1) Add support for the <CODE>'frame </CODE>datatype. In your routing format, add <CODE>'frame</CODE> to the <CODE>dataTypes</CODE> slot. This will allow all <CODE>'frame</CODE> transports, including  mail transports that can send attachments, to send mail with your application. This will allow your application to avoid text-specific bugs in Beam. For the best user interface, we recommend that you write stationery for your data so that users can view the item in the In Box or Out Box. See the Newton Programmers Guide and Reference for more information about writing and registering stationery. Note that you can test your application with Put Away, using  the built-in Beam transport as well as the DTS sample "Archive Transport".<BR><BR>    #2) Provide a text-only format that converts the item to text in the <CODE>format:SetupItem(...)</CODE>  method. If you don't support overviews or other mechanisms that use multiple item targets, change <CODE>item.body</CODE> to be a new frame of the form <CODE>{text: "the converted item to text", class: 'text}</CODE>. Note that this format should not also support the <CODE>'frame</CODE> dataType because you are destructively modifying the item.<BR><BR>    If you do support multiple item targets, you have to do more work because the items are not split up into seperate items before your <CODE>SetupItem</CODE> method is called. You can use the code like the following in your <CODE>SetupItem</CODE> format after calling the inherited method:<BR><BR><CODE><PRE>// get a 'cursor' to iterate over the items.// Note: this still returns a 'cursor' even if item.body wasn't reallocal cursor := GetTargetCursor(item.body, nil);local newArray := [];local entry := cursor:entry();while (entry) do    begin        // convert item to text in whatever way you normally do it...        // For instance, you might call your format's textscript...        entry := {            text: "blah blah" && entry.a && entry.b,            class: 'text            };         AddArraySlot(newArray, entry);        entry := cursor:Next();    end;        item.body := CreateTargetCursor(classof(item.body), newArray);// remember to return 'item' from SetupItemitem </PRE><BR>    </CODE>You might be wondering if you could route the <CODE>'frame</CODE> data by hiding the data in extra slots in <CODE>item.body</CODE>. If you did that, the item would be much larger than necessary to route <CODE>'frame</CODE> data, and will not be Put Away properly because the <CODE>'class</CODE> slot is set to <CODE>'text</CODE>, not your original data class). If you actually want to support <CODE>'text </CODE>and <CODE>'frame</CODE> dataTypes, use a single <CODE>protoFrameFormat</CODE> with dataTypes <CODE>['frame, 'text] </CODE>and do not convert the <CODE>item.body</CODE> as illustrated above. (This is actually recommendation #1 above).<BR><BR>     Note that <CODE>'text</CODE> stationery must be registered in order to view the item in the In Box and Out Box. Such stationery is not  necessarily installed on the receiving device. Some mail transport packages may have installed <CODE>'text</CODE> stationery, but you may choose not to rely on this. If you are interested in writing text stationery, see the DTS sample "MinMail" and the Newton Programmers Guide and Reference for more information about writing and registering stationery.<BR></DL>
<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Floating Point Numbers Are Approximations</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Floating Point Numbers Are Approximations</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Floating Point Numbers Are Approximations  (3/28/97)</H3><DL><DD>Q:    The functions <CODE>Floor</CODE> and <CODE>Ceiling</CODE> seem broken.  For instance, <CODE>Floor(12.2900 * 10000)</CODE> returns 122899, not 122900. What's going on? <BR><BR>A:    This is not a bug in <CODE>Floor</CODE> or <CODE>Ceiling</CODE>. This happens because of the way floating point numbers are stored, and the limitation is common to many real number representations.  In the same way that 1/3 cannot accurately be represented in a finite number of digits in base 10 (it is .3333333333...), likewise 1/10 cannot be exactly represented as a fractional part in base 2.  Because number printers typically round to a small number of significant digits, you don't normally notice this.  The NTK inspector, for example, displays only 5 significant figures in floating point numbers.  However, if you display the number with enough precision, you'll see the representation error, where the real is actually slightly larger or smaller than the intended value.<BR><CODE>        FormattedNumberStr(0.1, "%.18f")  -&gt;  "0.100000000000000010"</CODE><BR><CODE><PRE>    FormattedNumberStr(0.3, "%.18f")  -&gt;  "0.299999999999999990"</PRE><BR></CODE><BR>    The functions <CODE>Floor</CODE> and <CODE>Ceiling</CODE> are strict, and do not attempt to take this error into account.  In the example, <CODE>12.29</CODE> is actually <CODE>12.2899999999999990</CODE>, which multiplied by <CODE>10000</CODE> is <CODE>122,899.999999999990</CODE>.  The largest integer less than this number (<CODE>Floor</CODE>) is correctly <CODE>122899</CODE>.<BR><BR>    There are usually ways to work around this problem, depending on what you are trying to accomplish.  To convert a floating point number to an integer, use <CODE>RIntToL</CODE>, which rounds to the nearest integer avoiding the problems caused with round-off error and <CODE>Floor</CODE> or <CODE>Ceiling</CODE>.  <CODE>RIntToL(x)</CODE> produces the same result that <CODE>Floor(Round(x))</CODE> would produce.<BR><CODE><PRE>    RIntToL(12.29*10000)  -&gt;  122900</PRE><BR></CODE><BR>    If you need to format a number for display, use a formatting function such as <CODE>FormattedNumberStr</CODE>.  These functions typically round to the nearest displayable value.  To display 2 decimal digits, use "%.2f":<BR><CODE><PRE>    FormattedNumberStr(12.29, "%.2f")  -&gt;  "12.29"</PRE><BR></CODE><BR>    If you're working with fixed point numbers such as dollar amounts, consider using integers instead of reals.  By representing the value in pennies (or mils, or whatever) you can avoid the imprecision of reals.  For example, represent <CODE>$29.95</CODE> as the integer <CODE>2995</CODE> or <CODE>29950</CODE>, then divide by <CODE>100</CODE> or <CODE>1000</CODE> to display the number.  If you do this, keep in mind that there is a maximum representable integer value, <CODE>0x1FFFFFFF</CODE> or <CODE>536870911</CODE>, which is sufficient to track over 5 million dollars as pennies, but can't go much over that.<BR><BR>     If you really need to find the greatest integer less than a certain number and can't tolerate how <CODE>Floor</CODE> deals with round off errors, you'll need to do some extra work keeping track of the precision of the number and the magnitude of the round off error.  It's worthwhile to read a good numeric methods reference.  Floating point numbers in NewtonScript are represented by IEEE 64-bit reals, which are accurate to around 15 decimal digits.  The function <CODE>NextAfterD</CODE> provides a handy way to see how 'close together' floating point numbers are.<BR>        <CODE><PRE>        FormattedNumberStr(NextAfterD(0.3, kInfinity), "%.18f");                                                    -&gt;  "0.300000000000000040"</CODE></PRE></DL>
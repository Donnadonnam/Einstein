// HISTORY//// 10/20/95		G. Toto		Added HISTORY for Shortcuts 1.0a1.// 10/20/95		G. Toto		Changed st() to use StackTraceOld() to accomodate change in NSDT 2.1a2.// 10/20/95		G. Toto		Amplified comment for SetupMyDebug().// 10/20/95		G. Toto		Fixed ClassOf() bug in NSDBreakLoopEntry().// 10/20/95		G. Toto		Modified InstallScript and RemoveScript to reduce heap usage.// 11/09/95		G. Toto		Fixed spelling error in SetupMyDebug().// 2/13/96		PSC			Renamed kShortCutFrame to kFunctionsToInstall// 11/17/96		PSC			Added a bunch of new functions, initialize stackTracePrintDepth, misc cleanupDefineGlobalConstant('kExitBreakloopFunction, func() ExitBreakLoop());DefineGlobalConstant('kFunctionsToInstall,{	// Functions for examining where the program is stopped	qs:					func() QuickStackTrace(),					w:					func() Where(),	st:					func() StackTraceOld(),		// Functions for stepping	s:					func() Step(),							// Execute on (byte code) instruction	si:					func() StepIn(),						// Execute a function call or message send, stopping inside the invoked function or method	so:					func() StepOut(),						// Complete the execution of the current function stopping in the function that called it	// Functions for continuing execution		e:					kExitBreakloopFunction,					// Exit the current break loop (continue execution)	run:				kExitBreakloopFunction,	r:					kExitBreakloopFunction,	cont:				kExitBreakloopFunction,	contto:				func(pc) rununtil( cf(), pc),	runto:				func(pc) rununtil( cf(), pc),		Contat:				func( pc )						begin							setcpc( pc );							ExitBreakLoop();						end,			// Functions for looking at local variables and slots		gl:					func(var)					GetNamedVar(0, var),						// get local	sl:					func(var, value)			SetNamedVar(0, var, value),					// set local	gv:					func(var)					GetVariable(getself(), var),				// get slot	sv:					func(var, value)			getself().(whereisslotset(var)) := value,	// set slot	gs:					func(var)					GetVariable(getself(), var),				// get slot	ss:					func(var, value)			getself().(whereisslotset(var)) := value,	// set slot	gli:				func(i, var)				GetNamedVar(i, var),						// get i'th local	sli:				func(i, var, value)			SetNamedVar(i, var, value),					// set i'th local	gvi:				func(i, var)				GetVariable(getselfi(i), var),				// get i'th slot	svi:				func(i, var, value)			getselfi(i).(whereisslotset(var)) := value,	// set i'th slot	gsi:				func(i, var)				GetVariable(getselfi(i), var),				// get i'th slot	ssi:				func(i, var, value)			getselfi(i).(whereisslotset(var)) := value,	// set i'th slot	getalllocalsi:		func(i)						GetAllNamedVars(i),							// get all locals for i'th level	// functions for looking at parameters pushed on values stack	args:				func()						GetAllTempVars(0),							// get all arguments on value stack	values:				func()						GetAllTempVars(0),							// get all arguments on value stack	gettop:				func()						getarg(0),									// get top of stack	replacetop:			func(newValue)				SetTempVar(0, 0, newValue),					// replace top of value stack	argsi:				func(i)						GetAllTempVars(i),							// get all args to i'th function call on stack	getarg:				func(offset)				GetTempVar(0, offset),						// get offset'th arg on stack	getargi:			func(i, offset)				GetTempVar(i, offset),						// get offset'th arg to i'th function call on stack	setarg:				func(offset, newValue)		SetTempVar(0, offset, newValue),			// set offset'th arg	setargi:			func(i, offset, newValue)	SetTempVar(i, offset, newValue),			// set offset'th arg to i'th function call on stack	WhereIsSlot:		func(aSymbol) 				GetPathToSlot(getself(), aSymbol),	WhereIsSlotSet:		func(aSymbol) 				GetPathWhereSet(getself(), aSymbol),	// Functions for looking at self and implementor		getselfi:			func(i)						GetCurrentReceiver(i),						// get i'th self	getimpl:			func()						GetCurrentImplementor(0),					// get implementor	getimpli:			func(i)						GetCurrentImplementor(i),					// get i'th implementor	// Functions for looking at variables (and self) from the stack		gett:				func(i, var) GetTempVar(i, var),	sett:				func(i, var, value) SetTempVar(i, var, value),	getn:				func(i, var) GetNamedVar(i, var),	setn:				func(i, var, value) SetNamedVar(i, var, value),	getself:			func() GetCurrentReceiver( 0 ),	focus:				func(it)						begin							DefGlobalVar('focus, it);							GetCurrentReceiver( focus );						end,	glf:				func(it) GetTempVar( focus, it ),	gvf:				func(it) GetVariable( GetCurrentReceiver( focus ), it ),	// Functions for setting and clearing breakpoints		stop:				func( name, pc )						begin							local fn := if ClassOf (name ) = 'Symbol then											call Compile( SPrintObject( name ) ) with ();								 		else								 			name;							local bp := InstallBreakPoint(fn, pc);							bp.fn		 := fn;							bp.name	:= name;						end,							stopat:				func(pc) stop( cf(), pc ),	stopatend:			func() stop( cf(), Length( cf().instructions ) - 1 ),	stopend:			func(fn) stop( fn, Length( fn.instructions ) - 1 ),	stopendfn:			func(fn) stop(fn, Length(fn.instructions) - 1),	stophere:			func() stopat( cpc() ),	clearbp:			func(i) RemoveBreakPoint( allbps()[ i ] ),	clearat:			func(pc) RemoveBreakPoint( findbpat( pc ) ),	clearhere:			func() clearat( cpc() ),	clearallbps:		func() RemoveAllBreakPoints(),		// Functions for enabling and disabling breakpoints		disablebp:			func( i ) getbp( i ).disabled := True,	enablebp:			func( i ) getbp( i ).disabled := Nil,	disableallbps:		func()						begin							SetupMyDebug(nil);							GloballyEnableBreakPoints( Nil );						end,	enableallbps:		func()						begin							SetupMyDebug(true);							GloballyEnableBreakPoints( True );						end,		// Functions for examining breakpoints		allbps:				func()						begin							local bps := GetAllBreakPoints();							if bps then bps.programCounter else '[];						end,		listbps:			func()						begin							local i := 0;							foreach bp in allbps() do							begin								print( i & $: && bp.name & $, && bp.programCounter );								i := i + 1;							end;						end,									findbp:				func( name, pc )						begin							foreach bp in allbps() do								if ( bp.name = name ) AND ( bp.programCounter = pc ) then									return bp;						end,									findbpat:			func(pc)						begin							foreach bp in allbps() do								if ( bp.instructions = cf().instructions ) AND ( bp.programCounter = pc ) then									return bp;						end,									getbp:				func( i ) allbps()[ i ],		listdisabledbps:	func()						begin							local i:= 0;							foreach bp in allbps() do							begin								if bp.disabled then print( i & ":" && bp.name & "," && bp.programCounter );								i := i + 1;							end;						end,											listenabledbps:		func()						begin							local i := 0;							foreach bp in allbps() do							begin								if NOT bp.disabled then print( i & ":" && bp.name & "," && bp.programCounter );								i := i + 1;							end;						end,		// Functions for looking the program counter		cpc:				func() getcpc( 0 ),	pc:					func() getcpc( 0 ),	setcpc:				func( pc ) SetCurrentPC(pc),	cf:					func() getcf( 0 ),	getcpc:				func(level) GetCurrentPC( level ),	getcf:				func(level) GetCurrentFunction( level ),	endfn:				func(fn) Length( fn.instructions ),		// Functions for disassembing functions		dis:				func( a, b, c ) DisasmRange( a, b, c ),	dischunk:			func( pc ) dis( cf(), pc, pc + 50),	dishere:			func()						begin							dis( cf(), max( 0, cpc() - 30 ), cpc() + 10 );							print( "pc = " & cpc() );						end,	disnext:			func()						begin							print( "pc = " & cpc() );							dis( cf(), Max( 0, cpc() - 10 ), cpc() + 30 );						end,		disbp:				func(i)						begin							local bp := getbp( i );							local pc := bp.programCounter;							print("pc = " & pc);							dis( bp.fn, Max( 0, pc - 10 ), pc + 20 );						end,		disend:				func()						begin							local last := Length( cf().instructions );							dischunk( max( 0, last - 10 ) );						end,	disendfn:			func(fn)						begin							local last := Length( fn.instructions );							dis( fn, max( 0, last - 10 ), last );						end,	// Function to setup your debugging session the way you like it! Called whenever 	// breakpoints are enabled or disabled in the NSD Tools AboutBox.	//	// leave this function here even if you don't do anything with it! NS Debug Tools	// tests for this function to decide whether or not to add the "(with shortcuts)"	// notation in the splash screen.		SetupMyDebug:	func( debugNowEnabled )	begin			if debugNowEnabled then		begin					DefGlobalVar(EnsureInternal('breakOnThrows), True);			DefGlobalVar('printDepth, 3);			DefGlobalVar('printLength, 50);			DefGlobalVar(EnsureInternal('stackTracePrintDepth), -1);				end		else		begin					DefGlobalVar(EnsureInternal('breakOnThrows), Nil);			DefGlobalVar('printDepth, 1);			DefGlobalVar('printLength, 30);			UnDefGlobalVar('stackTracePrintDepth);				end;				Write(if debugNowEnabled then "BREAKPOINTS ENABLED\n" else "BREAKPOINTS DISABLED\n");		Write("breakOnThrows  = " & if breakOnThrows then "True\n" else "Nil\n");		Write("printDepth     = " & NumberStr( printDepth ) & $\n);		Write("printLength    = " & NumberStr( printLength ) & $\n);			end,			// This function, if defined, is called before BreakLoop() on a break or breakpoint.	// Note that pc may be Nil ( ROM or C function ), and paramArray may be empty.	//	// Return True if you want the BreakLoop() to be entered, Nil to skip the BreakLoop().	//	NSDBreakLoopEntry://	func( function, pc, paramArray )//	begin////		if ClassOf( paramArray) = 'paramNameAndValues then//		begin//		//			// paramArray looks like [ param1Name, param1Value, param2Name, param2Value, ... ]//			//		end//		else	// 'paramValues//		begin////			// paramArray looks like [ param1Value, param2Value, ... ]//	//		end;////		True;		// allow breakloop//		//	end;		// this function is called after the BreakLoop() is exited ( it is called even if		// NSDBreakLoopEntry() returned Nil ). didBreakLoopHappen is True or Nil depending		// on whether or not the BreakLoop was entered.		//	NSDBreakLoopExit://	func( didBreakLoopHappen )//	begin////	end;});
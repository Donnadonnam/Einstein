<HTML><HEAD><TITLE>Newton 2.x Q&amp;A: Function Size and "Closed Over" Environment</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H2>Function Size and "Closed Over" Environment</H2><H4> One of the Newton 2.x OS Q&amp;As<BR>Copyright © 1997 Newton, Inc.  All Rights Reserved. Newton, Newton Technology, Newton Works, the Newton, Inc. logo, the Newton Technology logo, the Light Bulb logo and MessagePad are trademarks of Newton, Inc. and may be registered in the U.S.A. and other countries. Windows is a registered trademark of Microsoft Corp. All other trademarks and company names are the intellectual property of their respective owners.</H4><BR>For the most recent version of the Q&amp;As on the World Wide Web, check the URL: <CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you've copied this file locally,<A HREF="qa.htm">click here to go to the main Newton Q&amp;A page.</A><BR>This document was exported on 7/23/97.</CENTER><H3><HR><B> </B>Function Size and "Closed Over" Environment  (7/18/94)</H3><DL><DD>Q:    I want to create several frames (for soup entries) that all share a single function, but when I try to store one of these frames to a soup, I run out of memory.  Can several frames share a function and still be written to a soup?  My code looks like this:<BR><CODE><PRE>    ...    local myFunc := func(...) ...;    local futureSoupEntries := Array(10, nil);    for i := 0 to 9 do        futureSoupEntries[i] := {            someSlots: ...,            aFunction: myFunc,        };    ...</PRE><BR></CODE>A:    When a function is defined within another function, the lexically enclosing scope (locals and paramaters) and message context (self) are "closed over" into the function body.  When NewtonScript searches for a variable to match a symbol in a function, it first searches the local scope, then any lexically enclosing scopes, then the message context (self), then the _proto and _parent chains from the message context, then finally the global variables.<BR><BR>    Functions constructed within another function, as in your example, will have this enclosing lexical scope, which is the locals and parameters of the function currently being executed, plus the message context (self) when the function is created.  Depending on the size of this function and how it's constructed, this could be very large.  (Self might be the application's base view, for example.)<BR><BR>    A <CODE>TotalClone</CODE> is made during the process of adding an entry to a soup, and this includes the function body, lexical scopes, and message context bound up within any functions in the frame.  All this  can take up a lot of space.<BR><BR>    If you create the function at compile time (perhaps with <CODE>DefConst('kMyFunc, func(...) ...)</CODE>)  it will not have the lexically enclosing scope, and the message context at compile time is defined to be an empty frame, and so cloning such a function will take less space.  You can use the constant <CODE>kMyFunc</CODE> within the initializer for the frame, and each frame will still reference the same function body.  (Additionally, the symbol <CODE>kMyFunc</CODE> will not be included in the package, since it is only needed at compile time.)<BR><BR>    If the soup entries are only useful when your package is installed, you might consider instead replacing the function body with a symbol when you write the entry to the soup.  When the entry is read from the soup, replace the symbol with the function itself, or use a <CODE>_proto</CODE> based scheme instead.  Each soup entry will necessarily contain a complete copy of the function, but if you can guarantee that the function body will always be available within your application's package, it might be unnecessarily redundant to store a copy with each soup entry.<BR></DL>
/*	File:		FDIL.h, v2.0	Contains:	Public interface to the Desktop Integration Library	Copyright:	Apple Computer, Inc. 1997-98, all rights reserved.*/#ifndef __FDIL_H#define __FDIL_H#include "DIL.h"#ifdef __cplusplusextern "C" {#endif#ifdef DIL_ForDebug	#define FD_TrackMemory		1#else	#define FD_HandleIsOpaque	1#endif/* --- FDIL error numbers --- */	/* Hard errors -- you should always be looking for these. */#define kFD_UnknownStreamVersion		(kFD_ErrorBase - 1)#define kFD_StreamCorrupted				(kFD_ErrorBase - 2)#define kFD_UnsupportedCompression		(kFD_ErrorBase - 3)#define kFD_CouldNotCompressData		(kFD_ErrorBase - 4)#define kFD_CouldNotDecompressData		(kFD_ErrorBase - 5)#define kFD_UnsupportedStoreVersion		(kFD_ErrorBase - 6)#define kFD_ErrorCreatingStore			(kFD_ErrorBase - 7)#define kFD_ErrorWritingToStore			(kFD_ErrorBase - 8)#define kFD_ErrorReadingFromStore		(kFD_ErrorBase - 9)	/* Soft errors -- you get these only if you feed in bad data. */#define kFD_FDILNotInitialized			(kFD_ErrorBase - 19)#define kFD_ExpectedInteger				(kFD_ErrorBase - 20)#define kFD_ExpectedPointerObject		(kFD_ErrorBase - 21)#define kFD_ExpectedImmediate			(kFD_ErrorBase - 22)#define kFD_ExpectedMagicPointer		(kFD_ErrorBase - 23)#define kFD_ExpectedArray				(kFD_ErrorBase - 24)#define kFD_ExpectedFrame				(kFD_ErrorBase - 25)#define kFD_ExpectedBinary				(kFD_ErrorBase - 26)#define kFD_ExpectedLargeBinary			(kFD_ErrorBase - 27)#define kFD_ExpectedReal				(kFD_ErrorBase - 28)#define kFD_ExpectedString				(kFD_ErrorBase - 29)#define kFD_ExpectedSymbol				(kFD_ErrorBase - 30)#define kFD_ExpectedChar				(kFD_ErrorBase - 31)#define kFD_NULLPointer					(kFD_ErrorBase - 40)#define kFD_ExpectedPositiveValue		(kFD_ErrorBase - 41)#define kFD_ExpectedNonNegativeValue	(kFD_ErrorBase - 42)#define kFD_ValueOutOfRange				(kFD_ErrorBase - 43)#define kFD_SymbolTooLong				(kFD_ErrorBase - 44)#define kFD_IllegalCharInSymbol			(kFD_ErrorBase - 45)#define kFD_InvalidClass				(kFD_ErrorBase - 46)#define kFD_PointerObjectIsFree			(kFD_ErrorBase - 47)	/* Internal errors -- you should never see these. */#define kFD_LBReadingFromUnwrittenPage	(kFD_ErrorBase - 50)/***	The FD_Handle type*/#ifdef FD_HandleIsOpaque	typedef long		FD_Handle;#else	struct FD_ObjectHeader;	typedef struct FD_Handle	{		long	ref;		struct FD_ObjectHeader**	entry;	} FD_Handle;#endif/***	Handy common values. Use them as values passed in to**	functions. Never compare (using FD_Equal) an object to**	them to see if it's NIL or not. Instead, use FD_IsNIL**	and FD_NotNIL.*/DILAPI extern FD_Handle	kFD_NIL;DILAPI extern FD_Handle	kFD_True;/***	Values returned by FD_GetClass (in addition to kFD_NIL**	and classes you define).*/DILAPI extern FD_Handle	kFD_SymArray;DILAPI extern FD_Handle	kFD_SymBoolean;DILAPI extern FD_Handle	kFD_SymChar;DILAPI extern FD_Handle	kFD_SymInteger;DILAPI extern FD_Handle	kFD_SymFrame;DILAPI extern FD_Handle	kFD_SymMagicPointer;DILAPI extern FD_Handle	kFD_SymReal;DILAPI extern FD_Handle	kFD_SymString;DILAPI extern FD_Handle	kFD_SymSymbol;DILAPI extern FD_Handle	kFD_SymWeird_Immediate;/***	Values that can be specified for the second**	parameter of FD_MakeImmediate.*/typedef enum FD_ImmediateType{	kFD_ImmedSpecial = 0,	kFD_ImmedChar,	kFD_ImmedBoolean,	kFD_ImmedReserved} FD_ImmediateType;/***	Compression types for FD_MakeLargeBinary.*/typedef enum FD_CompressionType{	kFD_NoCompression,	kFD_LZCompression,	kFD_ZippyCompression} FD_CompressionType;/*** Forward declarations of Large Binary structures.*/struct FD_LargeBinaryProcs;typedef struct FD_LargeBinaryProcs FD_LargeBinaryProcs;/***	Startup/Shutdown*/DILAPI DIL_Error	FD_Startup				(void);DILAPI DIL_Error	FD_Shutdown				(void);/***	Error handling*/DILAPI DIL_Error	FD_GetError				(void);/***	Create objects*/DILAPI FD_Handle	FD_MakeInt				(long);DILAPI FD_Handle	FD_MakeReal				(double);DILAPI FD_Handle	FD_MakeString			(const char*);DILAPI FD_Handle	FD_MakeWideString		(const DIL_WideChar*);DILAPI FD_Handle	FD_MakeSymbol			(const char*);DILAPI FD_Handle	FD_MakeArray			(long size, const char* objClass);DILAPI FD_Handle	FD_MakeFrame			(void);DILAPI FD_Handle	FD_MakeBinary			(long size, const char* objClass);DILAPI FD_Handle	FD_MakeChar				(char);DILAPI FD_Handle	FD_MakeWideChar			(DIL_WideChar);DILAPI FD_Handle	FD_MakeImmediate		(long type, long value);DILAPI FD_Handle	FD_MakeMagicPointer		(long value);DILAPI FD_Handle	FD_MakeLargeBinary		(long size,												const char* objClass,												long compressionType);/***	Delete objects*/DILAPI DIL_Error	FD_Dispose				(FD_Handle);DILAPI DIL_Error	FD_DeepDispose			(FD_Handle);DILAPI long			FD_AllocatedMemory		(void);/***	Object predicates*/DILAPI int			FD_IsInt				(FD_Handle);DILAPI int			FD_IsPointerObject		(FD_Handle);DILAPI int			FD_IsReal				(FD_Handle);DILAPI int			FD_IsString				(FD_Handle);DILAPI int			FD_IsRichString			(FD_Handle);DILAPI int			FD_IsSymbol				(FD_Handle);DILAPI int			FD_IsArray				(FD_Handle);DILAPI int			FD_IsFrame				(FD_Handle);DILAPI int			FD_IsBinary				(FD_Handle);DILAPI int			FD_IsChar				(FD_Handle);DILAPI int			FD_IsFree				(FD_Handle);DILAPI int			FD_IsImmediate			(FD_Handle);DILAPI int			FD_IsMagicPointer		(FD_Handle);DILAPI int			FD_IsBoolean			(FD_Handle);DILAPI int			FD_IsLargeBinary		(FD_Handle);DILAPI int			FD_IsSubClass			(FD_Handle, const char*);/***	Data accessors.****	FD_GetString and FD_GetWideString work like strncpy: bufLen characters**	will be copied. If there's enough room, a terminating NULL will be added.**	They differ from strncpy in that they will not necessarily pad out the**	rest of the buffer with NULLs.*/DILAPI long			FD_GetInt				(FD_Handle);DILAPI double		FD_GetReal				(FD_Handle);DILAPI DIL_Error	FD_GetString			(FD_Handle, char*, long bufLen);DILAPI DIL_Error	FD_GetWideString		(FD_Handle, DIL_WideChar*, long bufLen);DILAPI const char*	FD_GetSymbol			(FD_Handle);DILAPI void*		FD_GetBinaryData		(FD_Handle);DILAPI char			FD_GetChar				(FD_Handle);DILAPI DIL_WideChar FD_GetWideChar			(FD_Handle);DILAPI int			FD_IsNIL				(FD_Handle);DILAPI int			FD_NotNIL				(FD_Handle);DILAPI FD_Handle	FD_ASCIIString			(FD_Handle);DILAPI DIL_Error	FD_GetImmediate			(FD_Handle, long* type, long* value);DILAPI long			FD_GetMagicPointer		(FD_Handle);DILAPI DIL_Error	FD_ReadFromLargeBinary	(FD_Handle, long offset, void*, long count);DILAPI DIL_Error	FD_WriteToLargeBinary	(FD_Handle, long offset, const void*, long count);DILAPI DIL_Error	FD_SetLargeBinaryProcs	(const FD_LargeBinaryProcs*);/***	Array manipulation*/DILAPI DIL_Error	FD_InsertArraySlot		(FD_Handle array, long pos, FD_Handle item);DILAPI DIL_Error	FD_AppendArraySlot		(FD_Handle array, FD_Handle item);DILAPI FD_Handle	FD_RemoveArraySlot		(FD_Handle array, long pos);DILAPI DIL_Error	FD_RemoveArraySlotCount	(FD_Handle array, long pos, long count);DILAPI FD_Handle	FD_SetArraySlot			(FD_Handle array, long pos, FD_Handle item);DILAPI FD_Handle	FD_GetArraySlot			(FD_Handle array, long pos);/***	Frame manipulation*/DILAPI FD_Handle	FD_SetFrameSlot			(FD_Handle frame, const char* slotName, FD_Handle item);DILAPI FD_Handle	FD_GetFrameSlot			(FD_Handle frame, const char* slotName);DILAPI int			FD_FrameHasSlot			(FD_Handle frame, const char* slotName);DILAPI FD_Handle	FD_RemoveFrameSlot		(FD_Handle frame, const char* slotName);DILAPI FD_Handle	FD_GetIndFrameSlot		(FD_Handle frame, long pos);DILAPI FD_Handle	FD_GetIndFrameSlotName	(FD_Handle frame, long pos);/***	Heap object manipulation*/DILAPI DIL_Error	FD_SetClass				(FD_Handle, FD_Handle oClass);DILAPI long			FD_GetLength			(FD_Handle);DILAPI DIL_Error	FD_SetLength			(FD_Handle, long newSize);/***	Any object manipulation*/DILAPI FD_Handle	FD_GetClass				(FD_Handle);/***	Object comparison*/DILAPI int			FD_Equal				(FD_Handle, FD_Handle);/***	Object duplication*/DILAPI FD_Handle	FD_Clone				(FD_Handle);DILAPI FD_Handle	FD_DeepClone			(FD_Handle);/***	Object streaming*/DILAPI DIL_Error	FD_Flatten				(FD_Handle, DIL_WriteProc, void* userData);DILAPI FD_Handle	FD_Unflatten			(DIL_ReadProc, void* userData);/***	FD_PrintObject converts an object into some user-readable**	text form. For instance, a frame will be turned into text**	looking something like the following:****		{**			name:	"Fred",**			age:	15,**			phone:	[**						{**							'home,**							"555-1212"**						},**						{**							'work,**							"555-2121"**						}**					]**			...**		}****	As the text is generated, the DIL_WriteProc is called so that**	the application can deal with it as it deems fit. For instance,**	the app could buffer all the text into a Handle or CString**	object, or it could just turn around and call printf("%s", str)**	with it.*/DILAPI DIL_Error	FD_PrintObject			(FD_Handle obj,												const char* EOLString,												DIL_WriteProc,												void* userData);/***	Wide character conversion routines. These routines are written**	in such a way that you can use the same buffer as the source and**	destination. Also, since they work with NewtonScript-native**	strings, the NS_WideChars are or should be in big-endian format.*/enum {	kFD_MacEncoding,	kFD_WindowsEncoding,#ifdef macintosh	kFD_DefaultEncoding = kFD_MacEncoding#else	kFD_DefaultEncoding = kFD_WindowsEncoding#endif};DILAPI DIL_Error	FD_ConvertFromWideChar	(char* dest,												const DIL_WideChar* src,												long numChars);DILAPI DIL_Error	FD_ConvertToWideChar	(DIL_WideChar* dest,												const char* src,												long numChars);DILAPI DIL_Error	FD_SetWideCharEncoding	(long encoding);/***	Pages are passed around in FD_PageBuffs. These buffers are used to contain**	both compressed and uncompressed data. The amount of the buffer that's**	actually used in the compressed case is stored in fLength.*/#define kFD_PageChunkSize		(1024L)#define kFD_CompressionExtra	(288L)typedef struct FD_PageBuff{	long	fLength;	char	fData[kFD_PageChunkSize + kFD_CompressionExtra];					/* Only fLength bytes used */} FD_PageBuff;/***	Functions needed to support large binary objects.**	Any of these can be NULL if desired.*/struct FD_LargeBinaryProcs{	DIL_Error	(*Create)		(void**);	DIL_Error	(*SetNumPages)	(void**, long pageCount);	DIL_Error	(*ReadPage)		(void**, long pageNum, FD_PageBuff*);	DIL_Error	(*WritePage)	(void**, long pageNum, const FD_PageBuff*);	DIL_Error	(*Destroy)		(void**);};/***	Stock large binary functions you can use if you want. gNullStoreProcs**	merely read and discard the data. gMemoryStoreProcs read the data into**	memory and keep it there. gDiskStoreProcs store the data in tempory**	files on disk (which are deleted when the Destroy proc is called).*/DILAPI extern const FD_LargeBinaryProcs	kFD_NullStoreProcs;DILAPI extern const FD_LargeBinaryProcs	kFD_MemoryStoreProcs;DILAPI extern const FD_LargeBinaryProcs	kFD_DiskStoreProcs;/***	Versions of the above functions that allocate memory.**	These versions record the file and line that made the allocation.**	FD_CheckForMemoryLeaks will then report that location when it**	detects memory leaks.*/#ifdef FD_TrackMemoryDILAPI FD_Handle	FDT_MakeReal		(double,					const char*, long);DILAPI FD_Handle	FDT_MakeString		(const char*,				const char*, long);DILAPI FD_Handle	FDT_MakeWideString	(const DIL_WideChar*,		const char*, long);DILAPI FD_Handle	FDT_MakeSymbol		(const char*,				const char*, long);DILAPI FD_Handle	FDT_MakeArray		(long, const char*,			const char*, long);DILAPI FD_Handle	FDT_MakeFrame		(							const char*, long);DILAPI FD_Handle	FDT_MakeBinary		(long, const char*,			const char*, long);DILAPI FD_Handle	FDT_MakeLargeBinary	(long, const char*, long,	const char*, long);DILAPI FD_Handle	FDT_Clone			(FD_Handle,					const char*, long);DILAPI FD_Handle	FDT_DeepClone		(FD_Handle,					const char*, long);DILAPI FD_Handle	FDT_Unflatten		(DIL_ReadProc, void*,		const char*, long);#define	FD_MakeReal(v)				FDT_MakeReal		(v,			__FILE__, __LINE__)#define	FD_MakeString(v)			FDT_MakeString		(v,			__FILE__, __LINE__)#define	FD_MakeWideString(v)		FDT_MakeWideString	(v,			__FILE__, __LINE__)#define	FD_MakeSymbol(v)			FDT_MakeSymbol		(v,			__FILE__, __LINE__)#define	FD_MakeArray(v, c)			FDT_MakeArray		(v, c,		__FILE__, __LINE__)#define	FD_MakeFrame()				FDT_MakeFrame		(			__FILE__, __LINE__)#define	FD_MakeBinary(v, c)			FDT_MakeBinary		(v, c,		__FILE__, __LINE__)#define	FD_MakeLargeBinary(v, c, t)	FDT_MakeLargeBinary	(v, c, t,	__FILE__, __LINE__)#define	FD_Clone(v)					FDT_Clone			(v,			__FILE__, __LINE__)#define	FD_DeepClone(v)				FDT_DeepClone		(v,			__FILE__, __LINE__)#define	FD_Unflatten(v, d)			FDT_Unflatten		(v, d,		__FILE__, __LINE__)DILAPI long		FD_CheckForMemoryLeaks(const char* EOLString, DIL_WriteProc, void* userData);#endif	/* FD_TrackMemory *//*	Macro magic to make sure the right library is used in conjuction with	the right preprocessor options. If you define DIL_ForDebug, then you	MUST link with the debug version of the FDIL. If you don't define	DIL_ForDebug, then you MUST link with the release version of the FDIL.	Failing to do so will cause FD_Startup() to break into the debugger	when called.	Also, floating point values manipulated by the Newton OS and, hence,	by this library must be in standard IEEE-754 format. Passing the size	of doubles to the library helps ensure that the right compiler options	are being used.*/DILAPI DIL_Error		FD_RealStartup(long DIL_ForDebug_defined, long sizeOfDouble);#ifdef DIL_ForDebug	#define FD_Startup()	FD_RealStartup(1, sizeof(double))#else	#define FD_Startup()	FD_RealStartup(0, sizeof(double))#endif#ifdef __cplusplus}	/* extern "C" */#endif#endif	/* __FDIL_H */